{"version":3,"file":"chunks/vendors-node_modules_symbol-sdk_src_symbol_index_js.6f0a5146651bd4bd3ac9.js","mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9DA;AACA;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5LA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrPA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;;;;;;;;;;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzGA;AACA;AACA;AASA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACpZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;;;;;;;;;;;;;;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC/zBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACvMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChHA;AACA;AACA;AACA;AACA;AAOA;AAKA;AACA;AACA;AACA;AACA;AACA;AAsGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvlWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5iCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://GUI/./node_modules/@noble/hashes/esm/_assert.js","webpack://GUI/./node_modules/@noble/hashes/esm/_md.js","webpack://GUI/./node_modules/@noble/hashes/esm/_u64.js","webpack://GUI/./node_modules/@noble/hashes/esm/crypto.js","webpack://GUI/./node_modules/@noble/hashes/esm/hkdf.js","webpack://GUI/./node_modules/@noble/hashes/esm/hmac.js","webpack://GUI/./node_modules/@noble/hashes/esm/sha256.js","webpack://GUI/./node_modules/@noble/hashes/esm/sha3.js","webpack://GUI/./node_modules/@noble/hashes/esm/sha512.js","webpack://GUI/./node_modules/@noble/hashes/esm/utils.js","webpack://GUI/./node_modules/symbol-crypto-wasm-web/symbol_crypto_wasm.js","webpack://GUI/./node_modules/symbol-crypto-wasm-web/symbol_crypto_wasm_bg.js","webpack://GUI/./node_modules/symbol-sdk/src/Cipher.js","webpack://GUI/./node_modules/symbol-sdk/src/RuleBasedTransactionFactory.js","webpack://GUI/./node_modules/symbol-sdk/src/SharedKey.js","webpack://GUI/./node_modules/symbol-sdk/src/TransactionDescriptorProcessor.js","webpack://GUI/./node_modules/symbol-sdk/src/facade/SymbolFacade.js","webpack://GUI/./node_modules/symbol-sdk/src/impl/CipherHelpers.js","webpack://GUI/./node_modules/symbol-sdk/src/impl/ed25519.js","webpack://GUI/./node_modules/symbol-sdk/src/impl/ed25519_js.js","webpack://GUI/./node_modules/symbol-sdk/src/impl/ed25519_wasm.js","webpack://GUI/./node_modules/symbol-sdk/src/impl/external/tweetnacl-nacl-fast-symbol.js","webpack://GUI/./node_modules/symbol-sdk/src/symbol/KeyPair.js","webpack://GUI/./node_modules/symbol-sdk/src/symbol/MessageEncoder.js","webpack://GUI/./node_modules/symbol-sdk/src/symbol/Network.js","webpack://GUI/./node_modules/symbol-sdk/src/symbol/SharedKey.js","webpack://GUI/./node_modules/symbol-sdk/src/symbol/TransactionFactory.js","webpack://GUI/./node_modules/symbol-sdk/src/symbol/VotingKeysGenerator.js","webpack://GUI/./node_modules/symbol-sdk/src/symbol/idGenerator.js","webpack://GUI/./node_modules/symbol-sdk/src/symbol/index.js","webpack://GUI/./node_modules/symbol-sdk/src/symbol/merkle.js","webpack://GUI/./node_modules/symbol-sdk/src/symbol/metadata.js","webpack://GUI/./node_modules/symbol-sdk/src/symbol/models.js","webpack://GUI/./node_modules/symbol-sdk/src/symbol/models_ts.js","webpack://GUI/./node_modules/symbol-sdk/src/utils/base32.js"],"sourcesContent":["function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n// copied from utils\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\nexport { anumber, anumber as number, abytes, abytes as bytes, ahash, aexists, aoutput };\nconst assert = {\n    number: anumber,\n    bytes: abytes,\n    hash: ahash,\n    exists: aexists,\n    output: aoutput,\n};\nexport default assert;\n//# sourceMappingURL=_assert.js.map","import { aexists, aoutput } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n/**\n * Polyfill for Safari 14\n */\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/**\n * Choice: a ? b : c\n */\nexport const Chi = (a, b, c) => (a & b) ^ (~a & c);\n/**\n * Majority function, true if any two inputs is true\n */\nexport const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// BigUint64Array is too slow as per 2024, so we implement it using Uint32Array.\n// TODO: re-check https://issues.chromium.org/issues/42212588\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","export const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","import { ahash, anumber } from './_assert.js';\nimport { toBytes } from './utils.js';\nimport { hmac } from './hmac.js';\n// HKDF (RFC 5869)\n// https://soatok.blog/2021/11/17/understanding-hkdf/\n/**\n * HKDF-Extract(IKM, salt) -> PRK\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash\n * @param ikm\n * @param salt\n * @returns\n */\nexport function extract(hash, ikm, salt) {\n    ahash(hash);\n    // NOTE: some libraries treat zero-length array as 'not provided';\n    // we don't, since we have undefined as 'not provided'\n    // https://github.com/RustCrypto/KDFs/issues/15\n    if (salt === undefined)\n        salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros\n    return hmac(hash, toBytes(salt), toBytes(ikm));\n}\n// HKDF-Expand(PRK, info, L) -> OKM\nconst HKDF_COUNTER = /* @__PURE__ */ new Uint8Array([0]);\nconst EMPTY_BUFFER = /* @__PURE__ */ new Uint8Array();\n/**\n * HKDF-expand from the spec.\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in octets\n */\nexport function expand(hash, prk, info, length = 32) {\n    ahash(hash);\n    anumber(length);\n    if (length > 255 * hash.outputLen)\n        throw new Error('Length should be <= 255*HashLen');\n    const blocks = Math.ceil(length / hash.outputLen);\n    if (info === undefined)\n        info = EMPTY_BUFFER;\n    // first L(ength) octets of T\n    const okm = new Uint8Array(blocks * hash.outputLen);\n    // Re-use HMAC instance between blocks\n    const HMAC = hmac.create(hash, prk);\n    const HMACTmp = HMAC._cloneInto();\n    const T = new Uint8Array(HMAC.outputLen);\n    for (let counter = 0; counter < blocks; counter++) {\n        HKDF_COUNTER[0] = counter + 1;\n        // T(0) = empty string (zero length)\n        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n        HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n            .update(info)\n            .update(HKDF_COUNTER)\n            .digestInto(T);\n        okm.set(T, hash.outputLen * counter);\n        HMAC._cloneInto(HMACTmp);\n    }\n    HMAC.destroy();\n    HMACTmp.destroy();\n    T.fill(0);\n    HKDF_COUNTER.fill(0);\n    return okm.slice(0, length);\n}\n/**\n * HKDF (RFC 5869): extract + expand in one step.\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information\n * @param length - length of output keying material in octets\n */\nexport const hkdf = (hash, ikm, salt, info, length) => expand(hash, extract(hash, ikm, salt), info, length);\n//# sourceMappingURL=hkdf.js.map","import { ahash, abytes, aexists } from './_assert.js';\nimport { Hash, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nexport class HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        ahash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        aexists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        abytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","import { HashMD, Chi, Maj } from './_md.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per late 2024.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\n/**\n * SHA2-224 hash function\n */\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","import { abytes, aexists, anumber, aoutput } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport { Hash, u32, toBytes, wrapConstructor, wrapXOFConstructorWithOpts, isLE, byteSwap32, } from './utils.js';\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nexport class Keccak extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        anumber(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = u32(this.state);\n    }\n    keccak() {\n        if (!isLE)\n            byteSwap32(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!isLE)\n            byteSwap32(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        aexists(this);\n        const { blockLen, state } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        aexists(this, false);\n        abytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        anumber(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        aoutput(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\nexport const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nexport const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nexport const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nexport const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nexport const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nexport const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nexport const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nexport const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map","import { HashMD } from './_md.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends HashMD {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexport class SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nexport class SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nexport class SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nexport const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());\nexport const sha512_224 = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\nexport const sha512_256 = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\nexport const sha384 = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n//# sourceMappingURL=sha512.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nexport const byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('utf8ToBytes expected string, got ' + typeof str);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return crypto.randomBytes(bytesLength);\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","import * as wasm from \"./symbol_crypto_wasm_bg.wasm\";\nimport { __wbg_set_wasm } from \"./symbol_crypto_wasm_bg.js\";\n__wbg_set_wasm(wasm);\nexport * from \"./symbol_crypto_wasm_bg.js\";\n","let wasm;\nexport function __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    if (typeof(heap_next) !== 'number') throw new Error('corrupt heap');\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction _assertNum(n) {\n    if (typeof(n) !== 'number') throw new Error('expected a number argument');\n}\n\nlet stack_pointer = 128;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n/**\n* Generates public key given secret key.\n* @param {number} hash_mode\n* @param {Uint8Array} sk_boxed\n* @param {Uint8Array} pk_boxed\n*/\nexport function crypto_sign_keypair(hash_mode, sk_boxed, pk_boxed) {\n    try {\n        _assertNum(hash_mode);\n        wasm.crypto_sign_keypair(hash_mode, addBorrowedObject(sk_boxed), addBorrowedObject(pk_boxed));\n    } finally {\n        heap[stack_pointer++] = undefined;\n        heap[stack_pointer++] = undefined;\n    }\n}\n\n/**\n* Signs message.\n* @param {number} hash_mode\n* @param {Uint8Array} sk_boxed\n* @param {Uint8Array} message_boxed\n* @param {Uint8Array} signature_boxed\n*/\nexport function crypto_private_sign(hash_mode, sk_boxed, message_boxed, signature_boxed) {\n    try {\n        _assertNum(hash_mode);\n        wasm.crypto_private_sign(hash_mode, addBorrowedObject(sk_boxed), addBorrowedObject(message_boxed), addBorrowedObject(signature_boxed));\n    } finally {\n        heap[stack_pointer++] = undefined;\n        heap[stack_pointer++] = undefined;\n        heap[stack_pointer++] = undefined;\n    }\n}\n\n/**\n* Verifies signature.\n* @param {number} hash_mode\n* @param {Uint8Array} pk_boxed\n* @param {Uint8Array} message_boxed\n* @param {Uint8Array} signature_boxed\n* @returns {boolean}\n*/\nexport function crypto_private_verify(hash_mode, pk_boxed, message_boxed, signature_boxed) {\n    try {\n        _assertNum(hash_mode);\n        const ret = wasm.crypto_private_verify(hash_mode, addBorrowedObject(pk_boxed), addBorrowedObject(message_boxed), addBorrowedObject(signature_boxed));\n        return ret !== 0;\n    } finally {\n        heap[stack_pointer++] = undefined;\n        heap[stack_pointer++] = undefined;\n        heap[stack_pointer++] = undefined;\n    }\n}\n\nfunction logError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        let error = (function () {\n            try {\n                return e instanceof Error ? `${e.message}\\n\\nStack:\\n${e.stack}` : e.toString();\n            } catch(_) {\n                return \"<failed to stringify thrown value>\";\n            }\n        }());\n        console.error(\"wasm-bindgen: imported JS function that was not marked as `catch` threw an error:\", error);\n        throw e;\n    }\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (typeof(arg) !== 'string') throw new Error('expected a string argument');\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n        if (ret.read !== arg.length) throw new Error('failed to pass whole string');\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n/**\n* Supported hash modes.\n*/\nexport const HashMode = Object.freeze({\n/**\n* Keccak hash.\n*/\nKeccak:0,\"0\":\"Keccak\",\n/**\n* SHA2 hash.\n*/\nSha2_512:1,\"1\":\"Sha2_512\", });\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbg_error_f851667af71bcfc6() { return logError(function (arg0, arg1) {\n    try {\n        console.error(getStringFromWasm0(arg0, arg1));\n    } finally {\n        wasm.__wbindgen_free(arg0, arg1);\n    }\n}, arguments) };\n\nexport function __wbg_new_abda76e883ba8a5f() { return logError(function () {\n    const ret = new Error();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_stack_658279fe44541cf6() { return logError(function (arg0, arg1) {\n    const ret = getObject(arg1).stack;\n    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n}, arguments) };\n\nexport function __wbg_new_537b7341ce90bb31() { return logError(function (arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5() { return logError(function (arg0, arg1, arg2) {\n    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_slice_0ab69c1e013c6cae() { return logError(function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).slice(arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_length_27a2afe8ab42b09f() { return logError(function (arg0) {\n    const ret = getObject(arg0).length;\n    _assertNum(ret);\n    return ret;\n}, arguments) };\n\nexport function __wbg_set_17499e8aa4003ebd() { return logError(function (arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n}, arguments) };\n\nexport function __wbg_buffer_cf65c07de34b9a08() { return logError(function (arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_memory() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n","import ByteArray from './ByteArray.js';\n/* eslint-disable no-unused-vars */\nimport { PublicKey, SharedKey256 } from './CryptoTypes.js';\n/* eslint-enable no-unused-vars */\nimport crypto from 'crypto';\n\n// ReactNative Buffer polyfill only allows Buffers to be passed to Buffer.concat\n// in order to support ReactNative, all Uint8Arrays must be wrapped in Buffer when calling crypto cipher APIs\nconst toBufferView = input => {\n\tconst typedByteArray = input instanceof ByteArray ? input.bytes : input;\n\treturn Buffer.from(typedByteArray.buffer, typedByteArray.byteOffset, typedByteArray.length);\n};\n\nconst concatArrays = (lhs, rhs) => {\n\tconst result = new Uint8Array(lhs.length + rhs.length);\n\tresult.set(lhs);\n\tresult.set(rhs, lhs.length);\n\treturn result;\n};\n\n// region AesCbcCipher\n\n/**\n * Performs AES CBC encryption and decryption with a given key.\n */\nexport class AesCbcCipher {\n\t/**\n\t * Creates a cipher around an aes shared key.\n\t * @param {SharedKey256} aesKey AES shared key.\n\t */\n\tconstructor(aesKey) {\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tthis._key = aesKey;\n\t}\n\n\t/**\n\t * Encrypts clear text.\n\t * @param {Uint8Array} clearText Clear text to encrypt.\n\t * @param {Uint8Array} iv IV bytes.\n\t * @returns {Uint8Array} Cipher text.\n\t */\n\tencrypt(clearText, iv) {\n\t\tconst cipher = crypto.createCipheriv('aes-256-cbc', toBufferView(this._key), toBufferView(iv));\n\n\t\tconst cipherText = cipher.update(toBufferView(clearText));\n\t\tconst padding = cipher.final();\n\n\t\treturn concatArrays(cipherText, padding);\n\t}\n\n\t/**\n\t * Decrypts cipher text.\n\t * @param {Uint8Array} cipherText Cipher text to decrypt.\n\t * @param {Uint8Array} iv IV bytes.\n\t * @returns {Uint8Array} Clear text.\n\t */\n\tdecrypt(cipherText, iv) {\n\t\tconst decipher = crypto.createDecipheriv('aes-256-cbc', toBufferView(this._key), toBufferView(iv));\n\n\t\tconst clearText = decipher.update(toBufferView(cipherText));\n\t\tconst padding = decipher.final();\n\n\t\treturn concatArrays(clearText, padding);\n\t}\n}\n\n// endregion\n\n// region AesGcmCipher\n\n/**\n * Performs AES GCM encryption and decryption with a given key.\n */\nexport class AesGcmCipher {\n\t/**\n\t * Byte size of GCM tag.\n\t * @type {number}\n\t */\n\tstatic TAG_SIZE = 16;\n\n\t/**\n\t * Creates a cipher around an aes shared key.\n\t * @param {SharedKey256} aesKey AES shared key.\n\t */\n\tconstructor(aesKey) {\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tthis._key = aesKey;\n\t}\n\n\t/**\n\t * Encrypts clear text and appends tag to encrypted payload.\n\t * @param {Uint8Array} clearText Clear text to encrypt.\n\t * @param {Uint8Array} iv IV bytes.\n\t * @returns {Uint8Array} Cipher text with appended tag.\n\t */\n\tencrypt(clearText, iv) {\n\t\tconst cipher = crypto.createCipheriv('aes-256-gcm', toBufferView(this._key), toBufferView(iv));\n\n\t\tconst cipherText = cipher.update(toBufferView(clearText));\n\t\tcipher.final(); // no padding for GCM\n\n\t\tconst tag = cipher.getAuthTag();\n\n\t\treturn concatArrays(cipherText, tag);\n\t}\n\n\t/**\n\t * Decrypts cipher text with appended tag.\n\t * @param {Uint8Array} cipherText Cipher text with appended tag to decrypt.\n\t * @param {Uint8Array} iv IV bytes.\n\t * @returns {Uint8Array} Clear text.\n\t */\n\tdecrypt(cipherText, iv) {\n\t\tconst decipher = crypto.createDecipheriv('aes-256-gcm', toBufferView(this._key), toBufferView(iv));\n\n\t\tconst tagStartOffset = cipherText.length - AesGcmCipher.TAG_SIZE;\n\t\tdecipher.setAuthTag(Buffer.from(cipherText.buffer, tagStartOffset));\n\n\t\tconst clearText = decipher.update(Buffer.from(cipherText.buffer, 0, tagStartOffset));\n\t\tdecipher.final(); // no padding for GCM\n\t\treturn clearText;\n\t}\n}\n\n// endregion\n","import BaseValue from './BaseValue.js';\nimport ByteArray from './ByteArray.js';\nimport TransactionDescriptorProcessor from './TransactionDescriptorProcessor.js';\n\nconst buildEnumStringToValueMap = EnumClass => new Map(Object.getOwnPropertyNames(EnumClass)\n\t.filter(name => name.toUpperCase() === name)\n\t.map(name => [name.toLowerCase(), EnumClass[name]]));\n\nconst nameToEnumValue = (mapping, enumType, enumValueName) => {\n\tif (!mapping.has(enumValueName))\n\t\tthrow RangeError(`unknown value ${enumValueName} for type ${enumType}`);\n\n\treturn mapping.get(enumValueName);\n};\n\nconst buildTypeHintsMap = structValue => {\n\t/** @type {{[key: string]: string}} */\n\tconst typeHints = {};\n\tconst rawTypeHints = structValue.constructor.TYPE_HINTS || {};\n\tObject.getOwnPropertyNames(rawTypeHints).forEach(key => {\n\t\tconst hint = rawTypeHints[key];\n\t\tlet ruleName;\n\t\tif (0 === hint.indexOf('array['))\n\t\t\truleName = hint;\n\t\telse if (0 === hint.indexOf('enum:'))\n\t\t\truleName = hint.substring('enum:'.length);\n\t\telse if (0 === hint.indexOf('pod:'))\n\t\t\truleName = hint.substring('pod:'.length);\n\t\telse if (0 === hint.indexOf('struct:'))\n\t\t\truleName = hint;\n\n\t\tif (ruleName)\n\t\t\ttypeHints[key] = ruleName;\n\t});\n\n\treturn typeHints;\n};\n\nconst typeConverterFactory = (module, customTypeConverter, value) => {\n\tif (customTypeConverter && customTypeConverter(value))\n\t\treturn customTypeConverter(value);\n\n\tif (value instanceof ByteArray) {\n\t\t/** @type {object} */\n\t\tconst ByteArrayClass = value.constructor;\n\n\t\tif (ByteArrayClass.NAME in module)\n\t\t\treturn new module[ByteArrayClass.NAME](value.bytes);\n\n\t\treturn new ByteArrayClass(value.bytes);\n\t}\n\n\treturn value;\n};\n\nconst autoEncodeStrings = entity => {\n\tObject.getOwnPropertyNames(entity).forEach(key => {\n\t\tconst value = entity[key];\n\t\tif ('string' === typeof (value))\n\t\t\tentity[key] = new TextEncoder().encode(value);\n\t});\n};\n\n/**\n * Rule based transaction factory.\n * This class is not intended to be used directly.\n */\nexport default class RuleBasedTransactionFactory {\n\t/**\n\t * Creates a rule based transaction factory for use with catbuffer generated code.\n\t * @param {object} module Catbuffer generated module.\n\t * @param {Function|undefined} typeConverter Type converter.\n\t * @param {Map<string, Function>|undefined} typeRuleOverrides Type rule overrides.\n\t */\n\tconstructor(module, typeConverter = undefined, typeRuleOverrides = undefined) {\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tthis._module = module;\n\n\t\t/**\n\t\t * Tries to coerce a value to a more appropriate type.\n\t\t * @param {object} value Original value.\n\t\t * @returns {object} Type converted value.\n\t\t * @private\n\t\t */\n\t\tthis._typeConverter = value => typeConverterFactory(this._module, typeConverter, value);\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tthis._typeRuleOverrides = typeRuleOverrides || new Map();\n\n\t\t/**\n\t\t * Map of rule names to transform functions.\n\t\t * @type {Map<string, Function>}\n\t\t */\n\t\tthis.rules = new Map();\n\t}\n\n\t/**\n\t * Looks up a class in the wrapped module.\n\t * @param {string} name Class name.\n\t * @returns {Constructable} Class type.\n\t * @private\n\t */\n\t_getModuleClass(name) {\n\t\treturn this._module[name];\n\t}\n\n\t/**\n\t * Creates wrapper for SDK POD types.\n\t * @param {string} name Class name.\n\t * @param {Constructable} PodClass Class type.\n\t */\n\taddPodParser(name, PodClass) {\n\t\tif (this._typeRuleOverrides.has(PodClass)) {\n\t\t\tthis.rules.set(name, this._typeRuleOverrides.get(PodClass));\n\t\t\treturn;\n\t\t}\n\n\t\tthis.rules.set(name, value => (value instanceof PodClass ? value : new PodClass(value)));\n\t}\n\n\t/**\n\t * Creates flag type parser.\n\t * @param {string} name Class name.\n\t */\n\taddFlagsParser(name) {\n\t\tconst FlagsClass = this._getModuleClass(name);\n\t\tconst stringToEnum = buildEnumStringToValueMap(FlagsClass);\n\n\t\tthis.rules.set(name, flags => {\n\t\t\tif ('string' === typeof (flags)) {\n\t\t\t\tconst enumArray = flags.split(' ').map(flagName => nameToEnumValue(stringToEnum, name, flagName));\n\t\t\t\treturn new FlagsClass(enumArray.map(flag => flag.value).reduce((x, y) => x | y));\n\t\t\t}\n\n\t\t\tif ('number' === typeof (flags) && Number.isInteger(flags))\n\t\t\t\treturn new FlagsClass(flags);\n\n\t\t\treturn flags;\n\t\t});\n\t}\n\n\t/**\n\t * Creates enum type parser.\n\t * @param {string} name Class name.\n\t */\n\taddEnumParser(name) {\n\t\tconst EnumClass = this._getModuleClass(name);\n\t\tconst stringToEnum = buildEnumStringToValueMap(EnumClass);\n\n\t\tthis.rules.set(name, enumValue => {\n\t\t\tif ('string' === typeof (enumValue))\n\t\t\t\treturn nameToEnumValue(stringToEnum, name, enumValue);\n\n\t\t\tif ('number' === typeof (enumValue) && Number.isInteger(enumValue))\n\t\t\t\treturn new EnumClass(enumValue);\n\n\t\t\treturn enumValue;\n\t\t});\n\t}\n\n\t/**\n\t * Creates struct parser (to allow nested parsing).\n\t * @param {string} name Class name.\n\t */\n\taddStructParser(name) {\n\t\tconst StructClass = this._getModuleClass(name);\n\n\t\tthis.rules.set(`struct:${name}`, structDescriptor => {\n\t\t\tconst structProcessor = this._createProcessor(structDescriptor);\n\t\t\tconst structValue = new StructClass();\n\n\t\t\tconst allTypeHints = buildTypeHintsMap(structValue);\n\t\t\tstructProcessor.setTypeHints(allTypeHints);\n\n\t\t\tstructProcessor.copyTo(structValue);\n\t\t\treturn structValue;\n\t\t});\n\t}\n\n\t/**\n\t * Creates array type parser, based on some existing element type parser.\n\t * @param {string} name Class name.\n\t */\n\taddArrayParser(name) {\n\t\tconst elementRule = this.rules.get(name);\n\t\tif (!elementRule)\n\t\t\tthrow Error(`cannot create array type parser because element rule \"${name}\" is unknown`);\n\n\t\tconst elementName = name.replace(/^struct:/, '');\n\t\tthis.rules.set(`array[${elementName}]`, values => values.map(value => elementRule(value)));\n\t}\n\n\t/**\n\t * Autodetects rules using reflection.\n\t */\n\tautodetect() {\n\t\tObject.getOwnPropertyNames(this._module).forEach(key => {\n\t\t\tconst cls = this._module[key];\n\t\t\tif (Object.prototype.isPrototypeOf.call(BaseValue.prototype, cls.prototype))\n\t\t\t\tthis.addPodParser(key, cls);\n\t\t});\n\t}\n\n\t/**\n\t * Creates an entity from a descriptor using a factory.\n\t * @param {Function} factory Factory function.\n\t * @param {object} descriptor Entity descriptor.\n\t * @returns {object} Newly created entity.\n\t */\n\tcreateFromFactory(factory, descriptor) {\n\t\tconst processor = this._createProcessor(descriptor);\n\t\tconst entityType = processor.lookupValue('type');\n\t\tconst entity = factory(entityType);\n\n\t\tconst allTypeHints = buildTypeHintsMap(entity);\n\t\tprocessor.setTypeHints(allTypeHints);\n\t\tprocessor.copyTo(entity, ['type']);\n\n\t\tautoEncodeStrings(entity);\n\t\treturn entity;\n\t}\n\n\t/**\n\t * Creates a transaction descriptor processor around a descriptor.\n\t * @param {object} descriptor Transaction descriptor.\n\t * @returns {TransactionDescriptorProcessor} Transaction descriptor processor.\n\t * @private\n\t */\n\t_createProcessor(descriptor) {\n\t\treturn new TransactionDescriptorProcessor(descriptor, this.rules, this._typeConverter);\n\t}\n}\n\n// region type declarations\n\n/**\n * Constructable class type.\n * @class\n * @typedef {new(...args: any[]) => object} Constructable\n */\n\n// endregion\n","// this file contains implementation details and is not intended to be used directly\n\nimport {\n\t/* eslint-disable no-unused-vars */\n\tPublicKey,\n\t/* eslint-enable no-unused-vars */\n\tSharedKey256\n} from './CryptoTypes.js';\nimport tweetnacl from './impl/external/tweetnacl-nacl-fast-symbol.js';\nimport { hkdf } from '@noble/hashes/hkdf';\nimport { sha256 } from '@noble/hashes/sha256';\n\n// order matches order of exported methods\nconst tweetnacl_lowlevel = (/** @type {any} */ (tweetnacl)).lowlevel;\nconst {\n\tgf, neq25519, pack, unpackneg\n} = tweetnacl_lowlevel;\n\n// publicKey is canonical if the y coordinate is smaller than 2^255 - 19\n// note: this version is based on server version and should be constant-time\n// note 2: don't touch it, you'll break it\nconst isCanonicalKey = publicKey => {\n\tconst buffer = publicKey.bytes;\n\tlet a = (buffer[31] & 0x7F) ^ 0x7F;\n\tfor (let i = 30; 0 < i; --i)\n\t\ta |= buffer[i] ^ 0xFF;\n\n\ta = (a - 1) >>> 8;\n\n\tconst b = (0xED - 1 - buffer[0]) >>> 8;\n\treturn 0 !== 1 - (a & b & 1);\n};\n\nconst isInMainSubgroup = point => {\n\tconst { scalarmult, L } = tweetnacl_lowlevel;\n\tconst result = [gf(), gf(), gf(), gf()];\n\t// multiply by group order\n\tscalarmult(result, point, L);\n\n\t// check if result is neutral element\n\tconst gf0 = gf();\n\tconst areEqual = neq25519(result[1], result[2]);\n\tconst isZero = neq25519(gf0, result[0]);\n\n\t// yes, this is supposed to be  bit OR\n\treturn 0 === (areEqual | isZero);\n};\n\n/**\n * Creates a shared secret factory given a hash function.\n * @param {object} hasher Hash object to use.\n * @returns {function(Uint8Array, PublicKey): Uint8Array} Creates a shared secret from a raw private key and public key.\n */\nconst deriveSharedSecretFactory = hasher => (privateKeyBytes, otherPublicKey) => {\n\tconst { scalarmult, Z } = tweetnacl_lowlevel;\n\tconst point = [gf(), gf(), gf(), gf()];\n\n\tif (!isCanonicalKey(otherPublicKey) || 0 !== unpackneg(point, otherPublicKey.bytes) || !isInMainSubgroup(point))\n\t\tthrow Error('invalid point');\n\n\t// negate point == negate X coordinate and 't'\n\tZ(point[0], gf(), point[0]);\n\tZ(point[3], gf(), point[3]);\n\n\tconst scalar = new Uint8Array(64);\n\n\ttweetnacl.lowlevel.crypto_hash(scalar, privateKeyBytes, 32, hasher);\n\tscalar[0] &= 248;\n\tscalar[31] &= 127;\n\tscalar[31] |= 64;\n\n\tconst result = [gf(), gf(), gf(), gf()];\n\tscalarmult(result, point, scalar);\n\n\tconst sharedSecret = new Uint8Array(32);\n\tpack(sharedSecret, result);\n\treturn sharedSecret;\n};\n\n/**\n * Creates a shared key factory given a tag and a hash function.\n * @param {string} info Tag used in HKDF algorithm.\n * @param {object} hasher Hash object to use.\n * @returns {function(Uint8Array, PublicKey): SharedKey256} Creates a shared key from a raw private key and public key.\n */\nconst deriveSharedKeyFactory = (info, hasher) => {\n\tconst deriveSharedSecret = deriveSharedSecretFactory(hasher);\n\treturn (privateKeyBytes, otherPublicKey) => {\n\t\tconst sharedSecret = deriveSharedSecret(privateKeyBytes, otherPublicKey);\n\t\treturn new SharedKey256(hkdf(sha256, sharedSecret, undefined, info, 32));\n\t};\n};\n\nexport {\n\tderiveSharedSecretFactory,\n\tderiveSharedKeyFactory\n};\n","/**\n * Processes and looks up transaction descriptor properties.\n * This class is not intended to be used directly.\n */\nexport default class TransactionDescriptorProcessor {\n\t/**\n\t * Creates a transaction descriptor processor.\n\t * @param {object} transactionDescriptor Transaction descriptor.\n\t * @param {Map<string, Function>} typeParsingRules Type-dependent parsing rules.\n\t * @param {Function|undefined} typeConverter Converts a generated type to an sdk type (optional).\n\t */\n\tconstructor(transactionDescriptor, typeParsingRules, typeConverter = undefined) {\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tthis._transactionDescriptor = transactionDescriptor;\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tthis._typeParsingRules = typeParsingRules;\n\n\t\t/**\n\t\t * Tries to coerce a value to a more appropriate type.\n\t\t * @param {object} value Original value.\n\t\t * @returns {object} Type converted value.\n\t\t * @private\n\t\t */\n\t\tthis._typeConverter = typeConverter || (value => value);\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tthis._typeHints = {};\n\t}\n\n\t/**\n\t * Looks up value and applies type hints.\n\t * @param {string} key Key for which to retrieve value.\n\t * @returns {object} Value corresponding to key.\n\t * @private\n\t */\n\t_lookupValueAndApplyTypeHints(key) {\n\t\tif (undefined === this._transactionDescriptor[key])\n\t\t\tthrow RangeError(`transaction descriptor does not have attribute ${key}`);\n\n\t\tlet value = this._transactionDescriptor[key];\n\t\tconst typeHint = this._typeHints[key];\n\t\tconst rule = this._typeParsingRules.get(typeHint);\n\t\tif (rule)\n\t\t\tvalue = rule(value);\n\n\t\treturn value;\n\t}\n\n\t/**\n\t * Looks up the value for key.\n\t * @param {string} key Key for which to retrieve value.\n\t * @returns {object} Value corresponding to key.\n\t */\n\tlookupValue(key) {\n\t\tconst value = this._lookupValueAndApplyTypeHints(key);\n\t\treturn Array.isArray(value)\n\t\t\t? value.map(item => this._typeConverter(item))\n\t\t\t: this._typeConverter(value);\n\t}\n\n\t/**\n\t * Copies all descriptor information to a transaction.\n\t * @param {object} transaction Transaction to which to copy keys.\n\t * @param {Array<string>|undefined} ignoreKeys Keys of descriptor values not to copy (optional).\n\t */\n\tcopyTo(transaction, ignoreKeys = undefined) {\n\t\tObject.getOwnPropertyNames(this._transactionDescriptor).forEach(key => {\n\t\t\tif (ignoreKeys && -1 !== ignoreKeys.indexOf(key))\n\t\t\t\treturn;\n\n\t\t\tif (key.endsWith('Computed'))\n\t\t\t\tthrow RangeError(`cannot explicitly set computed field ${key}`);\n\n\t\t\tif (undefined === transaction[key])\n\t\t\t\tthrow RangeError(`transaction does not have attribute ${key}`);\n\n\t\t\tconst value = this.lookupValue(key);\n\t\t\ttransaction[key] = value;\n\t\t});\n\t}\n\n\t/**\n\t * Sets type hints.\n\t * @param {TypeHintsMap|undefined} typeHints New type hints. // eslint-disable-line valid-jsdoc\n\t */\n\tsetTypeHints(typeHints) {\n\t\tthis._typeHints = typeHints || {};\n\t}\n}\n\n// region type declarations\n\n/**\n * Type hints map.\n * @class\n * @typedef {{[key: string]: string}} TypeHintsMap\n */\n\n// endregion\n","/* eslint-disable no-unused-vars */\nimport { Bip32Node } from '../Bip32.js';\n/* eslint-enable no-unused-vars */\nimport {\n\tHash256,\n\tPrivateKey,\n\tPublicKey,\n\t/* eslint-disable no-unused-vars */\n\tSharedKey256,\n\t/* eslint-enable no-unused-vars */\n\tSignature\n} from '../CryptoTypes.js';\nimport { NetworkLocator } from '../Network.js';\nimport { KeyPair, Verifier } from '../symbol/KeyPair.js';\nimport MessageEncoder from '../symbol/MessageEncoder.js';\nimport {\n\tAddress,\n\tNetwork,\n\t/* eslint-disable no-unused-vars */\n\tNetworkTimestamp\n\t/* eslint-enable no-unused-vars */\n} from '../symbol/Network.js';\nimport { deriveSharedKey } from '../symbol/SharedKey.js';\nimport TransactionFactory from '../symbol/TransactionFactory.js';\nimport { MerkleHashBuilder } from '../symbol/merkle.js';\nimport * as sc from '../symbol/models.js';\nimport { sha3_256 } from '@noble/hashes/sha3';\n\nconst TRANSACTION_HEADER_SIZE = [\n\t4, // size\n\t4, // reserved1\n\tSignature.SIZE, // signature\n\tPublicKey.SIZE, // signer\n\t4 // reserved2\n].reduce((x, y) => x + y);\n\nconst AGGREGATE_HASHED_SIZE = [\n\t4, // version, network, type\n\t8, // maxFee\n\t8, // deadline\n\tHash256.SIZE // transactionsHash\n].reduce((x, y) => x + y);\n\nconst isAggregateTransaction = transactionBuffer => {\n\tconst transactionTypeOffset = TRANSACTION_HEADER_SIZE + 2; // skip version and network byte\n\tconst transactionType = (transactionBuffer[transactionTypeOffset + 1] << 8) + transactionBuffer[transactionTypeOffset];\n\tconst aggregateTypes = [sc.TransactionType.AGGREGATE_BONDED.value, sc.TransactionType.AGGREGATE_COMPLETE.value];\n\treturn aggregateTypes.some(aggregateType => aggregateType === transactionType);\n};\n\nconst transactionDataBuffer = transactionBuffer => {\n\tconst dataBufferStart = TRANSACTION_HEADER_SIZE;\n\tconst dataBufferEnd = isAggregateTransaction(transactionBuffer)\n\t\t? TRANSACTION_HEADER_SIZE + AGGREGATE_HASHED_SIZE\n\t\t: transactionBuffer.length;\n\n\treturn transactionBuffer.subarray(dataBufferStart, dataBufferEnd);\n};\n\n// region SymbolPublicAccount / SymbolAccount\n\n/**\n * Symbol public account.\n */\nexport class SymbolPublicAccount {\n\t/**\n\t * Creates a Symbol public account.\n\t * @param {SymbolFacade} facade Symbol facade.\n\t * @param {PublicKey} publicKey Account public key.\n\t */\n\tconstructor(facade, publicKey) {\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tthis._facade = facade;\n\n\t\t/**\n\t\t * Account public key.\n\t\t * @type {PublicKey}\n\t\t */\n\t\tthis.publicKey = publicKey;\n\n\t\t/**\n\t\t * Account address.\n\t\t * @type {Address}\n\t\t */\n\t\tthis.address = this._facade.network.publicKeyToAddress(this.publicKey);\n\t}\n}\n\n/**\n * Symbol account.\n */\nexport class SymbolAccount extends SymbolPublicAccount {\n\t/**\n\t * Creates a Symbol account.\n\t * @param {SymbolFacade} facade Symbol facade.\n\t * @param {KeyPair} keyPair Account key pair.\n\t */\n\tconstructor(facade, keyPair) {\n\t\tsuper(facade, keyPair.publicKey);\n\n\t\t/**\n\t\t * Account key pair.\n\t\t * @type {KeyPair}\n\t\t */\n\t\tthis.keyPair = keyPair;\n\t}\n\n\t/**\n\t * Creates a message encoder that can be used for encrypting and encoding messages between two parties.\n\t * @returns {MessageEncoder} Message encoder using this account as one party.\n\t */\n\tmessageEncoder() {\n\t\treturn new MessageEncoder(this.keyPair);\n\t}\n\n\t/**\n\t * Signs a Symbol transaction.\n\t * @param {sc.Transaction} transaction Transaction object.\n\t * @returns {Signature} Transaction signature.\n\t */\n\tsignTransaction(transaction) {\n\t\treturn this._facade.signTransaction(this.keyPair, transaction);\n\t}\n\n\t/**\n\t * Cosigns a Symbol transaction.\n\t * @param {sc.Transaction} transaction Transaction object.\n\t * @param {boolean} detached \\c true if resulting cosignature is appropriate for network propagation.\n\t *                           \\c false if resulting cosignature is appropriate for attaching to an aggregate.\n\t * @returns {sc.Cosignature|sc.DetachedCosignature} Signed cosignature.\n\t */\n\tcosignTransaction(transaction, detached = false) {\n\t\treturn this._facade.cosignTransaction(this.keyPair, transaction, detached);\n\t}\n\n\t/**\n\t * Cosigns a Symbol transaction hash.\n\t * @param {Hash256} transactionHash Transaction hash.\n\t * @param {boolean} detached \\c true if resulting cosignature is appropriate for network propagation.\n\t *                           \\c false if resulting cosignature is appropriate for attaching to an aggregate.\n\t * @returns {sc.Cosignature|sc.DetachedCosignature} Signed cosignature.\n\t */\n\tcosignTransactionHash(transactionHash, detached = false) {\n\t\treturn this._facade.static.cosignTransactionHash(this.keyPair, transactionHash, detached);\n\t}\n}\n\n// endregion\n\n/**\n * Facade used to interact with Symbol blockchain.\n */\nexport class SymbolFacade {\n\t/**\n\t * BIP32 curve name.\n\t * @type {string}\n\t */\n\tstatic BIP32_CURVE_NAME = 'ed25519';\n\n\t/**\n\t * Network address class type.\n\t * @type {typeof Address}\n\t */\n\tstatic Address = Address;\n\n\t/**\n\t * Network key pair class type.\n\t * @type {typeof KeyPair}\n\t */\n\tstatic KeyPair = KeyPair;\n\n\t/**\n\t * Network verifier class type.\n\t * @type {typeof Verifier}\n\t */\n\tstatic Verifier = Verifier;\n\n\t/**\n\t * Derives shared key from key pair and other party's public key.\n\t * @param {KeyPair} keyPair Key pair.\n\t * @param {PublicKey} otherPublicKey Other party's public key.\n\t * @returns {SharedKey256} Shared encryption key.\n\t */\n\tstatic deriveSharedKey = deriveSharedKey;\n\n\t/**\n\t * Creates a Symbol facade.\n\t * @param {string|Network} network Symbol network or network name.\n\t */\n\tconstructor(network) {\n\t\t/**\n\t\t * Underlying network.\n\t\t * @type {Network}\n\t\t */\n\t\tthis.network = 'string' === typeof network ? NetworkLocator.findByName(Network.NETWORKS, network) : network;\n\n\t\t/**\n\t\t * Underlying transaction factory.\n\t\t * @type {TransactionFactory}\n\t\t */\n\t\tthis.transactionFactory = new TransactionFactory(this.network);\n\t}\n\n\t/**\n\t * Gets class type.\n\t * @returns {typeof SymbolFacade} Class type.\n\t */\n\tget static() { // eslint-disable-line class-methods-use-this\n\t\treturn SymbolFacade;\n\t}\n\n\t/**\n\t * Creates a network timestamp representing the current time.\n\t * @returns {NetworkTimestamp} Network timestamp representing the current time.\n\t */\n\tnow() {\n\t\treturn this.network.fromDatetime(new Date());\n\t}\n\n\t/**\n\t * Creates a Symbol public account from a public key.\n\t * @param {PublicKey} publicKey Account public key.\n\t * @returns {SymbolPublicAccount} Symbol public account.\n\t */\n\tcreatePublicAccount(publicKey) {\n\t\treturn new SymbolPublicAccount(this, publicKey);\n\t}\n\n\t/**\n\t * Creates a Symbol account from a private key.\n\t * @param {PrivateKey} privateKey Account private key.\n\t * @returns {SymbolAccount} Symbol account.\n\t */\n\tcreateAccount(privateKey) {\n\t\treturn new SymbolAccount(this, new KeyPair(privateKey));\n\t}\n\n\t/**\n\t * Creates a transaction from a (typed) transaction descriptor.\n\t * @param {object} typedDescriptor Transaction (typed) descriptor.\n\t * @param {PublicKey} signerPublicKey Signer public key.\n\t * @param {number} feeMultiplier Fee multiplier.\n\t * @param {number} deadlineSeconds Approximate seconds from now for deadline.\n\t * @param {number} cosignatureCount Number of cosignature spaces to reserve.\n\t * @returns {sc.Transaction} Created transaction.\n\t */\n\tcreateTransactionFromTypedDescriptor(typedDescriptor, signerPublicKey, feeMultiplier, deadlineSeconds, cosignatureCount = 0) {\n\t\tconst rawDescriptor = typedDescriptor.toMap();\n\t\tconst transaction = this.transactionFactory.create({\n\t\t\t...rawDescriptor,\n\n\t\t\tsignerPublicKey,\n\t\t\tdeadline: this.now().addSeconds(deadlineSeconds).timestamp\n\t\t});\n\n\t\t// if cosignatures are specified in the descriptor, use the max of them and cosignatureCount\n\t\tlet cosignatureCountAdjustment = cosignatureCount;\n\t\tif (rawDescriptor.cosignatures) {\n\t\t\tcosignatureCountAdjustment = rawDescriptor.cosignatures.length > cosignatureCount\n\t\t\t\t? 0\n\t\t\t\t: cosignatureCount - rawDescriptor.cosignatures.length;\n\t\t}\n\n\t\tconst transactionWithCosignaturesSize = transaction.size + (cosignatureCountAdjustment * new sc.Cosignature().size);\n\t\ttransaction.fee = new sc.Amount(BigInt(transactionWithCosignaturesSize) * BigInt(feeMultiplier));\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Creates an embedded transaction from a (typed) transaction descriptor.\n\t * @param {object} typedDescriptor Transaction (typed) descriptor.\n\t * @param {PublicKey} signerPublicKey Signer public key.\n\t * @returns {sc.EmbeddedTransaction} Created embedded transaction.\n\t */\n\tcreateEmbeddedTransactionFromTypedDescriptor(typedDescriptor, signerPublicKey) {\n\t\tconst transaction = this.transactionFactory.createEmbedded({\n\t\t\t...typedDescriptor.toMap(),\n\n\t\t\tsignerPublicKey\n\t\t});\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Hashes a Symbol transaction.\n\t * @param {sc.Transaction} transaction Transaction object.\n\t * @returns {Hash256} Transaction hash.\n\t */\n\thashTransaction(transaction) {\n\t\tconst hasher = sha3_256.create();\n\t\thasher.update(transaction.signature.bytes);\n\t\thasher.update(transaction.signerPublicKey.bytes);\n\t\thasher.update(this.network.generationHashSeed.bytes);\n\t\thasher.update(transactionDataBuffer(transaction.serialize()));\n\t\treturn new Hash256(hasher.digest());\n\t}\n\n\t/**\n\t * Gets the payload to sign given a Symbol transaction.\n\t * @param {sc.Transaction} transaction Transaction object.\n\t * @returns {Uint8Array} Verifiable data to sign.\n\t */\n\textractSigningPayload(transaction) {\n\t\treturn new Uint8Array([\n\t\t\t...this.network.generationHashSeed.bytes,\n\t\t\t...transactionDataBuffer(transaction.serialize())\n\t\t]);\n\t}\n\n\t/**\n\t * Signs a Symbol transaction.\n\t * @param {KeyPair} keyPair Key pair.\n\t * @param {sc.Transaction} transaction Transaction object.\n\t * @returns {Signature} Transaction signature.\n\t */\n\tsignTransaction(keyPair, transaction) {\n\t\treturn keyPair.sign(this.extractSigningPayload(transaction));\n\t}\n\n\t/**\n\t * Verifies a Symbol transaction.\n\t * @param {sc.Transaction} transaction Transaction object.\n\t * @param {Signature} signature Signature to verify.\n\t * @returns {boolean} \\c true if transaction signature is verified.\n\t */\n\tverifyTransaction(transaction, signature) {\n\t\tconst verifyBuffer = new Uint8Array(this.extractSigningPayload(transaction));\n\t\treturn new Verifier(transaction.signerPublicKey).verify(verifyBuffer, signature);\n\t}\n\n\t/**\n\t * Cosigns a Symbol transaction hash.\n\t * @param {KeyPair} keyPair Key pair of the cosignatory.\n\t * @param {Hash256} transactionHash Transaction hash.\n\t * @param {boolean} detached \\c true if resulting cosignature is appropriate for network propagation.\n\t *                           \\c false if resulting cosignature is appropriate for attaching to an aggregate.\n\t * @returns {sc.Cosignature|sc.DetachedCosignature} Signed cosignature.\n\t */\n\tstatic cosignTransactionHash(keyPair, transactionHash, detached = false) {\n\t\tconst initializeCosignature = cosignature => {\n\t\t\tcosignature.version = 0n;\n\t\t\tcosignature.signerPublicKey = new sc.PublicKey(keyPair.publicKey.bytes);\n\t\t\tcosignature.signature = new sc.Signature(keyPair.sign(transactionHash.bytes).bytes);\n\t\t};\n\n\t\tif (detached) {\n\t\t\tconst cosignature = new sc.DetachedCosignature();\n\t\t\tcosignature.parentHash = new sc.Hash256(transactionHash.bytes);\n\t\t\tinitializeCosignature(cosignature);\n\t\t\treturn cosignature;\n\t\t}\n\n\t\tconst cosignature = new sc.Cosignature();\n\t\tinitializeCosignature(cosignature);\n\t\treturn cosignature;\n\t}\n\n\t/**\n\t * Cosigns a Symbol transaction.\n\t * @param {KeyPair} keyPair Key pair of the cosignatory.\n\t * @param {sc.Transaction} transaction Transaction object.\n\t * @param {boolean} detached \\c true if resulting cosignature is appropriate for network propagation.\n\t *                           \\c false if resulting cosignature is appropriate for attaching to an aggregate.\n\t * @returns {sc.Cosignature|sc.DetachedCosignature} Signed cosignature.\n\t */\n\tcosignTransaction(keyPair, transaction, detached = false) {\n\t\tconst transactionHash = this.hashTransaction(transaction);\n\n\t\treturn SymbolFacade.cosignTransactionHash(keyPair, transactionHash, detached);\n\t}\n\n\t/**\n\t * Hashes embedded transactions of an aggregate transaction.\n\t * @param {Array<sc.EmbeddedTransaction>} embeddedTransactions Embedded transactions to hash.\n\t * @returns {Hash256} Aggregate transactions hash.\n\t */\n\tstatic hashEmbeddedTransactions(embeddedTransactions) {\n\t\tconst hashBuilder = new MerkleHashBuilder();\n\t\tembeddedTransactions.forEach(embeddedTransaction => {\n\t\t\thashBuilder.update(new Hash256(sha3_256(embeddedTransaction.serialize())));\n\t\t});\n\n\t\treturn hashBuilder.final();\n\t}\n\n\t/**\n\t * Creates a network compatible BIP32 path for the specified account.\n\t * @param {number} accountId Id of the account for which to generate a BIP32 path.\n\t * @returns {Array<number>} BIP32 path for the specified account.\n\t */\n\tbip32Path(accountId) {\n\t\treturn [44, 'mainnet' === this.network.name ? 4343 : 1, accountId, 0, 0];\n\t}\n\n\t/**\n\t * Derives a Symbol KeyPair from a BIP32 node.\n\t * @param {Bip32Node} bip32Node BIP32 node.\n\t * @returns {KeyPair} Derived key pair.\n\t */\n\tstatic bip32NodeToKeyPair(bip32Node) {\n\t\treturn new KeyPair(new PrivateKey(bip32Node.privateKey.bytes));\n\t}\n}\n","// this file contains implementation details and is not intended to be used directly\n\nimport { AesCbcCipher, AesGcmCipher } from '../Cipher.js';\nimport crypto from 'crypto';\n\nconst GCM_IV_SIZE = 12;\nconst CBC_IV_SIZE = 16;\nconst SALT_SIZE = 32;\n\nconst concatArrays = (...arrays) => {\n\tconst totalLength = arrays.map(buffer => buffer.length).reduce((accumulator, currentValue) => accumulator + currentValue);\n\tconst result = new Uint8Array(totalLength);\n\tlet targetOffset = 0;\n\tarrays.forEach(buffer => {\n\t\tresult.set(buffer, targetOffset);\n\t\ttargetOffset += buffer.length;\n\t});\n\treturn result;\n};\n\nconst decode = (tagSize, ivSize, encodedMessage) => ({\n\ttag: encodedMessage.subarray(0, tagSize),\n\tinitializationVector: encodedMessage.subarray(tagSize, tagSize + ivSize),\n\tencodedMessageData: encodedMessage.subarray(tagSize + ivSize)\n});\n\nconst decodeAesGcm = (deriveSharedKey, keyPair, recipientPublicKey, encodedMessage) => {\n\tconst { tag, initializationVector, encodedMessageData } = decode(AesGcmCipher.TAG_SIZE, GCM_IV_SIZE, encodedMessage);\n\n\tconst sharedKey = deriveSharedKey(keyPair, recipientPublicKey);\n\tconst cipher = new AesGcmCipher(sharedKey);\n\n\treturn new Uint8Array(cipher.decrypt(concatArrays(encodedMessageData, tag), initializationVector));\n};\n\nconst decodeAesCbc = (deriveSharedKey, keyPair, recipientPublicKey, encodedMessage) => {\n\tconst { tag, initializationVector, encodedMessageData } = decode(SALT_SIZE, CBC_IV_SIZE, encodedMessage);\n\n\tconst sharedKey = deriveSharedKey(keyPair, recipientPublicKey, tag);\n\tconst cipher = new AesCbcCipher(sharedKey);\n\n\treturn new Uint8Array(cipher.decrypt(encodedMessageData, initializationVector));\n};\n\nconst encodeAesGcm = (deriveSharedKey, keyPair, recipientPublicKey, message) => {\n\tconst sharedKey = deriveSharedKey(keyPair, recipientPublicKey);\n\tconst cipher = new AesGcmCipher(sharedKey);\n\n\tconst initializationVector = new Uint8Array(crypto.randomBytes(GCM_IV_SIZE));\n\tconst cipherText = cipher.encrypt(message, initializationVector);\n\tconst tagStartOffset = cipherText.length - AesGcmCipher.TAG_SIZE;\n\tconst tag = cipherText.subarray(tagStartOffset);\n\n\treturn { tag, initializationVector, cipherText: cipherText.subarray(0, tagStartOffset) };\n};\n\nconst encodeAesCbc = (deriveSharedKey, keyPair, recipientPublicKey, message) => {\n\tconst salt = new Uint8Array(crypto.randomBytes(SALT_SIZE));\n\tconst sharedKey = deriveSharedKey(keyPair, recipientPublicKey, salt);\n\tconst cipher = new AesCbcCipher(sharedKey);\n\n\tconst initializationVector = new Uint8Array(crypto.randomBytes(CBC_IV_SIZE));\n\tconst cipherText = cipher.encrypt(message, initializationVector);\n\n\treturn { salt, initializationVector, cipherText };\n};\n\nexport {\n\tconcatArrays,\n\tdecodeAesGcm,\n\tdecodeAesCbc,\n\tencodeAesGcm,\n\tencodeAesCbc\n};\n","// this file contains implementation details and is not intended to be used directly\n\nimport ed25519_js from './ed25519_js.js';\nimport ed25519_wasm from './ed25519_wasm.js';\n\nlet ed25519;\nexport default {\n\tget: () => {\n\t\t// 1. certain environments, like ReactNative, do not support WebAssembly\n\t\t//    in those cases, default to JS-implementation\n\t\t// 2. for testing, check environment variable to force JS-implementation\n\t\tif (!ed25519)\n\t\t\ted25519 = globalThis.WebAssembly && !process.env.SYMBOL_SDK_NO_WASM ? ed25519_wasm : ed25519_js;\n\n\t\treturn ed25519;\n\t},\n\tunload: () => {\n\t\ted25519 = undefined;\n\t}\n};\n","// this file contains implementation details and is not intended to be used directly\n\nimport tweetnacl from './external/tweetnacl-nacl-fast-symbol.js';\nimport { deepCompare } from '../utils/arrayHelpers.js';\nimport { keccak_512 } from '@noble/hashes/sha3';\nimport { sha512 } from '@noble/hashes/sha512';\n\nconst getHasher = hashMode => ('Keccak' === hashMode ? keccak_512 : sha512);\n\nconst isCanonicalS = encodedS => {\n\tconst reduce = r => {\n\t\tconst x = new Float64Array(64);\n\t\tlet i;\n\t\tfor (i = 0; 64 > i; i++)\n\t\t\tx[i] = r[i];\n\n\t\tfor (i = 0; 64 > i; i++)\n\t\t\tr[i] = 0;\n\n\t\ttweetnacl.lowlevel.modL(r, x);\n\t};\n\n\t// require canonical signature\n\tconst reducedEncodedS = new Uint8Array([...encodedS, ...new Uint8Array(32)]);\n\treduce(reducedEncodedS);\n\treturn 0 === deepCompare(encodedS, reducedEncodedS.subarray(0, 32));\n};\n\nconst ed25519 = {\n\tkeyPairFromSeed: (hashMode, seed) => tweetnacl.sign.keyPair.fromSeed(seed, getHasher(hashMode)),\n\tsign: (hashMode, message, keyPair) => tweetnacl.sign.detached(message, keyPair.secretKey, getHasher(hashMode)),\n\tverify: (hashMode, message, signature, publicKey) => tweetnacl.sign.detached.verify(message, signature, publicKey, getHasher(hashMode))\n\t\t&& isCanonicalS(signature.subarray(32, 64))\n};\n\nexport default ed25519;\n","// this file contains implementation details and is not intended to be used directly\n\n/* eslint-disable import/no-extraneous-dependencies */\nimport {\n\tHashMode, crypto_private_sign, crypto_private_verify, crypto_sign_keypair\n} from 'symbol-crypto-wasm-node';\n/* eslint-enable import/no-extraneous-dependencies */\n\nconst CRYPTO_SIGN_BYTES = 64;\nconst CRYPTO_SIGN_PUBLICKEYBYTES = 32;\n\nconst ed25519 = {\n\tkeyPairFromSeed: (hashMode, seed) => {\n\t\tconst publicKey = new Uint8Array(CRYPTO_SIGN_PUBLICKEYBYTES);\n\t\tcrypto_sign_keypair(HashMode[hashMode], seed, publicKey);\n\t\treturn { publicKey, privateKey: seed };\n\t},\n\tsign: (hashMode, message, keyPair) => {\n\t\tconst signature = new Uint8Array(CRYPTO_SIGN_BYTES);\n\t\tcrypto_private_sign(HashMode[hashMode], keyPair.privateKey, message, signature);\n\t\treturn signature;\n\t},\n\tverify: (hashMode, message, signature, publicKey) => crypto_private_verify(HashMode[hashMode], publicKey, message, signature)\n};\n\nexport default ed25519;\n","// this file is based on tweetnacl/nacl-fast with the following changes:\n// - allows custom hash functions\n// - pruned to include minimal dependencies\n// - ES6\n\n/* eslint-disable\n\tcomma-spacing,\n\tcomputed-property-spacing,\n\tcurly,\n\tfunc-style,\n\tindent,\n\tkeyword-spacing,\n\tmax-len,\n\tno-mixed-operators,\n\tno-mixed-spaces-and-tabs,\n\tno-multi-spaces,\n\tno-underscore-dangle,\n\tno-var,\n\tnonblock-statement-body-position,\n\tobject-curly-spacing,\n\tone-var,\n\tone-var-declaration-per-line,\n\tspace-before-function-paren,\n\tspace-infix-ops,\n\tvars-on-top,\n\tyoda,\n\tjsdoc/require-jsdoc\n*/\n\nvar gf = function(init) {\n\tvar i, r = new Float64Array(16);\n\tif (init) for (i = 0; i < init.length; i++) r[i] = init[i];\n\treturn r;\n};\n\nvar _9 = new Uint8Array(32); _9[0] = 9;\n\nvar gf0 = gf(),\n\t\tgf1 = gf([1]),\n\t\tD = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),\n\t\tD2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),\n\t\tX = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),\n\t\tY = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),\n\t\tI = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);\n\nfunction vn(x, xi, y, yi, n) {\n\tvar i,d = 0;\n\tfor (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];\n\treturn (1 & ((d - 1) >>> 8)) - 1;\n}\n\nfunction crypto_verify_32(x, xi, y, yi) {\n\treturn vn(x,xi,y,yi,32);\n}\n\nfunction set25519(r, a) {\n\tvar i;\n\tfor (i = 0; i < 16; i++) r[i] = a[i]|0;\n}\n\nfunction car25519(o) {\n\tvar i, v, c = 1;\n\tfor (i = 0; i < 16; i++) {\n\t\tv = o[i] + c + 65535;\n\t\tc = Math.floor(v / 65536);\n\t\to[i] = v - c * 65536;\n\t}\n\to[0] += c-1 + 37 * (c-1);\n}\n\nfunction sel25519(p, q, b) {\n\tvar t, c = ~(b-1);\n\tfor (var i = 0; i < 16; i++) {\n\t\tt = c & (p[i] ^ q[i]);\n\t\tp[i] ^= t;\n\t\tq[i] ^= t;\n\t}\n}\n\nfunction pack25519(o, n) {\n\tvar i, j, b;\n\tvar m = gf(), t = gf();\n\tfor (i = 0; i < 16; i++) t[i] = n[i];\n\tcar25519(t);\n\tcar25519(t);\n\tcar25519(t);\n\tfor (j = 0; j < 2; j++) {\n\t\tm[0] = t[0] - 0xffed;\n\t\tfor (i = 1; i < 15; i++) {\n\t\t\tm[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);\n\t\t\tm[i-1] &= 0xffff;\n\t\t}\n\t\tm[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);\n\t\tb = (m[15]>>16) & 1;\n\t\tm[14] &= 0xffff;\n\t\tsel25519(t, m, 1-b);\n\t}\n\tfor (i = 0; i < 16; i++) {\n\t\to[2*i] = t[i] & 0xff;\n\t\to[2*i+1] = t[i]>>8;\n\t}\n}\n\nfunction neq25519(a, b) {\n\tvar c = new Uint8Array(32), d = new Uint8Array(32);\n\tpack25519(c, a);\n\tpack25519(d, b);\n\treturn crypto_verify_32(c, 0, d, 0);\n}\n\nfunction par25519(a) {\n\tvar d = new Uint8Array(32);\n\tpack25519(d, a);\n\treturn d[0] & 1;\n}\n\nfunction unpack25519(o, n) {\n\tvar i;\n\tfor (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);\n\to[15] &= 0x7fff;\n}\n\nfunction A(o, a, b) {\n\tfor (var i = 0; i < 16; i++) o[i] = a[i] + b[i];\n}\n\nfunction Z(o, a, b) {\n\tfor (var i = 0; i < 16; i++) o[i] = a[i] - b[i];\n}\n\nfunction M(o, a, b) {\n\tvar v, c,\n\t\t t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,\n\t\t t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,\n\t\tt16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,\n\t\tt24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,\n\t\tb0 = b[0],\n\t\tb1 = b[1],\n\t\tb2 = b[2],\n\t\tb3 = b[3],\n\t\tb4 = b[4],\n\t\tb5 = b[5],\n\t\tb6 = b[6],\n\t\tb7 = b[7],\n\t\tb8 = b[8],\n\t\tb9 = b[9],\n\t\tb10 = b[10],\n\t\tb11 = b[11],\n\t\tb12 = b[12],\n\t\tb13 = b[13],\n\t\tb14 = b[14],\n\t\tb15 = b[15];\n\n\tv = a[0];\n\tt0 += v * b0;\n\tt1 += v * b1;\n\tt2 += v * b2;\n\tt3 += v * b3;\n\tt4 += v * b4;\n\tt5 += v * b5;\n\tt6 += v * b6;\n\tt7 += v * b7;\n\tt8 += v * b8;\n\tt9 += v * b9;\n\tt10 += v * b10;\n\tt11 += v * b11;\n\tt12 += v * b12;\n\tt13 += v * b13;\n\tt14 += v * b14;\n\tt15 += v * b15;\n\tv = a[1];\n\tt1 += v * b0;\n\tt2 += v * b1;\n\tt3 += v * b2;\n\tt4 += v * b3;\n\tt5 += v * b4;\n\tt6 += v * b5;\n\tt7 += v * b6;\n\tt8 += v * b7;\n\tt9 += v * b8;\n\tt10 += v * b9;\n\tt11 += v * b10;\n\tt12 += v * b11;\n\tt13 += v * b12;\n\tt14 += v * b13;\n\tt15 += v * b14;\n\tt16 += v * b15;\n\tv = a[2];\n\tt2 += v * b0;\n\tt3 += v * b1;\n\tt4 += v * b2;\n\tt5 += v * b3;\n\tt6 += v * b4;\n\tt7 += v * b5;\n\tt8 += v * b6;\n\tt9 += v * b7;\n\tt10 += v * b8;\n\tt11 += v * b9;\n\tt12 += v * b10;\n\tt13 += v * b11;\n\tt14 += v * b12;\n\tt15 += v * b13;\n\tt16 += v * b14;\n\tt17 += v * b15;\n\tv = a[3];\n\tt3 += v * b0;\n\tt4 += v * b1;\n\tt5 += v * b2;\n\tt6 += v * b3;\n\tt7 += v * b4;\n\tt8 += v * b5;\n\tt9 += v * b6;\n\tt10 += v * b7;\n\tt11 += v * b8;\n\tt12 += v * b9;\n\tt13 += v * b10;\n\tt14 += v * b11;\n\tt15 += v * b12;\n\tt16 += v * b13;\n\tt17 += v * b14;\n\tt18 += v * b15;\n\tv = a[4];\n\tt4 += v * b0;\n\tt5 += v * b1;\n\tt6 += v * b2;\n\tt7 += v * b3;\n\tt8 += v * b4;\n\tt9 += v * b5;\n\tt10 += v * b6;\n\tt11 += v * b7;\n\tt12 += v * b8;\n\tt13 += v * b9;\n\tt14 += v * b10;\n\tt15 += v * b11;\n\tt16 += v * b12;\n\tt17 += v * b13;\n\tt18 += v * b14;\n\tt19 += v * b15;\n\tv = a[5];\n\tt5 += v * b0;\n\tt6 += v * b1;\n\tt7 += v * b2;\n\tt8 += v * b3;\n\tt9 += v * b4;\n\tt10 += v * b5;\n\tt11 += v * b6;\n\tt12 += v * b7;\n\tt13 += v * b8;\n\tt14 += v * b9;\n\tt15 += v * b10;\n\tt16 += v * b11;\n\tt17 += v * b12;\n\tt18 += v * b13;\n\tt19 += v * b14;\n\tt20 += v * b15;\n\tv = a[6];\n\tt6 += v * b0;\n\tt7 += v * b1;\n\tt8 += v * b2;\n\tt9 += v * b3;\n\tt10 += v * b4;\n\tt11 += v * b5;\n\tt12 += v * b6;\n\tt13 += v * b7;\n\tt14 += v * b8;\n\tt15 += v * b9;\n\tt16 += v * b10;\n\tt17 += v * b11;\n\tt18 += v * b12;\n\tt19 += v * b13;\n\tt20 += v * b14;\n\tt21 += v * b15;\n\tv = a[7];\n\tt7 += v * b0;\n\tt8 += v * b1;\n\tt9 += v * b2;\n\tt10 += v * b3;\n\tt11 += v * b4;\n\tt12 += v * b5;\n\tt13 += v * b6;\n\tt14 += v * b7;\n\tt15 += v * b8;\n\tt16 += v * b9;\n\tt17 += v * b10;\n\tt18 += v * b11;\n\tt19 += v * b12;\n\tt20 += v * b13;\n\tt21 += v * b14;\n\tt22 += v * b15;\n\tv = a[8];\n\tt8 += v * b0;\n\tt9 += v * b1;\n\tt10 += v * b2;\n\tt11 += v * b3;\n\tt12 += v * b4;\n\tt13 += v * b5;\n\tt14 += v * b6;\n\tt15 += v * b7;\n\tt16 += v * b8;\n\tt17 += v * b9;\n\tt18 += v * b10;\n\tt19 += v * b11;\n\tt20 += v * b12;\n\tt21 += v * b13;\n\tt22 += v * b14;\n\tt23 += v * b15;\n\tv = a[9];\n\tt9 += v * b0;\n\tt10 += v * b1;\n\tt11 += v * b2;\n\tt12 += v * b3;\n\tt13 += v * b4;\n\tt14 += v * b5;\n\tt15 += v * b6;\n\tt16 += v * b7;\n\tt17 += v * b8;\n\tt18 += v * b9;\n\tt19 += v * b10;\n\tt20 += v * b11;\n\tt21 += v * b12;\n\tt22 += v * b13;\n\tt23 += v * b14;\n\tt24 += v * b15;\n\tv = a[10];\n\tt10 += v * b0;\n\tt11 += v * b1;\n\tt12 += v * b2;\n\tt13 += v * b3;\n\tt14 += v * b4;\n\tt15 += v * b5;\n\tt16 += v * b6;\n\tt17 += v * b7;\n\tt18 += v * b8;\n\tt19 += v * b9;\n\tt20 += v * b10;\n\tt21 += v * b11;\n\tt22 += v * b12;\n\tt23 += v * b13;\n\tt24 += v * b14;\n\tt25 += v * b15;\n\tv = a[11];\n\tt11 += v * b0;\n\tt12 += v * b1;\n\tt13 += v * b2;\n\tt14 += v * b3;\n\tt15 += v * b4;\n\tt16 += v * b5;\n\tt17 += v * b6;\n\tt18 += v * b7;\n\tt19 += v * b8;\n\tt20 += v * b9;\n\tt21 += v * b10;\n\tt22 += v * b11;\n\tt23 += v * b12;\n\tt24 += v * b13;\n\tt25 += v * b14;\n\tt26 += v * b15;\n\tv = a[12];\n\tt12 += v * b0;\n\tt13 += v * b1;\n\tt14 += v * b2;\n\tt15 += v * b3;\n\tt16 += v * b4;\n\tt17 += v * b5;\n\tt18 += v * b6;\n\tt19 += v * b7;\n\tt20 += v * b8;\n\tt21 += v * b9;\n\tt22 += v * b10;\n\tt23 += v * b11;\n\tt24 += v * b12;\n\tt25 += v * b13;\n\tt26 += v * b14;\n\tt27 += v * b15;\n\tv = a[13];\n\tt13 += v * b0;\n\tt14 += v * b1;\n\tt15 += v * b2;\n\tt16 += v * b3;\n\tt17 += v * b4;\n\tt18 += v * b5;\n\tt19 += v * b6;\n\tt20 += v * b7;\n\tt21 += v * b8;\n\tt22 += v * b9;\n\tt23 += v * b10;\n\tt24 += v * b11;\n\tt25 += v * b12;\n\tt26 += v * b13;\n\tt27 += v * b14;\n\tt28 += v * b15;\n\tv = a[14];\n\tt14 += v * b0;\n\tt15 += v * b1;\n\tt16 += v * b2;\n\tt17 += v * b3;\n\tt18 += v * b4;\n\tt19 += v * b5;\n\tt20 += v * b6;\n\tt21 += v * b7;\n\tt22 += v * b8;\n\tt23 += v * b9;\n\tt24 += v * b10;\n\tt25 += v * b11;\n\tt26 += v * b12;\n\tt27 += v * b13;\n\tt28 += v * b14;\n\tt29 += v * b15;\n\tv = a[15];\n\tt15 += v * b0;\n\tt16 += v * b1;\n\tt17 += v * b2;\n\tt18 += v * b3;\n\tt19 += v * b4;\n\tt20 += v * b5;\n\tt21 += v * b6;\n\tt22 += v * b7;\n\tt23 += v * b8;\n\tt24 += v * b9;\n\tt25 += v * b10;\n\tt26 += v * b11;\n\tt27 += v * b12;\n\tt28 += v * b13;\n\tt29 += v * b14;\n\tt30 += v * b15;\n\n\tt0  += 38 * t16;\n\tt1  += 38 * t17;\n\tt2  += 38 * t18;\n\tt3  += 38 * t19;\n\tt4  += 38 * t20;\n\tt5  += 38 * t21;\n\tt6  += 38 * t22;\n\tt7  += 38 * t23;\n\tt8  += 38 * t24;\n\tt9  += 38 * t25;\n\tt10 += 38 * t26;\n\tt11 += 38 * t27;\n\tt12 += 38 * t28;\n\tt13 += 38 * t29;\n\tt14 += 38 * t30;\n\t// t15 left as is\n\n\t// first car\n\tc = 1;\n\tv =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\n\tv =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\n\tv =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\n\tv =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\n\tv =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\n\tv =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\n\tv =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\n\tv =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\n\tv =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\n\tv =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\n\tv = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\n\tv = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\n\tv = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\n\tv = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\n\tv = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\n\tv = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\n\tt0 += c-1 + 37 * (c-1);\n\n\t// second car\n\tc = 1;\n\tv =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\n\tv =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\n\tv =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\n\tv =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\n\tv =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\n\tv =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\n\tv =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\n\tv =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\n\tv =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\n\tv =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\n\tv = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\n\tv = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\n\tv = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\n\tv = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\n\tv = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\n\tv = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\n\tt0 += c-1 + 37 * (c-1);\n\n\to[ 0] = t0;\n\to[ 1] = t1;\n\to[ 2] = t2;\n\to[ 3] = t3;\n\to[ 4] = t4;\n\to[ 5] = t5;\n\to[ 6] = t6;\n\to[ 7] = t7;\n\to[ 8] = t8;\n\to[ 9] = t9;\n\to[10] = t10;\n\to[11] = t11;\n\to[12] = t12;\n\to[13] = t13;\n\to[14] = t14;\n\to[15] = t15;\n}\n\nfunction S(o, a) {\n\tM(o, a, a);\n}\n\nfunction inv25519(o, i) {\n\tvar c = gf();\n\tvar a;\n\tfor (a = 0; a < 16; a++) c[a] = i[a];\n\tfor (a = 253; a >= 0; a--) {\n\t\tS(c, c);\n\t\tif(a !== 2 && a !== 4) M(c, c, i);\n\t}\n\tfor (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction pow2523(o, i) {\n\tvar c = gf();\n\tvar a;\n\tfor (a = 0; a < 16; a++) c[a] = i[a];\n\tfor (a = 250; a >= 0; a--) {\n\t\t\tS(c, c);\n\t\t\tif(a !== 1) M(c, c, i);\n\t}\n\tfor (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction crypto_hash(out, m, n, hasher) {\n\tconst hashBuilder = hasher.create();\n\thashBuilder.update(m.subarray(0, n));\n\tconst hash = hashBuilder.digest();\n\n\tfor (let i = 0; i < out.length; ++i)\n\t\tout[i] = hash[i];\n\n\treturn 0;\n}\n\nfunction add(p, q) {\n\tvar a = gf(), b = gf(), c = gf(),\n\t\t\td = gf(), e = gf(), f = gf(),\n\t\t\tg = gf(), h = gf(), t = gf();\n\n\tZ(a, p[1], p[0]);\n\tZ(t, q[1], q[0]);\n\tM(a, a, t);\n\tA(b, p[0], p[1]);\n\tA(t, q[0], q[1]);\n\tM(b, b, t);\n\tM(c, p[3], q[3]);\n\tM(c, c, D2);\n\tM(d, p[2], q[2]);\n\tA(d, d, d);\n\tZ(e, b, a);\n\tZ(f, d, c);\n\tA(g, d, c);\n\tA(h, b, a);\n\n\tM(p[0], e, f);\n\tM(p[1], h, g);\n\tM(p[2], g, f);\n\tM(p[3], e, h);\n}\n\nfunction cswap(p, q, b) {\n\tvar i;\n\tfor (i = 0; i < 4; i++) {\n\t\tsel25519(p[i], q[i], b);\n\t}\n}\n\nfunction pack(r, p) {\n\tvar tx = gf(), ty = gf(), zi = gf();\n\tinv25519(zi, p[2]);\n\tM(tx, p[0], zi);\n\tM(ty, p[1], zi);\n\tpack25519(r, ty);\n\tr[31] ^= par25519(tx) << 7;\n}\n\nfunction scalarmult(p, q, s) {\n\tvar b, i;\n\tset25519(p[0], gf0);\n\tset25519(p[1], gf1);\n\tset25519(p[2], gf1);\n\tset25519(p[3], gf0);\n\tfor (i = 255; i >= 0; --i) {\n\t\tb = (s[(i/8)|0] >> (i&7)) & 1;\n\t\tcswap(p, q, b);\n\t\tadd(q, p);\n\t\tadd(p, p);\n\t\tcswap(p, q, b);\n\t}\n}\n\nfunction scalarbase(p, s) {\n\tvar q = [gf(), gf(), gf(), gf()];\n\tset25519(q[0], X);\n\tset25519(q[1], Y);\n\tset25519(q[2], gf1);\n\tM(q[3], X, Y);\n\tscalarmult(p, q, s);\n}\n\nfunction crypto_sign_keypair(pk, sk, hasher) {\n\tvar d = new Uint8Array(64);\n\tvar p = [gf(), gf(), gf(), gf()];\n\tvar i;\n\n\tcrypto_hash(d, sk, 32, hasher);\n\td[0] &= 248;\n\td[31] &= 127;\n\td[31] |= 64;\n\n\tscalarbase(p, d);\n\tpack(pk, p);\n\n\tfor (i = 0; i < 32; i++) sk[i+32] = pk[i];\n\treturn 0;\n}\n\nvar L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);\n\nfunction modL(r, x) {\n\tvar carry, i, j, k;\n\tfor (i = 63; i >= 32; --i) {\n\t\tcarry = 0;\n\t\tfor (j = i - 32, k = i - 12; j < k; ++j) {\n\t\t\tx[j] += carry - 16 * x[i] * L[j - (i - 32)];\n\t\t\tcarry = Math.floor((x[j] + 128) / 256);\n\t\t\tx[j] -= carry * 256;\n\t\t}\n\t\tx[j] += carry;\n\t\tx[i] = 0;\n\t}\n\tcarry = 0;\n\tfor (j = 0; j < 32; j++) {\n\t\tx[j] += carry - (x[31] >> 4) * L[j];\n\t\tcarry = x[j] >> 8;\n\t\tx[j] &= 255;\n\t}\n\tfor (j = 0; j < 32; j++) x[j] -= carry * L[j];\n\tfor (i = 0; i < 32; i++) {\n\t\tx[i+1] += x[i] >> 8;\n\t\tr[i] = x[i] & 255;\n\t}\n}\n\nfunction reduce(r) {\n\tvar x = new Float64Array(64), i;\n\tfor (i = 0; i < 64; i++) x[i] = r[i];\n\tfor (i = 0; i < 64; i++) r[i] = 0;\n\tmodL(r, x);\n}\n\n// Note: difference from C - smlen returned, not passed as argument.\nfunction crypto_sign(sm, m, n, sk, hasher) {\n\tvar d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);\n\tvar i, j, x = new Float64Array(64);\n\tvar p = [gf(), gf(), gf(), gf()];\n\n\tcrypto_hash(d, sk, 32, hasher);\n\td[0] &= 248;\n\td[31] &= 127;\n\td[31] |= 64;\n\n\tvar smlen = n + 64;\n\tfor (i = 0; i < n; i++) sm[64 + i] = m[i];\n\tfor (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];\n\n\tcrypto_hash(r, sm.subarray(32), n+32, hasher);\n\treduce(r);\n\tscalarbase(p, r);\n\tpack(sm, p);\n\n\tfor (i = 32; i < 64; i++) sm[i] = sk[i];\n\tcrypto_hash(h, sm, n + 64, hasher);\n\treduce(h);\n\n\tfor (i = 0; i < 64; i++) x[i] = 0;\n\tfor (i = 0; i < 32; i++) x[i] = r[i];\n\tfor (i = 0; i < 32; i++) {\n\t\tfor (j = 0; j < 32; j++) {\n\t\t\tx[i+j] += h[i] * d[j];\n\t\t}\n\t}\n\n\tmodL(sm.subarray(32), x);\n\treturn smlen;\n}\n\nfunction unpackneg(r, p) {\n\tvar t = gf(), chk = gf(), num = gf(),\n\t\t\tden = gf(), den2 = gf(), den4 = gf(),\n\t\t\tden6 = gf();\n\n\tset25519(r[2], gf1);\n\tunpack25519(r[1], p);\n\tS(num, r[1]);\n\tM(den, num, D);\n\tZ(num, num, r[2]);\n\tA(den, r[2], den);\n\n\tS(den2, den);\n\tS(den4, den2);\n\tM(den6, den4, den2);\n\tM(t, den6, num);\n\tM(t, t, den);\n\n\tpow2523(t, t);\n\tM(t, t, num);\n\tM(t, t, den);\n\tM(t, t, den);\n\tM(r[0], t, den);\n\n\tS(chk, r[0]);\n\tM(chk, chk, den);\n\tif (neq25519(chk, num)) M(r[0], r[0], I);\n\n\tS(chk, r[0]);\n\tM(chk, chk, den);\n\tif (neq25519(chk, num)) return -1;\n\n\tif (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);\n\n\tM(r[3], r[0], r[1]);\n\treturn 0;\n}\n\nfunction crypto_sign_open(m, sm, n, pk, hasher) {\n\tvar i;\n\tvar t = new Uint8Array(32), h = new Uint8Array(64);\n\tvar p = [gf(), gf(), gf(), gf()],\n\t\t\tq = [gf(), gf(), gf(), gf()];\n\n\tif (n < 64) return -1;\n\n\tif (unpackneg(q, pk)) return -1;\n\n\tfor (i = 0; i < n; i++) m[i] = sm[i];\n\tfor (i = 0; i < 32; i++) m[i+32] = pk[i];\n\tcrypto_hash(h, m, n, hasher);\n\treduce(h);\n\tscalarmult(p, q, h);\n\n\tscalarbase(q, sm.subarray(32));\n\tadd(p, q);\n\tpack(t, p);\n\n\tn -= 64; // eslint-disable-line no-param-reassign\n\tif (crypto_verify_32(sm, 0, t, 0)) {\n\t\tfor (i = 0; i < n; i++) m[i] = 0;\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < n; i++) m[i] = sm[i + 64];\n\treturn n;\n}\n\nvar crypto_sign_BYTES = 64,\n\t\tcrypto_sign_PUBLICKEYBYTES = 32,\n\t\tcrypto_sign_SECRETKEYBYTES = 64,\n\t\tcrypto_sign_SEEDBYTES = 32;\n\nconst nacl = {};\nnacl.lowlevel = {\n\tcrypto_hash,\n\n\tgf,\n\tL,\n\tZ,\n\tmodL,\n\tscalarmult,\n\tneq25519,\n\tpar25519,\n\tinv25519,\n\tpack,\n\tunpackneg\n};\n\n/* High-level API */\n\nfunction checkArrayTypes(...params) {\n\tfor (var i = 0; i < params.length; i++) {\n\t\tif (!(params[i] instanceof Uint8Array))\n\t\t\tthrow new TypeError('unexpected type, use Uint8Array');\n\t}\n}\n\nnacl.sign = function(msg, secretKey, hasher) {\n\tcheckArrayTypes(msg, secretKey);\n\tif (secretKey.length !== crypto_sign_SECRETKEYBYTES)\n\t\tthrow new Error('bad secret key size');\n\tvar signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);\n\tcrypto_sign(signedMsg, msg, msg.length, secretKey, hasher);\n\treturn signedMsg;\n};\n\nnacl.sign.detached = function(msg, secretKey, hasher) {\n\tvar signedMsg = nacl.sign(msg, secretKey, hasher);\n\tvar sig = new Uint8Array(crypto_sign_BYTES);\n\tfor (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];\n\treturn sig;\n};\n\nnacl.sign.detached.verify = function(msg, sig, publicKey, hasher) {\n\tcheckArrayTypes(msg, sig, publicKey);\n\tif (sig.length !== crypto_sign_BYTES)\n\t\tthrow new Error('bad signature size');\n\tif (publicKey.length !== crypto_sign_PUBLICKEYBYTES)\n\t\tthrow new Error('bad public key size');\n\tvar sm = new Uint8Array(crypto_sign_BYTES + msg.length);\n\tvar m = new Uint8Array(crypto_sign_BYTES + msg.length);\n\tvar i;\n\tfor (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];\n\tfor (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];\n\treturn (crypto_sign_open(m, sm, sm.length, publicKey, hasher) >= 0);\n};\n\nnacl.sign.keyPair = {};\nnacl.sign.keyPair.fromSeed = function(seed, hasher) {\n\tcheckArrayTypes(seed);\n\tif (seed.length !== crypto_sign_SEEDBYTES)\n\t\tthrow new Error('bad seed size');\n\tvar pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n\tvar sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n\tfor (var i = 0; i < 32; i++) sk[i] = seed[i];\n\tcrypto_sign_keypair(pk, sk, hasher);\n\treturn {publicKey: pk, secretKey: sk};\n};\n\nexport default nacl;\n","import { PrivateKey, PublicKey, Signature } from '../CryptoTypes.js';\nimport ed25519 from '../impl/ed25519.js';\nimport { deepCompare } from '../utils/arrayHelpers.js';\n\nconst HASH_MODE = 'Sha2_512';\n\n/**\n * Represents an ED25519 private and public key.\n */\nexport class KeyPair {\n\t/**\n\t * Creates a key pair from a private key.\n\t * @param {PrivateKey} privateKey Private key.\n\t */\n\tconstructor(privateKey) {\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tthis._privateKey = privateKey;\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tthis._keyPair = ed25519.get().keyPairFromSeed(HASH_MODE, this._privateKey.bytes);\n\t}\n\n\t/**\n\t * Gets the public key.\n\t * @returns {PublicKey} Public key.\n\t */\n\tget publicKey() {\n\t\treturn new PublicKey(this._keyPair.publicKey);\n\t}\n\n\t/**\n\t * Gets the private key.\n\t * @returns {PrivateKey} Private key.\n\t */\n\tget privateKey() {\n\t\treturn new PrivateKey(this._privateKey.bytes);\n\t}\n\n\t/**\n\t * Signs a message with the private key.\n\t * @param {Uint8Array} message Message to sign.\n\t * @returns {Signature} Message signature.\n\t */\n\tsign(message) {\n\t\treturn new Signature(ed25519.get().sign(HASH_MODE, message, this._keyPair));\n\t}\n}\n\n/**\n * Verifies signatures signed by a single key pair.\n */\nexport class Verifier {\n\t/**\n\t * Creates a verifier from a public key.\n\t * @param {PublicKey} publicKey Public key.\n\t */\n\tconstructor(publicKey) {\n\t\tif (0 === deepCompare(new Uint8Array(PublicKey.SIZE), publicKey.bytes))\n\t\t\tthrow new Error('public key cannot be zero');\n\n\t\t/**\n\t\t * Public key used for signature verification.\n\t\t * @type {PublicKey}\n\t\t */\n\t\tthis.publicKey = publicKey;\n\t}\n\n\t/**\n\t * Verifies a message signature.\n\t * @param {Uint8Array} message Message to verify.\n\t * @param {Signature} signature Signature to verify.\n\t * @returns {boolean} true if the message signature verifies.\n\t */\n\tverify(message, signature) {\n\t\treturn ed25519.get().verify(HASH_MODE, message, signature.bytes, this.publicKey.bytes);\n\t}\n}\n","import { KeyPair } from './KeyPair.js';\nimport { deriveSharedKey } from './SharedKey.js';\nimport { PrivateKey, PublicKey } from '../CryptoTypes.js';\nimport { concatArrays, decodeAesGcm, encodeAesGcm } from '../impl/CipherHelpers.js';\nimport { deepCompare } from '../utils/arrayHelpers.js';\nimport { hexToUint8, isHexString, uint8ToHex } from '../utils/converter.js';\n\nconst DELEGATION_MARKER = Uint8Array.from(Buffer.from('FE2A8061577301E2', 'hex'));\n\nconst filterExceptions = (statement, exceptions) => {\n\ttry {\n\t\tconst message = statement();\n\t\treturn [true, message];\n\t} catch (exception) {\n\t\tif (!exceptions.some(exceptionMessage => exception.message.includes(exceptionMessage)))\n\t\t\tthrow exception;\n\t}\n\n\treturn [false, undefined];\n};\n\n/**\n * Encrypts and encodes messages between two parties.\n */\nexport default class MessageEncoder {\n\t/**\n\t * Creates message encoder around key pair.\n\t * @param {KeyPair} keyPair Key pair.\n\t */\n\tconstructor(keyPair) {\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tthis._keyPair = keyPair;\n\t}\n\n\t/**\n\t * Public key used for message encoding.\n\t * @returns {PublicKey} Public key used for message encoding.\n\t */\n\tget publicKey() {\n\t\treturn this._keyPair.publicKey;\n\t}\n\n\t/**\n\t * Tries to decode encoded message.\n\t * @param {PublicKey} recipientPublicKey Recipient's public key.\n\t * @param {Uint8Array} encodedMessage Encoded message.\n\t * @returns {TryDecodeResult} Tuple containing decoded status and message.\n\t */\n\ttryDecode(recipientPublicKey, encodedMessage) {\n\t\tif (1 === encodedMessage[0]) {\n\t\t\tconst [result, message] = filterExceptions(\n\t\t\t\t() => decodeAesGcm(deriveSharedKey, this._keyPair, recipientPublicKey, encodedMessage.subarray(1)),\n\t\t\t\t['Unsupported state or unable to authenticate data']\n\t\t\t);\n\t\t\tif (result)\n\t\t\t\treturn { isDecoded: true, message };\n\t\t}\n\n\t\tif (0xFE === encodedMessage[0] && 0 === deepCompare(DELEGATION_MARKER, encodedMessage.slice(0, 8))) {\n\t\t\tconst ephemeralPublicKeyStart = DELEGATION_MARKER.length;\n\t\t\tconst ephemeralPublicKeyEnd = ephemeralPublicKeyStart + PublicKey.SIZE;\n\t\t\tconst ephemeralPublicKey = new PublicKey(encodedMessage.subarray(ephemeralPublicKeyStart, ephemeralPublicKeyEnd));\n\n\t\t\tconst [result, message] = filterExceptions(\n\t\t\t\t() => decodeAesGcm(deriveSharedKey, this._keyPair, ephemeralPublicKey, encodedMessage.subarray(ephemeralPublicKeyEnd)),\n\t\t\t\t[\n\t\t\t\t\t'Unsupported state or unable to authenticate data',\n\t\t\t\t\t'invalid point'\n\t\t\t\t]\n\t\t\t);\n\t\t\tif (result)\n\t\t\t\treturn { isDecoded: true, message };\n\t\t}\n\n\t\treturn { isDecoded: false, message: encodedMessage };\n\t}\n\n\t/**\n\t * Encodes message to recipient using recommended format.\n\t * @param {PublicKey} recipientPublicKey Recipient public key.\n\t * @param {Uint8Array} message Message to encode.\n\t * @returns {Uint8Array} Encrypted and encoded message.\n\t */\n\tencode(recipientPublicKey, message) {\n\t\tconst { tag, initializationVector, cipherText } = encodeAesGcm(deriveSharedKey, this._keyPair, recipientPublicKey, message);\n\n\t\treturn concatArrays(new Uint8Array([1]), tag, initializationVector, cipherText);\n\t}\n\n\t/**\n\t * Encodes persistent harvesting delegation to node.\n\t * @param {PublicKey} nodePublicKey Node public key.\n\t * @param {KeyPair} remoteKeyPair Remote key pair.\n\t * @param {KeyPair} vrfKeyPair Vrf key pair.\n\t * @returns {Uint8Array} Encrypted and encoded harvesting delegation request.\n\t */\n\t// eslint-disable-next-line class-methods-use-this\n\tencodePersistentHarvestingDelegation(nodePublicKey, remoteKeyPair, vrfKeyPair) {\n\t\tconst ephemeralKeyPair = new KeyPair(PrivateKey.random());\n\t\tconst message = concatArrays(remoteKeyPair.privateKey.bytes, vrfKeyPair.privateKey.bytes);\n\t\tconst { tag, initializationVector, cipherText } = encodeAesGcm(deriveSharedKey, ephemeralKeyPair, nodePublicKey, message);\n\n\t\treturn concatArrays(DELEGATION_MARKER, ephemeralKeyPair.publicKey.bytes, tag, initializationVector, cipherText);\n\t}\n\n\t/**\n\t * Tries to decode encoded message.\n\t * @deprecated This function is only provided for compatability with the original Symbol wallets.\n\t *             Please use `tryDecode` in any new code.\n\t * @param {PublicKey} recipientPublicKey Recipient's public key.\n\t * @param {Uint8Array} encodedMessage Encoded message\n\t * @returns {TryDecodeResult} Tuple containing decoded status and message.\n\t */\n\ttryDecodeDeprecated(recipientPublicKey, encodedMessage) {\n\t\tconst encodedHexString = new TextDecoder().decode(encodedMessage.subarray(1));\n\t\tif (1 === encodedMessage[0] && isHexString(encodedHexString)) {\n\t\t\t// wallet additionally hex encodes\n\t\t\treturn this.tryDecode(recipientPublicKey, new Uint8Array([1, ...hexToUint8(encodedHexString)]));\n\t\t}\n\n\t\treturn this.tryDecode(recipientPublicKey, encodedMessage);\n\t}\n\n\t/**\n\t * Encodes message to recipient using (deprecated) wallet format.\n\t * @deprecated This function is only provided for compatability with the original Symbol wallets.\n\t *             Please use `encode` in any new code.\n\t * @param {PublicKey} recipientPublicKey Recipient public key.\n\t * @param {Uint8Array} message Message to encode.\n\t * @returns {Uint8Array} Encrypted and encoded message.\n\t */\n\tencodeDeprecated(recipientPublicKey, message) {\n\t\t// wallet additionally hex encodes\n\t\tconst encodedHexString = uint8ToHex(this.encode(recipientPublicKey, message).subarray(1));\n\t\tconst encodedHexStringBytes = new TextEncoder().encode(encodedHexString);\n\t\treturn new Uint8Array([1, ...encodedHexStringBytes]);\n\t}\n}\n\n// region type declarations\n\n/**\n * Result of a try decode operation.\n * @class\n * @typedef {object} TryDecodeResult\n * @property {boolean} isDecoded \\c true if message has been decoded and decrypted; \\c false otherwise.\n * @property {Uint8Array} message Decoded message when `isDecoded` is \\c true; encoded message otherwise.\n */\n\n// endregion\n","import { NamespaceId } from './models.js';\nimport ByteArray from '../ByteArray.js';\nimport { Hash256 } from '../CryptoTypes.js';\nimport { Network as BasicNetwork } from '../Network.js';\nimport { NetworkTimestamp as BasicNetworkTimestamp, NetworkTimestampDatetimeConverter } from '../NetworkTimestamp.js';\nimport base32 from '../utils/base32.js';\nimport { hexToUint8 } from '../utils/converter.js';\nimport { sha3_256 } from '@noble/hashes/sha3';\n\n/**\n * Represents a Symbol network timestamp with millisecond resolution.\n */\nexport class NetworkTimestamp extends BasicNetworkTimestamp {\n\t/**\n\t * Adds a specified number of milliseconds to this timestamp.\n\t * @param {number|bigint} count Number of milliseconds to add.\n\t * @returns {NetworkTimestamp} New timestamp that is the specified number of milliseconds past this timestamp.\n\t */\n\taddMilliseconds(count) {\n\t\treturn new NetworkTimestamp(this.timestamp + BigInt(count));\n\t}\n\n\t/**\n\t * Adds a specified number of seconds to this timestamp.\n\t * @override\n\t * @param {number|bigint} count Number of seconds to add.\n\t * @returns {NetworkTimestamp} New timestamp that is the specified number of seconds past this timestamp.\n\t */\n\taddSeconds(count) {\n\t\treturn this.addMilliseconds(1000n * BigInt(count));\n\t}\n}\n\n/**\n * Represents a Symbol address.\n */\nexport class Address extends ByteArray {\n\t/**\n\t * Byte size of raw address.\n\t * @type {number}\n\t */\n\tstatic SIZE = 24;\n\n\t/**\n\t * Length of encoded address string.\n\t * @type {number}\n\t */\n\tstatic ENCODED_SIZE = 39;\n\n\t/**\n\t * Byte array name (required because `constructor.name` is dropped during minification).\n\t * @type {string}\n\t */\n\tstatic NAME = 'Address';\n\n\t/**\n\t * Creates a Symbol address.\n\t * @param {Uint8Array|string|Address} addressInput Input string, byte array or address.\n\t */\n\tconstructor(addressInput) {\n\t\tconst extractAddressBytes = () => {\n\t\t\tif ('string' === typeof addressInput)\n\t\t\t\treturn base32.decode(`${addressInput}A`).slice(0, -1);\n\n\t\t\tif (addressInput instanceof Address)\n\t\t\t\treturn addressInput.bytes;\n\n\t\t\treturn addressInput;\n\t\t};\n\n\t\tsuper(Address.SIZE, extractAddressBytes());\n\t}\n\n\t/**\n\t * Attempts to convert this address into a namespace id.\n\t * @returns {NamespaceId|undefined} Namespace id if this adresss is an alias, undefined otherwise.\n\t */\n\ttoNamespaceId() {\n\t\tif (!(this.bytes[0] & 0x01))\n\t\t\treturn undefined;\n\n\t\tconst idBytes = this.bytes.slice(1, 9); // slice because namespace id is unaligned\n\t\tconst ids = new BigUint64Array(idBytes.buffer);\n\t\treturn new NamespaceId(ids[0]);\n\t}\n\n\t/**\n\t * Returns string representation of this object.\n\t * @returns {string} String representation of this object\n\t */\n\ttoString() {\n\t\treturn base32.encode(new Uint8Array([...this.bytes, 0])).slice(0, -1);\n\t}\n\n\t/**\n\t * Creates an address from a decoded address hex string (typically from REST).\n\t * @param {string} hexString Decoded address hex string.\n\t * @returns {Address} Equivalent address.\n\t */\n\tstatic fromDecodedAddressHexString(hexString) {\n\t\tconst bytes = hexToUint8(hexString);\n\t\treturn new Address(bytes);\n\t}\n\n\t/**\n\t * Creates an address from a namespace id.\n\t * @param {NamespaceId} namespaceId Namespace id.\n\t * @param {number} networkIdentifier Network identifier byte.\n\t * @returns {Address} Address referencing namespace id.\n\t */\n\tstatic fromNamespaceId(namespaceId, networkIdentifier) {\n\t\tconst ids = new BigUint64Array(1);\n\t\tids[0] = /** @type {bigint} */ (namespaceId.value);\n\n\t\treturn new Address(new Uint8Array([\n\t\t\tnetworkIdentifier + 1,\n\t\t\t...new Uint8Array(ids.buffer),\n\t\t\t...new Uint8Array(Address.SIZE - 9)\n\t\t]));\n\t}\n}\n\n/**\n * Represents a Symbol network.\n */\nexport class Network extends BasicNetwork {\n\t/**\n\t * Symbol main network.\n\t * @type {Network}\n\t */\n\tstatic MAINNET;\n\n\t/**\n\t * Symbol test network.\n\t * @type {Network}\n\t */\n\tstatic TESTNET;\n\n\t/**\n\t * Symbol well known networks.\n\t * @type {Array<Network>}\n\t */\n\tstatic NETWORKS;\n\n\t/**\n\t * Creates a new network with the specified name, identifier byte and generation hash seed.\n\t * @param {string} name Network name.\n\t * @param {number} identifier Network identifier byte.\n\t * @param {Date} epochTime Network epoch time.\n\t * @param {Hash256} generationHashSeed Network generation hash seed.\n\t */\n\tconstructor(name, identifier, epochTime, generationHashSeed) {\n\t\tsuper(\n\t\t\tname,\n\t\t\tidentifier,\n\t\t\tnew NetworkTimestampDatetimeConverter(epochTime, 'milliseconds'),\n\t\t\t() => sha3_256.create(),\n\t\t\t(addressWithoutChecksum, checksum) => new Address(new Uint8Array([...addressWithoutChecksum, ...checksum.subarray(0, 3)])),\n\t\t\tAddress,\n\t\t\tNetworkTimestamp\n\t\t);\n\n\t\t/**\n\t\t * Network generation hash seed.\n\t\t * @type {Hash256}\n\t\t */\n\t\tthis.generationHashSeed = generationHashSeed;\n\t}\n}\n\nNetwork.MAINNET = new Network(\n\t'mainnet',\n\t0x68,\n\tnew Date(Date.UTC(2021, 2, 16, 0, 6, 25)),\n\tnew Hash256('57F7DA205008026C776CB6AED843393F04CD458E0AA2D9F1D5F31A402072B2D6')\n);\nNetwork.TESTNET = new Network(\n\t'testnet',\n\t0x98,\n\tnew Date(Date.UTC(2022, 9, 31, 21, 7, 47)),\n\tnew Hash256('49D6E1CE276A85B70EAFE52349AACCA389302E7A9754BCF1221E79494FC665A4')\n);\nNetwork.NETWORKS = [Network.MAINNET, Network.TESTNET];\n","/* eslint-disable no-unused-vars */\nimport { KeyPair } from './KeyPair.js';\nimport { PublicKey, SharedKey256 } from '../CryptoTypes.js';\n/* eslint-enable no-unused-vars */\nimport { deriveSharedKeyFactory } from '../SharedKey.js';\nimport { sha512 } from '@noble/hashes/sha512';\n\nconst deriveSharedKeyImpl = deriveSharedKeyFactory('catapult', sha512);\n\n/**\n * Derives shared key from key pair and other party's public key.\n * @param {KeyPair} keyPair Key pair.\n * @param {PublicKey} otherPublicKey Other party's public key.\n * @returns {SharedKey256} Shared encryption key.\n */\nconst deriveSharedKey = (keyPair, otherPublicKey) => deriveSharedKeyImpl(keyPair.privateKey.bytes, otherPublicKey);\n\nexport { deriveSharedKey }; // eslint-disable-line import/prefer-default-export\n","import {\n\tAddress,\n\t/* eslint-disable no-unused-vars */\n\tNetwork\n\t/* eslint-enable no-unused-vars */\n} from './Network.js';\nimport { generateMosaicId, generateNamespaceId } from './idGenerator.js';\nimport * as sc from './models.js';\nimport {\n\tHash256,\n\tPublicKey,\n\t/* eslint-disable no-unused-vars */\n\tSignature\n\t/* eslint-enable no-unused-vars */\n} from '../CryptoTypes.js';\nimport RuleBasedTransactionFactory from '../RuleBasedTransactionFactory.js';\nimport { uint8ToHex } from '../utils/converter.js';\n\n/**\n * Factory for creating Symbol transactions.\n */\nexport default class TransactionFactory {\n\t/**\n\t * Creates a factory for the specified network.\n\t * @param {Network} network Symbol network.\n\t * @param {Map<string, Function>|undefined} typeRuleOverrides Type rule overrides.\n\t */\n\tconstructor(network, typeRuleOverrides = undefined) {\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tthis._factory = TransactionFactory._buildRules(typeRuleOverrides); // eslint-disable-line no-underscore-dangle\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tthis._network = network;\n\t}\n\n\t/**\n\t * Gets class type.\n\t * @returns {typeof TransactionFactory} Class type.\n\t */\n\tget static() { // eslint-disable-line class-methods-use-this\n\t\treturn TransactionFactory;\n\t}\n\n\t/**\n\t * Gets rule names with registered hints.\n\t * @returns {Array<string>} Rule names with registered hints.\n\t */\n\tget ruleNames() {\n\t\treturn Array.from(this._factory.rules.keys());\n\t}\n\n\t/**\n\t * Looks up the friendly name for the specified transaction.\n\t * @param {sc.TransactionType} transactionType Transaction type.\n\t * @param {number} transactionVersion Transaction version.\n\t * @returns {string} Transaction friendly name.\n\t */\n\tstatic lookupTransactionName(transactionType, transactionVersion) {\n\t\treturn `${sc.TransactionType.valueToKey(transactionType.value).toLowerCase()}_transaction_v${transactionVersion}`;\n\t}\n\n\t/**\n\t * Creates a transaction from a transaction descriptor.\n\t * @template TTransaction\n\t * @param {object} transactionDescriptor Transaction descriptor.\n\t * @param {boolean} autosort When set (default), descriptor arrays requiring ordering will be automatically sorted.\n\t *                           When unset, descriptor arrays will be presumed to be already sorted.\n\t * @param {{createByName: Function}} FactoryClass Factory class used to create the transaction.\n\t * @returns {TTransaction} Newly created transaction.\n\t * @private\n\t */\n\t_createAndExtend(transactionDescriptor, autosort, FactoryClass) {\n\t\tconst transaction = this._factory.createFromFactory(FactoryClass.createByName, {\n\t\t\t...transactionDescriptor,\n\t\t\tnetwork: this._network.identifier\n\t\t});\n\t\tif (autosort)\n\t\t\ttransaction.sort();\n\n\t\t// autogenerate artifact ids\n\t\tif (sc.TransactionType.NAMESPACE_REGISTRATION === transaction.type) {\n\t\t\tconst parentId = sc.NamespaceRegistrationType.CHILD === transaction.registrationType ? transaction.parentId.value : 0n;\n\t\t\tconst rawNamespaceId = generateNamespaceId(new TextDecoder().decode(transaction.name), parentId);\n\t\t\ttransaction.id = new sc.NamespaceId(rawNamespaceId);\n\t\t} else if (sc.TransactionType.MOSAIC_DEFINITION === transaction.type) {\n\t\t\tconst address = this._network.publicKeyToAddress(new PublicKey(transaction.signerPublicKey.bytes));\n\t\t\ttransaction.id = new sc.MosaicId(generateMosaicId(address, transaction.nonce.value));\n\t\t}\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Creates a transaction from a transaction descriptor.\n\t * @param {object} transactionDescriptor Transaction descriptor.\n\t * @param {boolean} autosort When set (default), descriptor arrays requiring ordering will be automatically sorted.\n\t *                           When unset, descriptor arrays will be presumed to be already sorted.\n\t * @returns {sc.Transaction} Newly created transaction.\n\t */\n\tcreate(transactionDescriptor, autosort = true) {\n\t\treturn this._createAndExtend(transactionDescriptor, autosort, sc.TransactionFactory);\n\t}\n\n\t/**\n\t * Creates an embedded transaction from a transaction descriptor.\n\t * @param {object} transactionDescriptor Transaction descriptor.\n\t * @param {boolean} autosort When set (default), descriptor arrays requiring ordering will be automatically sorted.\n\t *                           When unset, descriptor arrays will be presumed to be already sorted.\n\t * @returns {sc.EmbeddedTransaction} Newly created transaction.\n\t */\n\tcreateEmbedded(transactionDescriptor, autosort = true) {\n\t\treturn this._createAndExtend(transactionDescriptor, autosort, sc.EmbeddedTransactionFactory);\n\t}\n\n\t/**\n\t * Deserializes a transaction from a binary payload.\n\t * @param {Uint8Array} payload Binary payload.\n\t * @returns {sc.Transaction} Deserialized transaction.\n\t */\n\tstatic deserialize(payload) {\n\t\treturn sc.TransactionFactory.deserialize(payload);\n\t}\n\n\t/**\n\t * Deserializes an embedded transaction from a binary payload.\n\t * @param {Uint8Array} payload Binary payload.\n\t * @returns {sc.EmbeddedTransaction} Deserialized embedded transaction.\n\t */\n\tstatic deserializeEmbedded(payload) {\n\t\treturn sc.EmbeddedTransactionFactory.deserialize(payload);\n\t}\n\n\t/**\n\t * Attaches a signature to a transaction.\n\t * @param {sc.Transaction} transaction Transaction object.\n\t * @param {Signature} signature Signature to attach.\n\t * @returns {string} JSON transaction payload.\n\t */\n\tstatic attachSignature(transaction, signature) {\n\t\ttransaction.signature = new sc.Signature(signature.bytes);\n\n\t\tconst transactionBuffer = transaction.serialize();\n\t\tconst hexPayload = uint8ToHex(transactionBuffer);\n\t\tconst jsonPayload = `{\"payload\": \"${hexPayload}\"}`;\n\t\treturn jsonPayload;\n\t}\n\n\t/**\n\t * Tries to coerce an sdk type to a model type.\n\t * @param {object} value Value to convert.\n\t * @returns {sc.Address|undefined} Converted value or undefined.\n\t * @private\n\t */\n\tstatic _symbolTypeConverter(value) {\n\t\tif (value instanceof Address)\n\t\t\treturn new sc.UnresolvedAddress(value.bytes);\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Builds a rule based transaction factory.\n\t * @param {Map<string, Function>|undefined} typeRuleOverrides Type rule overrides.\n\t * @returns {RuleBasedTransactionFactory} Rule based transaction factory.\n\t * @private\n\t */\n\tstatic _buildRules(typeRuleOverrides) {\n\t\tconst factory = new RuleBasedTransactionFactory(sc, this._symbolTypeConverter, typeRuleOverrides);\n\t\tfactory.autodetect();\n\n\t\t['MosaicFlags', 'AccountRestrictionFlags'].forEach(name => { factory.addFlagsParser(name); });\n\n\t\t[\n\t\t\t'AliasAction', 'LinkAction', 'LockHashAlgorithm',\n\t\t\t'MosaicRestrictionType', 'MosaicSupplyChangeAction',\n\t\t\t'NamespaceRegistrationType', 'NetworkType', 'TransactionType'\n\t\t].forEach(name => { factory.addEnumParser(name); });\n\n\t\tfactory.addStructParser('UnresolvedMosaic');\n\n\t\tconst sdkTypeMapping = {\n\t\t\tUnresolvedAddress: Address,\n\t\t\tAddress,\n\t\t\tHash256,\n\t\t\tPublicKey,\n\t\t\tVotingPublicKey: PublicKey\n\t\t};\n\t\tObject.keys(sdkTypeMapping).forEach(name => { factory.addPodParser(name, sdkTypeMapping[name]); });\n\n\t\t['UnresolvedMosaicId', 'TransactionType', 'UnresolvedAddress', 'struct:UnresolvedMosaic'].forEach(name => {\n\t\t\tfactory.addArrayParser(name);\n\t\t});\n\n\t\treturn factory;\n\t}\n}\n","import { KeyPair } from './KeyPair.js';\nimport { PrivateKey } from '../CryptoTypes.js';\n\nconst setBuffer = (destination, offset, source) => {\n\tsource.forEach((byte, i) => { destination.setUint8(offset + i, source[i]); });\n};\n\n/**\n * Generates symbol voting keys.\n */\nexport default class VotingKeysGenerator {\n\t/**\n\t * Creates a generator around a voting root key pair.\n\t * @param {KeyPair} rootKeyPair Voting root key pair.\n\t * @param {Function} privateKeyGenerator Private key generator.\n\t */\n\tconstructor(rootKeyPair, privateKeyGenerator = PrivateKey.random) {\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tthis._rootKeyPair = rootKeyPair;\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tthis._privateKeyGenerator = privateKeyGenerator;\n\t}\n\n\t/**\n\t * Generates voting keys for specified epochs.\n\t * @param {bigint} startEpoch Start epoch.\n\t * @param {bigint} endEpoch End epoch.\n\t * @returns {Uint8Array} Serialized voting keys.\n\t */\n\tgenerate(startEpoch, endEpoch) {\n\t\tconst HEADER_SIZE = 80;\n\t\tconst EPOCH_ENTRY_SIZE = 96;\n\n\t\tconst numEpochs = Number(endEpoch - startEpoch + 1n);\n\t\tconst buffer = new ArrayBuffer(HEADER_SIZE + (EPOCH_ENTRY_SIZE * numEpochs));\n\n\t\tconst view = new DataView(buffer);\n\t\tview.setBigUint64(0, startEpoch, true); // start key identifier\n\t\tview.setBigUint64(8, endEpoch, true); // end key identifier\n\t\tview.setBigUint64(16, 0xFFFFFFFFFFFFFFFFn, true); // reserved - last (used) key identifier\n\t\tview.setBigUint64(24, 0xFFFFFFFFFFFFFFFFn, true); // reserved - last wiped key identifier\n\n\t\tsetBuffer(view, 32, this._rootKeyPair.publicKey.bytes); // root voting public key\n\t\tview.setBigUint64(64, startEpoch, true); // level 1/1 start key identifier\n\t\tview.setBigUint64(72, endEpoch, true); // level 1/1 end key identifier\n\n\t\tfor (let i = 0; i < numEpochs; ++i) {\n\t\t\tconst identifier = endEpoch - BigInt(i);\n\t\t\tconst childPrivateKey = this._privateKeyGenerator();\n\t\t\tconst childKeyPair = new KeyPair(childPrivateKey);\n\n\t\t\tconst parentSignedPayloadBuffer = new ArrayBuffer(40);\n\t\t\tconst parentSignedPayloadView = new DataView(parentSignedPayloadBuffer);\n\t\t\tsetBuffer(parentSignedPayloadView, 0, childKeyPair.publicKey.bytes);\n\t\t\tparentSignedPayloadView.setBigUint64(32, identifier, true);\n\t\t\tconst signature = this._rootKeyPair.sign(new Uint8Array(parentSignedPayloadBuffer));\n\n\t\t\tconst startOffset = HEADER_SIZE + (EPOCH_ENTRY_SIZE * i);\n\t\t\tsetBuffer(view, startOffset, childKeyPair.privateKey.bytes); // child voting private key used to sign votes for an epoch\n\t\t\tsetBuffer(view, startOffset + PrivateKey.SIZE, signature.bytes); // signature proving derivation of child key pair from root\n\t\t}\n\n\t\treturn new Uint8Array(buffer);\n\t}\n}\n","/* eslint-disable no-unused-vars */\nimport { Address } from './Network.js';\n/* eslint-enable no-unused-vars */\nimport { sha3_256 } from '@noble/hashes/sha3';\n\nconst NAMESPACE_FLAG = 1n << 63n;\n\nconst uint32ToBytes = value => new Uint8Array([\n\tvalue & 0xFF,\n\t(value >> 8) & 0xFF,\n\t(value >> 16) & 0xFF,\n\t(value >> 24) & 0xFF\n]);\n\nconst digestToBigInt = digest => {\n\tlet result = 0n;\n\tfor (let i = 0; 8 > i; ++i)\n\t\tresult += (BigInt(digest[i]) << BigInt(8 * i));\n\n\treturn result;\n};\n\n/**\n * Generates a mosaic id from an owner address and a nonce.\n * @param {Address} ownerAddress Owner address.\n * @param {number} nonce Nonce.\n * @returns {bigint} Computed mosaic id.\n */\nconst generateMosaicId = (ownerAddress, nonce) => {\n\tconst hasher = sha3_256.create();\n\thasher.update(uint32ToBytes(nonce));\n\thasher.update(ownerAddress.bytes);\n\tconst digest = hasher.digest();\n\n\tlet result = digestToBigInt(digest);\n\tif (result & NAMESPACE_FLAG)\n\t\tresult -= NAMESPACE_FLAG;\n\n\treturn result;\n};\n\n/**\n * Generates a namespace id from a name and an optional parent namespace id.\n * @param {string} name Namespace name.\n * @param {bigint} parentNamespaceId Parent namespace id.\n * @returns {bigint} Computed namespace id.\n */\nconst generateNamespaceId = (name, parentNamespaceId = 0n) => {\n\tconst hasher = sha3_256.create();\n\thasher.update(uint32ToBytes(Number(parentNamespaceId & 0xFFFFFFFFn)));\n\thasher.update(uint32ToBytes(Number((parentNamespaceId >> 32n) & 0xFFFFFFFFn)));\n\thasher.update(name);\n\tconst digest = new Uint8Array(hasher.digest());\n\n\tconst result = digestToBigInt(digest);\n\treturn result | NAMESPACE_FLAG;\n};\n\n/**\n * Returns true if a name is a valid namespace name.\n * @param {string} name Namespace name to check.\n * @returns {boolean} true if the specified name is valid.\n */\nconst isValidNamespaceName = name => {\n\tconst isAlphanum = character => ('a' <= character && 'z' >= character) || ('0' <= character && '9' >= character);\n\tif (!name || !isAlphanum(name[0]))\n\t\treturn false;\n\n\tfor (let i = 0; i < name.length; ++i) {\n\t\tconst ch = name[i];\n\t\tif (!isAlphanum(ch) && '_' !== ch && '-' !== ch)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n};\n\n/**\n * Parses a fully qualified namespace name into a path.\n * @param {string} fullyQualifiedName Fully qualified namespace name.\n * @returns {Array<bigint>} Computed namespace path.\n */\nconst generateNamespacePath = fullyQualifiedName => {\n\tconst path = [];\n\tlet parentNamespaceId = 0n;\n\tfullyQualifiedName.split('.').forEach(name => {\n\t\tif (!isValidNamespaceName(name))\n\t\t\tthrow Error(`fully qualified name is invalid due to invalid part name (${fullyQualifiedName})`);\n\n\t\tpath.push(generateNamespaceId(name, parentNamespaceId));\n\t\tparentNamespaceId = path[path.length - 1];\n\t});\n\n\treturn path;\n};\n\n/**\n * Generates a mosaic id from a fully qualified mosaic alias name.\n * @param {string} fullyQualifiedName Fully qualified mosaic name.\n * @returns {bigint} Computed mosaic id.\n */\nconst generateMosaicAliasId = fullyQualifiedName => {\n\tconst path = generateNamespacePath(fullyQualifiedName);\n\treturn path[path.length - 1];\n};\n\nexport {\n\tgenerateMosaicId,\n\tgenerateNamespaceId,\n\tisValidNamespaceName,\n\tgenerateNamespacePath,\n\tgenerateMosaicAliasId\n};\n","import { KeyPair, Verifier } from './KeyPair.js';\nimport MessageEncoder from './MessageEncoder.js';\nimport { Address, Network, NetworkTimestamp } from './Network.js';\nimport SymbolTransactionFactory from './TransactionFactory.js';\nimport VotingKeysGenerator from './VotingKeysGenerator.js';\nimport {\n\tgenerateMosaicAliasId,\n\tgenerateMosaicId,\n\tgenerateNamespaceId,\n\tgenerateNamespacePath,\n\tisValidNamespaceName\n} from './idGenerator.js';\nimport {\n\tdeserializePatriciaTreeNodes,\n\tproveMerkle,\n\tprovePatriciaMerkle\n} from './merkle.js';\nimport { metadataGenerateKey, metadataUpdateValue } from './metadata.js';\nimport * as models from './models.js';\nimport * as descriptors from './models_ts.js';\nimport { SymbolAccount, SymbolFacade, SymbolPublicAccount } from '../facade/SymbolFacade.js';\n\nexport {\n\t// region facade\n\n\t/**\n\t * Facade used to interact with Symbol blockchain.\n\t * @type {typeof SymbolFacade}\n\t */\n\tSymbolFacade,\n\n\t/**\n\t * Symbol public account.\n\t * @type {typeof SymbolPublicAccount}\n\t */\n\tSymbolPublicAccount,\n\n\t/**\n\t * Symbol account.\n\t * @type {typeof SymbolAccount}\n\t */\n\tSymbolAccount,\n\n\t// endregion\n\n\t// region common\n\n\t/**\n\t * Factory for creating Symbol transactions.\n\t * @type {typeof SymbolTransactionFactory}\n\t */\n\tSymbolTransactionFactory,\n\n\t/**\n\t * Represents a Symbol network timestamp with second resolution.\n\t * @type {typeof NetworkTimestamp}\n\t */\n\tNetworkTimestamp,\n\n\t/**\n\t * Represents a Symbol address.\n\t * @type {typeof Address}\n\t */\n\tAddress,\n\n\t/**\n\t * Represents a Symbol network.\n\t * @type {typeof Network}\n\t */\n\tNetwork,\n\n\t/**\n\t * Encrypts and encodes messages between two parties.\n\t * @type {typeof MessageEncoder}\n\t */\n\tMessageEncoder,\n\n\t/**\n\t * Encrypts and encodes messages between two parties.\n\t * @type {typeof KeyPair}\n\t */\n\tKeyPair,\n\n\t/**\n\t * Encrypts and encodes messages between two parties.\n\t * @type {typeof Verifier}\n\t */\n\tVerifier,\n\n\t// endregion\n\n\t// region Symbol extensions\n\n\tgenerateMosaicId,\n\tgenerateNamespaceId,\n\tisValidNamespaceName,\n\tgenerateNamespacePath,\n\tgenerateMosaicAliasId,\n\n\tproveMerkle,\n\tdeserializePatriciaTreeNodes,\n\tprovePatriciaMerkle,\n\n\tmetadataGenerateKey,\n\tmetadataUpdateValue,\n\n\t/**\n\t * Generates symbol voting keys.\n\t * @type {typeof VotingKeysGenerator}\n\t */\n\tVotingKeysGenerator,\n\n\t/**\n\t * Raw models generated from catbuffer schemas.\n\t */\n\tmodels,\n\n\t/**\n\t * Descriptors generated from catbuffer schemas for improved TypeScript support.\n\t */\n\tdescriptors\n\n\t// endregion\n};\n","import { Hash256 } from '../CryptoTypes.js';\nimport { deepCompare } from '../utils/arrayHelpers.js';\nimport { uint8ToHex } from '../utils/converter.js';\nimport { sha3_256 } from '@noble/hashes/sha3';\n\n// region MerkleHashBuilder\n\n/**\n * Builder for creating a merkle hash.\n */\nexport class MerkleHashBuilder {\n\t/**\n\t * Creates a merkle hash builder.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tthis._hashes = [];\n\t}\n\n\t/**\n\t * Adds a hash to the merkle hash.\n\t * @param {Hash256} componentHash Hash to add.\n\t */\n\tupdate(componentHash) {\n\t\tthis._hashes.push(componentHash.bytes);\n\t}\n\n\t/**\n\t * Calculates the merkle hash.\n\t * @returns {Hash256} Merkle hash.\n\t */\n\tfinal() {\n\t\tif (0 === this._hashes.length)\n\t\t\treturn Hash256.zero();\n\n\t\tlet numRemainingHashes = this._hashes.length;\n\t\twhile (1 < numRemainingHashes) {\n\t\t\tlet i = 0;\n\t\t\twhile (i < numRemainingHashes) {\n\t\t\t\tconst hasher = sha3_256.create();\n\t\t\t\thasher.update(this._hashes[i]);\n\n\t\t\t\tif (i + 1 < numRemainingHashes) {\n\t\t\t\t\thasher.update(this._hashes[i + 1]);\n\t\t\t\t} else {\n\t\t\t\t\t// if there is an odd number of hashes, duplicate the last one\n\t\t\t\t\thasher.update(this._hashes[i]);\n\t\t\t\t\tnumRemainingHashes += 1;\n\t\t\t\t}\n\n\t\t\t\tthis._hashes[Math.floor(i / 2)] = hasher.digest();\n\t\t\t\ti += 2;\n\t\t\t}\n\n\t\t\tnumRemainingHashes = Math.floor(numRemainingHashes / 2);\n\t\t}\n\n\t\treturn new Hash256(this._hashes[0]);\n\t}\n}\n\n// endregion\n\n// region proveMerkle\n\n/**\n * Proves a merkle hash.\n * @param {Hash256} leafHash Leaf hash to prove.\n * @param {Array<MerklePart>} merklePath Merkle *hash chain* path from leaf to root.\n * @param {Hash256} rootHash Root hash of the merkle tree.\n * @returns {boolean} \\c true if leaf hash is connected to root hash; false otherwise.\n */\nconst proveMerkle = (leafHash, merklePath, rootHash) => {\n\tconst computedRootHash = merklePath.reduce((workingHash, merklePart) => {\n\t\tconst hasher = sha3_256.create();\n\t\tif (merklePart.isLeft) {\n\t\t\thasher.update(merklePart.hash.bytes);\n\t\t\thasher.update(workingHash.bytes);\n\t\t} else {\n\t\t\thasher.update(workingHash.bytes);\n\t\t\thasher.update(merklePart.hash.bytes);\n\t\t}\n\n\t\treturn new Hash256(hasher.digest());\n\t}, leafHash);\n\n\treturn 0 === deepCompare(rootHash.bytes, computedRootHash.bytes);\n};\n\n// endregion\n\n// region LeafNode / BranchNode\n\nconst getNibbleAt = (path, index) => {\n\tconst byte = path.path[Math.floor(index / 2)];\n\treturn 1 === index % 2 ? byte & 0xF : byte >>> 4;\n};\n\nconst encodePath = (path, isLeaf) => {\n\tlet i = 0;\n\tconst buffer = new Uint8Array(1 + Math.floor(path.size / 2));\n\tbuffer[0] = isLeaf ? 0x20 : 0;\n\tif (1 === path.size % 2) {\n\t\tbuffer[0] |= 0x10 | getNibbleAt(path, 0);\n\t\t++i;\n\t}\n\n\twhile (i < path.size) {\n\t\tbuffer[1 + Math.floor(i / 2)] = (getNibbleAt(path, i) << 4) + (getNibbleAt(path, i + 1));\n\t\ti += 2;\n\t}\n\n\treturn buffer;\n};\n\n/**\n *  Node in a compact Patricia tree.\n */\nexport class TreeNode {\n\t/**\n\t * Creates a tree node.\n\t * @param {PatriciaTreePath} path Node path.\n\t */\n\tconstructor(path) {\n\t\t/**\n\t\t * Node path.\n\t\t * @type {PatriciaTreePath}\n\t\t */\n\t\tthis.path = path;\n\t}\n\n\t/**\n\t * Gets hex representation of path.\n\t * @returns {string} Hex representation of path.\n\t */\n\tget hexPath() {\n\t\treturn uint8ToHex(this.path.path).substring(0, this.path.size);\n\t}\n\n\t/**\n\t * Calculates node hash.\n\t * @returns {Hash256} Hash of the node.\n\t */\n\tcalculateHash() { // eslint-disable-line class-methods-use-this\n\t\treturn Hash256.zero();\n\t}\n}\n\n/**\n *  Leaf node in a compact Patricia tree.\n */\nexport class LeafNode extends TreeNode {\n\t/**\n\t * Creates a leaf node.\n\t * @param {PatriciaTreePath} path Leaf path.\n\t * @param {Hash256} value Leaf value.\n\t */\n\tconstructor(path, value) {\n\t\tsuper(path);\n\n\t\t/**\n\t\t * Leaf value.\n\t\t * @type {Hash256}\n\t\t */\n\t\tthis.value = value;\n\t}\n\n\t/**\n\t * Calculates node hash.\n\t * @override\n\t * @returns {Hash256} Hash of the node.\n\t */\n\tcalculateHash() {\n\t\tconst hasher = sha3_256.create();\n\t\thasher.update(encodePath(this.path, true));\n\t\thasher.update(this.value.bytes);\n\t\treturn new Hash256(hasher.digest());\n\t}\n}\n\n/**\n *  Branch node in a compact Patricia tree.\n */\nexport class BranchNode extends TreeNode {\n\t/**\n\t * Creates a branch node.\n\t * @param {PatriciaTreePath} path Branch path.\n\t * @param {Array<Hash256>} links Branch links.\n\t */\n\tconstructor(path, links) {\n\t\tsuper(path);\n\n\t\t/**\n\t\t * Branch links.\n\t\t * @type {Array<Hash256>}\n\t\t */\n\t\tthis.links = links;\n\t}\n\n\t/**\n\t * Calculates node hash.\n\t * @override\n\t * @returns {Hash256} Hash of the node.\n\t */\n\tcalculateHash() {\n\t\tconst hasher = sha3_256.create();\n\t\thasher.update(encodePath(this.path, false));\n\t\tthis.links.forEach(link => {\n\t\t\thasher.update((undefined === link ? Hash256.zero() : link).bytes);\n\t\t});\n\n\t\treturn new Hash256(hasher.digest());\n\t}\n}\n\n// endregion\n\n// region deserializePatriciaTreeNodes\n\nclass BufferReader {\n\tconstructor(buffer) {\n\t\tthis.view = new DataView(buffer);\n\t\tthis.offset = 0;\n\t}\n\n\tget eof() {\n\t\treturn this.offset === this.view.byteLength;\n\t}\n\n\treadByte() {\n\t\tconst result = this.view.getUint8(this.offset);\n\t\t++this.offset;\n\t\treturn result;\n\t}\n\n\treadShort() {\n\t\tconst result = this.view.getUint16(this.offset, true);\n\t\tthis.offset += 2;\n\t\treturn result;\n\t}\n\n\treadBytes(count) {\n\t\tconst result = new Uint8Array(this.view.buffer, this.offset, count);\n\t\tthis.offset += count;\n\t\treturn result;\n\t}\n}\n\nconst deserializePath = reader => {\n\tconst numNibbles = reader.readByte();\n\tconst numBytes = Math.floor((numNibbles + 1) / 2);\n\treturn { path: reader.readBytes(numBytes), size: numNibbles };\n};\n\nconst deserializeLeaf = reader => {\n\tconst path = deserializePath(reader);\n\tconst value = new Hash256(reader.readBytes(Hash256.SIZE));\n\treturn new LeafNode(path, value);\n};\n\nconst deserializeBranch = reader => {\n\tconst path = deserializePath(reader);\n\n\tconst linksMask = reader.readShort();\n\tconst links = new Array(16);\n\tfor (let i = 0; i < links.length; ++i)\n\t\tlinks[i] = linksMask & (2 ** i) ? new Hash256(reader.readBytes(Hash256.SIZE)) : undefined;\n\n\treturn new BranchNode(path, links);\n};\n\n/**\n * Deserializes a buffer containing patricia tree nodes.\n * @param {Uint8Array} buffer Buffer containing serialized patricia tree nodes.\n * @returns {Array<TreeNode>} Deserialized patricia tree nodes.\n */\nconst deserializePatriciaTreeNodes = buffer => {\n\tconst reader = new BufferReader(buffer.buffer);\n\tconst nodes = [];\n\twhile (!reader.eof) {\n\t\tconst nodeMarker = reader.readByte();\n\n\t\tswitch (nodeMarker) {\n\t\tcase 0xFF:\n\t\t\tnodes.push(deserializeLeaf(reader));\n\t\t\tbreak;\n\n\t\tcase 0x00:\n\t\t\tnodes.push(deserializeBranch(reader));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tthrow new Error(`invalid marker of a serialized node (${nodeMarker})`);\n\t\t}\n\t}\n\n\treturn nodes;\n};\n\n// endregion\n\n// region provePatriciaMerkle\n\n/**\n * Possible results of a patricia merkle proof.\n */\nexport class PatriciaMerkleProofResult {\n\t/**\n\t * Proof is valid (positive).\n\t * @type {number}\n\t */\n\tstatic VALID_POSITIVE = 0x0001;\n\n\t/**\n\t * Proof is valid (negative).\n\t * @type {number}\n\t */\n\tstatic VALID_NEGATIVE = 0x0002;\n\n\t/**\n\t * Negative proof is inconclusive.\n\t * @type {number}\n\t */\n\tstatic INCONCLUSIVE = 0x4001;\n\n\t/**\n\t * State hash cannot be derived from subcache merkle roots.\n\t * @type {number}\n\t */\n\tstatic STATE_HASH_DOES_NOT_MATCH_ROOTS = 0x8001;\n\n\t/**\n\t * Root of the path tree being proven is not a subcache merkle root.\n\t * @type {number}\n\t */\n\tstatic UNANCHORED_PATH_TREE = 0x8002;\n\n\t/**\n\t * Leaf value does not match expected value.\n\t * @type {number}\n\t */\n\tstatic LEAF_VALUE_MISMATCH = 0x8003;\n\n\t/**\n\t * Provided merkle hash contains an unlinked node.\n\t * @type {number}\n\t */\n\tstatic UNLINKED_NODE = 0x8004;\n\n\t/**\n\t * Actual merkle path does not match encoded key.\n\t * @type {number}\n\t */\n\tstatic PATH_MISMATCH = 0x8005;\n}\n\nconst checkStateHash = (stateHash, subcacheMerkleRoots) => {\n\tconst hasher = sha3_256.create();\n\tsubcacheMerkleRoots.forEach(root => {\n\t\thasher.update(root.bytes);\n\t});\n\n\treturn 0 === deepCompare(stateHash.bytes, hasher.digest());\n};\n\nconst findLinkIndex = (branchNode, targetLinkHash) => (\n\tbranchNode.links.findIndex(link => undefined !== link && 0 === deepCompare(targetLinkHash.bytes, link.bytes))\n);\n\n/**\n * Proves a patricia merkle hash.\n * @param {Hash256} encodedKey Encoded key of the state to prove.\n * @param {Hash256} valueToTest Expected hash of the state to prove.\n * @param {Array<TreeNode>} merklePath Merkle *node* path from root to leaf.\n * @param {Hash256} stateHash State hash from a block header.\n * @param {Array<Hash256>} subcacheMerkleRoots Sub cache merkle roots corresponding to the state hash.\n * @returns {number} Proof result code.\n */\nconst provePatriciaMerkle = (encodedKey, valueToTest, merklePath, stateHash, subcacheMerkleRoots) => {\n\tif (!checkStateHash(stateHash, subcacheMerkleRoots))\n\t\treturn PatriciaMerkleProofResult.STATE_HASH_DOES_NOT_MATCH_ROOTS;\n\n\tconst pathRootHash = merklePath[0].calculateHash();\n\tif (subcacheMerkleRoots.every(root => 0 !== deepCompare(pathRootHash.bytes, root.bytes)))\n\t\treturn PatriciaMerkleProofResult.UNANCHORED_PATH_TREE;\n\n\t// positive proof must end with a leaf\n\tconst isPositiveProof = 'value' in merklePath[merklePath.length - 1];\n\tif (isPositiveProof) {\n\t\tif (0 !== deepCompare(valueToTest.bytes, (/** @type {LeafNode} */ (merklePath[merklePath.length - 1])).value.bytes))\n\t\t\treturn PatriciaMerkleProofResult.LEAF_VALUE_MISMATCH;\n\t}\n\n\tlet childHash;\n\tlet actualPath = '';\n\tfor (let i = merklePath.length - 1; 0 <= i; --i) {\n\t\tconst node = merklePath[i];\n\t\tconst nodeHash = node.calculateHash();\n\t\tlet formattedLinkIndex = '';\n\t\tif (childHash) {\n\t\t\tconst linkIndex = findLinkIndex(node, childHash);\n\t\t\tif (-1 === linkIndex)\n\t\t\t\treturn PatriciaMerkleProofResult.UNLINKED_NODE;\n\n\t\t\tformattedLinkIndex = uint8ToHex(new Uint8Array([linkIndex]))[1];\n\t\t}\n\n\t\tchildHash = nodeHash;\n\t\tactualPath = `${formattedLinkIndex}${node.hexPath}${actualPath}`;\n\t}\n\n\tif (isPositiveProof) {\n\t\t// for positive proof, expected and calculated paths must match exactly\n\t\treturn actualPath !== encodedKey.toString() ? PatriciaMerkleProofResult.PATH_MISMATCH : PatriciaMerkleProofResult.VALID_POSITIVE;\n\t}\n\n\t// for negative proof, expected path must start with calculated path and next nibble must be a dead end\n\tif (!encodedKey.toString().startsWith(actualPath))\n\t\treturn PatriciaMerkleProofResult.PATH_MISMATCH;\n\n\tconst nextNibble = getNibbleAt({ path: encodedKey.bytes, size: 2 * encodedKey.bytes.length }, actualPath.length);\n\tconst nextNode = (/** @type {BranchNode} */ (merklePath[merklePath.length - 1])).links[nextNibble];\n\treturn undefined !== nextNode ? PatriciaMerkleProofResult.INCONCLUSIVE : PatriciaMerkleProofResult.VALID_NEGATIVE;\n};\n\n// endregion\n\nexport {\n\tproveMerkle,\n\tdeserializePatriciaTreeNodes,\n\tprovePatriciaMerkle\n};\n\n// region type declarations\n\n/**\n * Path in a Patricia merkle treee.\n * @class\n * @typedef {object} PatriciaTreePath\n * @property {Uint8Array} path Bytes composing the full path.\n * @property {number} size Length (in nibbles) of the path.\n */\n\n/**\n * Represents part of a merkle tree proof.\n * @class\n * @typedef {object} MerklePart\n * @property {Hash256} hash Hash at this node.\n * @property {boolean} isLeft \\c true if this is a left node; right otherwise.\n */\n\n// endregion\n","import { sha3_256 } from '@noble/hashes/sha3';\n\n/**\n * Generates a metadata key from a string.\n * @param {string} seed Metadata key seed.\n * @returns {bigint} Metadata key.\n */\nconst metadataGenerateKey = seed => {\n\tconst hashResult = sha3_256(seed);\n\n\tconst keyBytes = hashResult.subarray(0, 8);\n\tkeyBytes[7] |= 0x80; // set high bit to match SDK V2 implementation\n\n\tconst keys = new BigUint64Array(keyBytes.buffer);\n\treturn keys[0];\n};\n\n/**\n * Creates a metadata payload for updating old value to new value.\n * @param {Uint8Array|undefined} oldValue Old metadata value.\n * @param {Uint8Array} newValue New metadata value.\n * @returns {Uint8Array} Metadata payload for updating old value to new value.\n */\nconst metadataUpdateValue = (oldValue, newValue) => {\n\tif (!oldValue)\n\t\treturn newValue;\n\n\tconst shorterLength = Math.min(oldValue.length, newValue.length);\n\tconst longerLength = Math.max(oldValue.length, newValue.length);\n\tconst isNewValueShorter = oldValue.length > newValue.length;\n\n\tconst result = new Uint8Array(longerLength);\n\n\tlet i = 0;\n\tfor (i = 0; i < shorterLength; ++i)\n\t\tresult[i] = oldValue[i] ^ newValue[i];\n\n\tfor (; i < longerLength; ++i)\n\t\tresult[i] = (isNewValueShorter ? oldValue : newValue)[i];\n\n\treturn result;\n};\n\nexport { metadataGenerateKey, metadataUpdateValue };\n","/* eslint-disable max-len, object-property-newline, no-underscore-dangle, no-use-before-define */\n\nimport BaseValue from '../BaseValue.js';\nimport ByteArray from '../ByteArray.js';\nimport BufferView from '../utils/BufferView.js';\nimport Writer from '../utils/Writer.js';\nimport * as arrayHelpers from '../utils/arrayHelpers.js';\nimport * as converter from '../utils/converter.js';\n\nexport class Amount extends BaseValue {\n\tstatic SIZE = 8;\n\n\tconstructor(amount = 0n) {\n\t\tsuper(Amount.SIZE, amount);\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new Amount(converter.bytesToBigIntUnaligned(byteArray, 8, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new Amount(converter.bytesToBigInt(byteArray, 8, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 8, false);\n\t}\n}\n\nexport class BlockDuration extends BaseValue {\n\tstatic SIZE = 8;\n\n\tconstructor(blockDuration = 0n) {\n\t\tsuper(BlockDuration.SIZE, blockDuration);\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new BlockDuration(converter.bytesToBigIntUnaligned(byteArray, 8, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new BlockDuration(converter.bytesToBigInt(byteArray, 8, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 8, false);\n\t}\n}\n\nexport class BlockFeeMultiplier extends BaseValue {\n\tstatic SIZE = 4;\n\n\tconstructor(blockFeeMultiplier = 0) {\n\t\tsuper(BlockFeeMultiplier.SIZE, blockFeeMultiplier);\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new BlockFeeMultiplier(converter.bytesToIntUnaligned(byteArray, 4, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new BlockFeeMultiplier(converter.bytesToInt(byteArray, 4, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 4, false);\n\t}\n}\n\nexport class Difficulty extends BaseValue {\n\tstatic SIZE = 8;\n\n\tconstructor(difficulty = 0n) {\n\t\tsuper(Difficulty.SIZE, difficulty);\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new Difficulty(converter.bytesToBigIntUnaligned(byteArray, 8, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new Difficulty(converter.bytesToBigInt(byteArray, 8, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 8, false);\n\t}\n}\n\nexport class FinalizationEpoch extends BaseValue {\n\tstatic SIZE = 4;\n\n\tconstructor(finalizationEpoch = 0) {\n\t\tsuper(FinalizationEpoch.SIZE, finalizationEpoch);\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new FinalizationEpoch(converter.bytesToIntUnaligned(byteArray, 4, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new FinalizationEpoch(converter.bytesToInt(byteArray, 4, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 4, false);\n\t}\n}\n\nexport class FinalizationPoint extends BaseValue {\n\tstatic SIZE = 4;\n\n\tconstructor(finalizationPoint = 0) {\n\t\tsuper(FinalizationPoint.SIZE, finalizationPoint);\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new FinalizationPoint(converter.bytesToIntUnaligned(byteArray, 4, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new FinalizationPoint(converter.bytesToInt(byteArray, 4, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 4, false);\n\t}\n}\n\nexport class Height extends BaseValue {\n\tstatic SIZE = 8;\n\n\tconstructor(height = 0n) {\n\t\tsuper(Height.SIZE, height);\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new Height(converter.bytesToBigIntUnaligned(byteArray, 8, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new Height(converter.bytesToBigInt(byteArray, 8, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 8, false);\n\t}\n}\n\nexport class Importance extends BaseValue {\n\tstatic SIZE = 8;\n\n\tconstructor(importance = 0n) {\n\t\tsuper(Importance.SIZE, importance);\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new Importance(converter.bytesToBigIntUnaligned(byteArray, 8, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new Importance(converter.bytesToBigInt(byteArray, 8, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 8, false);\n\t}\n}\n\nexport class ImportanceHeight extends BaseValue {\n\tstatic SIZE = 8;\n\n\tconstructor(importanceHeight = 0n) {\n\t\tsuper(ImportanceHeight.SIZE, importanceHeight);\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new ImportanceHeight(converter.bytesToBigIntUnaligned(byteArray, 8, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new ImportanceHeight(converter.bytesToBigInt(byteArray, 8, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 8, false);\n\t}\n}\n\nexport class UnresolvedMosaicId extends BaseValue {\n\tstatic SIZE = 8;\n\n\tconstructor(unresolvedMosaicId = 0n) {\n\t\tsuper(UnresolvedMosaicId.SIZE, unresolvedMosaicId);\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new UnresolvedMosaicId(converter.bytesToBigIntUnaligned(byteArray, 8, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new UnresolvedMosaicId(converter.bytesToBigInt(byteArray, 8, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 8, false);\n\t}\n}\n\nexport class MosaicId extends BaseValue {\n\tstatic SIZE = 8;\n\n\tconstructor(mosaicId = 0n) {\n\t\tsuper(MosaicId.SIZE, mosaicId);\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new MosaicId(converter.bytesToBigIntUnaligned(byteArray, 8, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new MosaicId(converter.bytesToBigInt(byteArray, 8, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 8, false);\n\t}\n}\n\nexport class Timestamp extends BaseValue {\n\tstatic SIZE = 8;\n\n\tconstructor(timestamp = 0n) {\n\t\tsuper(Timestamp.SIZE, timestamp);\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new Timestamp(converter.bytesToBigIntUnaligned(byteArray, 8, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new Timestamp(converter.bytesToBigInt(byteArray, 8, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 8, false);\n\t}\n}\n\nexport class UnresolvedAddress extends ByteArray {\n\tstatic SIZE = 24;\n\n\tconstructor(unresolvedAddress = new Uint8Array(24)) {\n\t\tsuper(UnresolvedAddress.SIZE, unresolvedAddress);\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 24;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new UnresolvedAddress(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 24));\n\t}\n\n\tserialize() {\n\t\treturn this.bytes;\n\t}\n}\n\nexport class Address extends ByteArray {\n\tstatic SIZE = 24;\n\n\tconstructor(address = new Uint8Array(24)) {\n\t\tsuper(Address.SIZE, address);\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 24;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new Address(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 24));\n\t}\n\n\tserialize() {\n\t\treturn this.bytes;\n\t}\n}\n\nexport class Hash256 extends ByteArray {\n\tstatic SIZE = 32;\n\n\tconstructor(hash256 = new Uint8Array(32)) {\n\t\tsuper(Hash256.SIZE, hash256);\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 32;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new Hash256(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 32));\n\t}\n\n\tserialize() {\n\t\treturn this.bytes;\n\t}\n}\n\nexport class Hash512 extends ByteArray {\n\tstatic SIZE = 64;\n\n\tconstructor(hash512 = new Uint8Array(64)) {\n\t\tsuper(Hash512.SIZE, hash512);\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 64;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new Hash512(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 64));\n\t}\n\n\tserialize() {\n\t\treturn this.bytes;\n\t}\n}\n\nexport class PublicKey extends ByteArray {\n\tstatic SIZE = 32;\n\n\tconstructor(publicKey = new Uint8Array(32)) {\n\t\tsuper(PublicKey.SIZE, publicKey);\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 32;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new PublicKey(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 32));\n\t}\n\n\tserialize() {\n\t\treturn this.bytes;\n\t}\n}\n\nexport class VotingPublicKey extends ByteArray {\n\tstatic SIZE = 32;\n\n\tconstructor(votingPublicKey = new Uint8Array(32)) {\n\t\tsuper(VotingPublicKey.SIZE, votingPublicKey);\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 32;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new VotingPublicKey(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 32));\n\t}\n\n\tserialize() {\n\t\treturn this.bytes;\n\t}\n}\n\nexport class Signature extends ByteArray {\n\tstatic SIZE = 64;\n\n\tconstructor(signature = new Uint8Array(64)) {\n\t\tsuper(Signature.SIZE, signature);\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 64;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new Signature(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 64));\n\t}\n\n\tserialize() {\n\t\treturn this.bytes;\n\t}\n}\n\nexport class Mosaic {\n\tstatic TYPE_HINTS = {\n\t\tmosaicId: 'pod:MosaicId',\n\t\tamount: 'pod:Amount'\n\t};\n\n\tconstructor() {\n\t\tthis._mosaicId = new MosaicId();\n\t\tthis._amount = new Amount();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget mosaicId() {\n\t\treturn this._mosaicId;\n\t}\n\n\tset mosaicId(value) {\n\t\tthis._mosaicId = value;\n\t}\n\n\tget amount() {\n\t\treturn this._amount;\n\t}\n\n\tset amount(value) {\n\t\tthis._amount = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += this.mosaicId.size;\n\t\tsize += this.amount.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new Mosaic();\n\n\t\tconst mosaicId = MosaicId.deserialize(view.buffer);\n\t\tview.shiftRight(mosaicId.size);\n\t\tconst amount = Amount.deserialize(view.buffer);\n\t\tview.shiftRight(amount.size);\n\n\t\tinstance._mosaicId = mosaicId;\n\t\tinstance._amount = amount;\n\t\treturn instance;\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new Mosaic();\n\n\t\tconst mosaicId = MosaicId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(mosaicId.size);\n\t\tconst amount = Amount.deserializeAligned(view.buffer);\n\t\tview.shiftRight(amount.size);\n\n\t\tinstance._mosaicId = mosaicId;\n\t\tinstance._amount = amount;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tbuffer.write(this._mosaicId.serialize());\n\t\tbuffer.write(this._amount.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += `mosaicId: ${this._mosaicId.toString()}, `;\n\t\tresult += `amount: ${this._amount.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tresult.mosaicId = this._mosaicId.toJson();\n\t\tresult.amount = this._amount.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class UnresolvedMosaic {\n\tstatic TYPE_HINTS = {\n\t\tmosaicId: 'pod:UnresolvedMosaicId',\n\t\tamount: 'pod:Amount'\n\t};\n\n\tconstructor() {\n\t\tthis._mosaicId = new UnresolvedMosaicId();\n\t\tthis._amount = new Amount();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget mosaicId() {\n\t\treturn this._mosaicId;\n\t}\n\n\tset mosaicId(value) {\n\t\tthis._mosaicId = value;\n\t}\n\n\tget amount() {\n\t\treturn this._amount;\n\t}\n\n\tset amount(value) {\n\t\tthis._amount = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += this.mosaicId.size;\n\t\tsize += this.amount.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new UnresolvedMosaic();\n\n\t\tconst mosaicId = UnresolvedMosaicId.deserialize(view.buffer);\n\t\tview.shiftRight(mosaicId.size);\n\t\tconst amount = Amount.deserialize(view.buffer);\n\t\tview.shiftRight(amount.size);\n\n\t\tinstance._mosaicId = mosaicId;\n\t\tinstance._amount = amount;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tbuffer.write(this._mosaicId.serialize());\n\t\tbuffer.write(this._amount.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += `mosaicId: ${this._mosaicId.toString()}, `;\n\t\tresult += `amount: ${this._amount.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tresult.mosaicId = this._mosaicId.toJson();\n\t\tresult.amount = this._amount.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class LinkAction {\n\tstatic UNLINK = new LinkAction(0);\n\n\tstatic LINK = new LinkAction(1);\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n\n\tstatic valueToKey(value) {\n\t\tconst values = [\n\t\t\t0, 1\n\t\t];\n\t\tconst keys = [\n\t\t\t'UNLINK', 'LINK'\n\t\t];\n\n\t\tconst index = values.indexOf(value);\n\t\tif (-1 === index)\n\t\t\tthrow RangeError(`invalid enum value ${value}`);\n\n\t\treturn keys[index];\n\t}\n\n\tstatic fromValue(value) {\n\t\treturn LinkAction[this.valueToKey(value)];\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 1;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToIntUnaligned(byteArray, 1, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToInt(byteArray, 1, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 1, false);\n\t}\n\n\ttoString() {\n\t\treturn `LinkAction.${LinkAction.valueToKey(this.value)}`;\n\t}\n\n\ttoJson() {\n\t\treturn this.value;\n\t}\n}\n\nexport class NetworkType {\n\tstatic MAINNET = new NetworkType(104);\n\n\tstatic TESTNET = new NetworkType(152);\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n\n\tstatic valueToKey(value) {\n\t\tconst values = [\n\t\t\t104, 152\n\t\t];\n\t\tconst keys = [\n\t\t\t'MAINNET', 'TESTNET'\n\t\t];\n\n\t\tconst index = values.indexOf(value);\n\t\tif (-1 === index)\n\t\t\tthrow RangeError(`invalid enum value ${value}`);\n\n\t\treturn keys[index];\n\t}\n\n\tstatic fromValue(value) {\n\t\treturn NetworkType[this.valueToKey(value)];\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 1;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToIntUnaligned(byteArray, 1, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToInt(byteArray, 1, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 1, false);\n\t}\n\n\ttoString() {\n\t\treturn `NetworkType.${NetworkType.valueToKey(this.value)}`;\n\t}\n\n\ttoJson() {\n\t\treturn this.value;\n\t}\n}\n\nexport class TransactionType {\n\tstatic ACCOUNT_KEY_LINK = new TransactionType(16716);\n\n\tstatic NODE_KEY_LINK = new TransactionType(16972);\n\n\tstatic AGGREGATE_COMPLETE = new TransactionType(16705);\n\n\tstatic AGGREGATE_BONDED = new TransactionType(16961);\n\n\tstatic VOTING_KEY_LINK = new TransactionType(16707);\n\n\tstatic VRF_KEY_LINK = new TransactionType(16963);\n\n\tstatic HASH_LOCK = new TransactionType(16712);\n\n\tstatic SECRET_LOCK = new TransactionType(16722);\n\n\tstatic SECRET_PROOF = new TransactionType(16978);\n\n\tstatic ACCOUNT_METADATA = new TransactionType(16708);\n\n\tstatic MOSAIC_METADATA = new TransactionType(16964);\n\n\tstatic NAMESPACE_METADATA = new TransactionType(17220);\n\n\tstatic MOSAIC_DEFINITION = new TransactionType(16717);\n\n\tstatic MOSAIC_SUPPLY_CHANGE = new TransactionType(16973);\n\n\tstatic MOSAIC_SUPPLY_REVOCATION = new TransactionType(17229);\n\n\tstatic MULTISIG_ACCOUNT_MODIFICATION = new TransactionType(16725);\n\n\tstatic ADDRESS_ALIAS = new TransactionType(16974);\n\n\tstatic MOSAIC_ALIAS = new TransactionType(17230);\n\n\tstatic NAMESPACE_REGISTRATION = new TransactionType(16718);\n\n\tstatic ACCOUNT_ADDRESS_RESTRICTION = new TransactionType(16720);\n\n\tstatic ACCOUNT_MOSAIC_RESTRICTION = new TransactionType(16976);\n\n\tstatic ACCOUNT_OPERATION_RESTRICTION = new TransactionType(17232);\n\n\tstatic MOSAIC_ADDRESS_RESTRICTION = new TransactionType(16977);\n\n\tstatic MOSAIC_GLOBAL_RESTRICTION = new TransactionType(16721);\n\n\tstatic TRANSFER = new TransactionType(16724);\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n\n\tstatic valueToKey(value) {\n\t\tconst values = [\n\t\t\t16716, 16972, 16705, 16961, 16707, 16963, 16712, 16722, 16978, 16708, 16964, 17220, 16717, 16973, 17229, 16725, 16974, 17230,\n\t\t\t16718, 16720, 16976, 17232, 16977, 16721, 16724\n\t\t];\n\t\tconst keys = [\n\t\t\t'ACCOUNT_KEY_LINK', 'NODE_KEY_LINK', 'AGGREGATE_COMPLETE', 'AGGREGATE_BONDED', 'VOTING_KEY_LINK', 'VRF_KEY_LINK', 'HASH_LOCK',\n\t\t\t'SECRET_LOCK', 'SECRET_PROOF', 'ACCOUNT_METADATA', 'MOSAIC_METADATA', 'NAMESPACE_METADATA', 'MOSAIC_DEFINITION',\n\t\t\t'MOSAIC_SUPPLY_CHANGE', 'MOSAIC_SUPPLY_REVOCATION', 'MULTISIG_ACCOUNT_MODIFICATION', 'ADDRESS_ALIAS', 'MOSAIC_ALIAS',\n\t\t\t'NAMESPACE_REGISTRATION', 'ACCOUNT_ADDRESS_RESTRICTION', 'ACCOUNT_MOSAIC_RESTRICTION', 'ACCOUNT_OPERATION_RESTRICTION',\n\t\t\t'MOSAIC_ADDRESS_RESTRICTION', 'MOSAIC_GLOBAL_RESTRICTION', 'TRANSFER'\n\t\t];\n\n\t\tconst index = values.indexOf(value);\n\t\tif (-1 === index)\n\t\t\tthrow RangeError(`invalid enum value ${value}`);\n\n\t\treturn keys[index];\n\t}\n\n\tstatic fromValue(value) {\n\t\treturn TransactionType[this.valueToKey(value)];\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 2;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToIntUnaligned(byteArray, 2, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToInt(byteArray, 2, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 2, false);\n\t}\n\n\ttoString() {\n\t\treturn `TransactionType.${TransactionType.valueToKey(this.value)}`;\n\t}\n\n\ttoJson() {\n\t\treturn this.value;\n\t}\n}\n\nexport class Transaction {\n\tstatic TYPE_HINTS = {\n\t\tsignature: 'pod:Signature',\n\t\tsignerPublicKey: 'pod:PublicKey',\n\t\tnetwork: 'enum:NetworkType',\n\t\ttype: 'enum:TransactionType',\n\t\tfee: 'pod:Amount',\n\t\tdeadline: 'pod:Timestamp'\n\t};\n\n\tconstructor() {\n\t\tthis._signature = new Signature();\n\t\tthis._signerPublicKey = new PublicKey();\n\t\tthis._version = 0;\n\t\tthis._network = NetworkType.MAINNET;\n\t\tthis._type = TransactionType.ACCOUNT_KEY_LINK;\n\t\tthis._fee = new Amount();\n\t\tthis._deadline = new Timestamp();\n\t\tthis._verifiableEntityHeaderReserved_1 = 0; // reserved field\n\t\tthis._entityBodyReserved_1 = 0; // reserved field\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget signature() {\n\t\treturn this._signature;\n\t}\n\n\tset signature(value) {\n\t\tthis._signature = value;\n\t}\n\n\tget signerPublicKey() {\n\t\treturn this._signerPublicKey;\n\t}\n\n\tset signerPublicKey(value) {\n\t\tthis._signerPublicKey = value;\n\t}\n\n\tget version() {\n\t\treturn this._version;\n\t}\n\n\tset version(value) {\n\t\tthis._version = value;\n\t}\n\n\tget network() {\n\t\treturn this._network;\n\t}\n\n\tset network(value) {\n\t\tthis._network = value;\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tset type(value) {\n\t\tthis._type = value;\n\t}\n\n\tget fee() {\n\t\treturn this._fee;\n\t}\n\n\tset fee(value) {\n\t\tthis._fee = value;\n\t}\n\n\tget deadline() {\n\t\treturn this._deadline;\n\t}\n\n\tset deadline(value) {\n\t\tthis._deadline = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += 4;\n\t\tsize += 4;\n\t\tsize += this.signature.size;\n\t\tsize += this.signerPublicKey.size;\n\t\tsize += 4;\n\t\tsize += 1;\n\t\tsize += this.network.size;\n\t\tsize += this.type.size;\n\t\tsize += this.fee.size;\n\t\tsize += this.deadline.size;\n\t\treturn size;\n\t}\n\n\tstatic _deserialize(view, instance) {\n\t\tconst size = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tview.shrink(size - 4);\n\t\tconst verifiableEntityHeaderReserved_1 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== verifiableEntityHeaderReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${verifiableEntityHeaderReserved_1})`);\n\t\tconst signature = Signature.deserialize(view.buffer);\n\t\tview.shiftRight(signature.size);\n\t\tconst signerPublicKey = PublicKey.deserialize(view.buffer);\n\t\tview.shiftRight(signerPublicKey.size);\n\t\tconst entityBodyReserved_1 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== entityBodyReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${entityBodyReserved_1})`);\n\t\tconst version = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst network = NetworkType.deserializeAligned(view.buffer);\n\t\tview.shiftRight(network.size);\n\t\tconst type = TransactionType.deserializeAligned(view.buffer);\n\t\tview.shiftRight(type.size);\n\t\tconst fee = Amount.deserializeAligned(view.buffer);\n\t\tview.shiftRight(fee.size);\n\t\tconst deadline = Timestamp.deserializeAligned(view.buffer);\n\t\tview.shiftRight(deadline.size);\n\n\t\tinstance._signature = signature;\n\t\tinstance._signerPublicKey = signerPublicKey;\n\t\tinstance._version = version;\n\t\tinstance._network = network;\n\t\tinstance._type = type;\n\t\tinstance._fee = fee;\n\t\tinstance._deadline = deadline;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tthis._serialize(buffer);\n\t\treturn buffer.storage;\n\t}\n\n\t_serialize(buffer) {\n\t\tbuffer.write(converter.intToBytes(this.size, 4, false));\n\t\tbuffer.write(converter.intToBytes(this._verifiableEntityHeaderReserved_1, 4, false));\n\t\tbuffer.write(this._signature.serialize());\n\t\tbuffer.write(this._signerPublicKey.serialize());\n\t\tbuffer.write(converter.intToBytes(this._entityBodyReserved_1, 4, false));\n\t\tbuffer.write(converter.intToBytes(this._version, 1, false));\n\t\tbuffer.write(this._network.serialize());\n\t\tbuffer.write(this._type.serialize());\n\t\tbuffer.write(this._fee.serialize());\n\t\tbuffer.write(this._deadline.serialize());\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += `signature: ${this._signature.toString()}, `;\n\t\tresult += `signerPublicKey: ${this._signerPublicKey.toString()}, `;\n\t\tresult += `version: ${'0x'.concat(this._version.toString(16))}, `;\n\t\tresult += `network: ${this._network.toString()}, `;\n\t\tresult += `type: ${this._type.toString()}, `;\n\t\tresult += `fee: ${this._fee.toString()}, `;\n\t\tresult += `deadline: ${this._deadline.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tresult.signature = this._signature.toJson();\n\t\tresult.signerPublicKey = this._signerPublicKey.toJson();\n\t\tresult.version = this._version;\n\t\tresult.network = this._network.toJson();\n\t\tresult.type = this._type.toJson();\n\t\tresult.fee = this._fee.toJson();\n\t\tresult.deadline = this._deadline.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedTransaction {\n\tstatic TYPE_HINTS = {\n\t\tsignerPublicKey: 'pod:PublicKey',\n\t\tnetwork: 'enum:NetworkType',\n\t\ttype: 'enum:TransactionType'\n\t};\n\n\tconstructor() {\n\t\tthis._signerPublicKey = new PublicKey();\n\t\tthis._version = 0;\n\t\tthis._network = NetworkType.MAINNET;\n\t\tthis._type = TransactionType.ACCOUNT_KEY_LINK;\n\t\tthis._embeddedTransactionHeaderReserved_1 = 0; // reserved field\n\t\tthis._entityBodyReserved_1 = 0; // reserved field\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget signerPublicKey() {\n\t\treturn this._signerPublicKey;\n\t}\n\n\tset signerPublicKey(value) {\n\t\tthis._signerPublicKey = value;\n\t}\n\n\tget version() {\n\t\treturn this._version;\n\t}\n\n\tset version(value) {\n\t\tthis._version = value;\n\t}\n\n\tget network() {\n\t\treturn this._network;\n\t}\n\n\tset network(value) {\n\t\tthis._network = value;\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tset type(value) {\n\t\tthis._type = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += 4;\n\t\tsize += 4;\n\t\tsize += this.signerPublicKey.size;\n\t\tsize += 4;\n\t\tsize += 1;\n\t\tsize += this.network.size;\n\t\tsize += this.type.size;\n\t\treturn size;\n\t}\n\n\tstatic _deserialize(view, instance) {\n\t\tconst size = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tview.shrink(size - 4);\n\t\tconst embeddedTransactionHeaderReserved_1 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== embeddedTransactionHeaderReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${embeddedTransactionHeaderReserved_1})`);\n\t\tconst signerPublicKey = PublicKey.deserialize(view.buffer);\n\t\tview.shiftRight(signerPublicKey.size);\n\t\tconst entityBodyReserved_1 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== entityBodyReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${entityBodyReserved_1})`);\n\t\tconst version = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst network = NetworkType.deserializeAligned(view.buffer);\n\t\tview.shiftRight(network.size);\n\t\tconst type = TransactionType.deserializeAligned(view.buffer);\n\t\tview.shiftRight(type.size);\n\n\t\tinstance._signerPublicKey = signerPublicKey;\n\t\tinstance._version = version;\n\t\tinstance._network = network;\n\t\tinstance._type = type;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tthis._serialize(buffer);\n\t\treturn buffer.storage;\n\t}\n\n\t_serialize(buffer) {\n\t\tbuffer.write(converter.intToBytes(this.size, 4, false));\n\t\tbuffer.write(converter.intToBytes(this._embeddedTransactionHeaderReserved_1, 4, false));\n\t\tbuffer.write(this._signerPublicKey.serialize());\n\t\tbuffer.write(converter.intToBytes(this._entityBodyReserved_1, 4, false));\n\t\tbuffer.write(converter.intToBytes(this._version, 1, false));\n\t\tbuffer.write(this._network.serialize());\n\t\tbuffer.write(this._type.serialize());\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += `signerPublicKey: ${this._signerPublicKey.toString()}, `;\n\t\tresult += `version: ${'0x'.concat(this._version.toString(16))}, `;\n\t\tresult += `network: ${this._network.toString()}, `;\n\t\tresult += `type: ${this._type.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tresult.signerPublicKey = this._signerPublicKey.toJson();\n\t\tresult.version = this._version;\n\t\tresult.network = this._network.toJson();\n\t\tresult.type = this._type.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class ProofGamma extends ByteArray {\n\tstatic SIZE = 32;\n\n\tconstructor(proofGamma = new Uint8Array(32)) {\n\t\tsuper(ProofGamma.SIZE, proofGamma);\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 32;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new ProofGamma(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 32));\n\t}\n\n\tserialize() {\n\t\treturn this.bytes;\n\t}\n}\n\nexport class ProofVerificationHash extends ByteArray {\n\tstatic SIZE = 16;\n\n\tconstructor(proofVerificationHash = new Uint8Array(16)) {\n\t\tsuper(ProofVerificationHash.SIZE, proofVerificationHash);\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 16;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new ProofVerificationHash(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 16));\n\t}\n\n\tserialize() {\n\t\treturn this.bytes;\n\t}\n}\n\nexport class ProofScalar extends ByteArray {\n\tstatic SIZE = 32;\n\n\tconstructor(proofScalar = new Uint8Array(32)) {\n\t\tsuper(ProofScalar.SIZE, proofScalar);\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 32;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new ProofScalar(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 32));\n\t}\n\n\tserialize() {\n\t\treturn this.bytes;\n\t}\n}\n\nexport class BlockType {\n\tstatic NEMESIS = new BlockType(32835);\n\n\tstatic NORMAL = new BlockType(33091);\n\n\tstatic IMPORTANCE = new BlockType(33347);\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n\n\tstatic valueToKey(value) {\n\t\tconst values = [\n\t\t\t32835, 33091, 33347\n\t\t];\n\t\tconst keys = [\n\t\t\t'NEMESIS', 'NORMAL', 'IMPORTANCE'\n\t\t];\n\n\t\tconst index = values.indexOf(value);\n\t\tif (-1 === index)\n\t\t\tthrow RangeError(`invalid enum value ${value}`);\n\n\t\treturn keys[index];\n\t}\n\n\tstatic fromValue(value) {\n\t\treturn BlockType[this.valueToKey(value)];\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 2;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToIntUnaligned(byteArray, 2, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToInt(byteArray, 2, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 2, false);\n\t}\n\n\ttoString() {\n\t\treturn `BlockType.${BlockType.valueToKey(this.value)}`;\n\t}\n\n\ttoJson() {\n\t\treturn this.value;\n\t}\n}\n\nexport class VrfProof {\n\tstatic TYPE_HINTS = {\n\t\tgamma: 'pod:ProofGamma',\n\t\tverificationHash: 'pod:ProofVerificationHash',\n\t\tscalar: 'pod:ProofScalar'\n\t};\n\n\tconstructor() {\n\t\tthis._gamma = new ProofGamma();\n\t\tthis._verificationHash = new ProofVerificationHash();\n\t\tthis._scalar = new ProofScalar();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget gamma() {\n\t\treturn this._gamma;\n\t}\n\n\tset gamma(value) {\n\t\tthis._gamma = value;\n\t}\n\n\tget verificationHash() {\n\t\treturn this._verificationHash;\n\t}\n\n\tset verificationHash(value) {\n\t\tthis._verificationHash = value;\n\t}\n\n\tget scalar() {\n\t\treturn this._scalar;\n\t}\n\n\tset scalar(value) {\n\t\tthis._scalar = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += this.gamma.size;\n\t\tsize += this.verificationHash.size;\n\t\tsize += this.scalar.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new VrfProof();\n\n\t\tconst gamma = ProofGamma.deserialize(view.buffer);\n\t\tview.shiftRight(gamma.size);\n\t\tconst verificationHash = ProofVerificationHash.deserialize(view.buffer);\n\t\tview.shiftRight(verificationHash.size);\n\t\tconst scalar = ProofScalar.deserialize(view.buffer);\n\t\tview.shiftRight(scalar.size);\n\n\t\tinstance._gamma = gamma;\n\t\tinstance._verificationHash = verificationHash;\n\t\tinstance._scalar = scalar;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tbuffer.write(this._gamma.serialize());\n\t\tbuffer.write(this._verificationHash.serialize());\n\t\tbuffer.write(this._scalar.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += `gamma: ${this._gamma.toString()}, `;\n\t\tresult += `verificationHash: ${this._verificationHash.toString()}, `;\n\t\tresult += `scalar: ${this._scalar.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tresult.gamma = this._gamma.toJson();\n\t\tresult.verificationHash = this._verificationHash.toJson();\n\t\tresult.scalar = this._scalar.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class Block {\n\tstatic TYPE_HINTS = {\n\t\tsignature: 'pod:Signature',\n\t\tsignerPublicKey: 'pod:PublicKey',\n\t\tnetwork: 'enum:NetworkType',\n\t\ttype: 'enum:BlockType',\n\t\theight: 'pod:Height',\n\t\ttimestamp: 'pod:Timestamp',\n\t\tdifficulty: 'pod:Difficulty',\n\t\tgenerationHashProof: 'struct:VrfProof',\n\t\tpreviousBlockHash: 'pod:Hash256',\n\t\ttransactionsHash: 'pod:Hash256',\n\t\treceiptsHash: 'pod:Hash256',\n\t\tstateHash: 'pod:Hash256',\n\t\tbeneficiaryAddress: 'pod:Address',\n\t\tfeeMultiplier: 'pod:BlockFeeMultiplier'\n\t};\n\n\tconstructor() {\n\t\tthis._signature = new Signature();\n\t\tthis._signerPublicKey = new PublicKey();\n\t\tthis._version = 0;\n\t\tthis._network = NetworkType.MAINNET;\n\t\tthis._type = BlockType.NEMESIS;\n\t\tthis._height = new Height();\n\t\tthis._timestamp = new Timestamp();\n\t\tthis._difficulty = new Difficulty();\n\t\tthis._generationHashProof = new VrfProof();\n\t\tthis._previousBlockHash = new Hash256();\n\t\tthis._transactionsHash = new Hash256();\n\t\tthis._receiptsHash = new Hash256();\n\t\tthis._stateHash = new Hash256();\n\t\tthis._beneficiaryAddress = new Address();\n\t\tthis._feeMultiplier = new BlockFeeMultiplier();\n\t\tthis._verifiableEntityHeaderReserved_1 = 0; // reserved field\n\t\tthis._entityBodyReserved_1 = 0; // reserved field\n\t}\n\n\tsort() {\n\t\tthis._generationHashProof.sort();\n\t}\n\n\tget signature() {\n\t\treturn this._signature;\n\t}\n\n\tset signature(value) {\n\t\tthis._signature = value;\n\t}\n\n\tget signerPublicKey() {\n\t\treturn this._signerPublicKey;\n\t}\n\n\tset signerPublicKey(value) {\n\t\tthis._signerPublicKey = value;\n\t}\n\n\tget version() {\n\t\treturn this._version;\n\t}\n\n\tset version(value) {\n\t\tthis._version = value;\n\t}\n\n\tget network() {\n\t\treturn this._network;\n\t}\n\n\tset network(value) {\n\t\tthis._network = value;\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tset type(value) {\n\t\tthis._type = value;\n\t}\n\n\tget height() {\n\t\treturn this._height;\n\t}\n\n\tset height(value) {\n\t\tthis._height = value;\n\t}\n\n\tget timestamp() {\n\t\treturn this._timestamp;\n\t}\n\n\tset timestamp(value) {\n\t\tthis._timestamp = value;\n\t}\n\n\tget difficulty() {\n\t\treturn this._difficulty;\n\t}\n\n\tset difficulty(value) {\n\t\tthis._difficulty = value;\n\t}\n\n\tget generationHashProof() {\n\t\treturn this._generationHashProof;\n\t}\n\n\tset generationHashProof(value) {\n\t\tthis._generationHashProof = value;\n\t}\n\n\tget previousBlockHash() {\n\t\treturn this._previousBlockHash;\n\t}\n\n\tset previousBlockHash(value) {\n\t\tthis._previousBlockHash = value;\n\t}\n\n\tget transactionsHash() {\n\t\treturn this._transactionsHash;\n\t}\n\n\tset transactionsHash(value) {\n\t\tthis._transactionsHash = value;\n\t}\n\n\tget receiptsHash() {\n\t\treturn this._receiptsHash;\n\t}\n\n\tset receiptsHash(value) {\n\t\tthis._receiptsHash = value;\n\t}\n\n\tget stateHash() {\n\t\treturn this._stateHash;\n\t}\n\n\tset stateHash(value) {\n\t\tthis._stateHash = value;\n\t}\n\n\tget beneficiaryAddress() {\n\t\treturn this._beneficiaryAddress;\n\t}\n\n\tset beneficiaryAddress(value) {\n\t\tthis._beneficiaryAddress = value;\n\t}\n\n\tget feeMultiplier() {\n\t\treturn this._feeMultiplier;\n\t}\n\n\tset feeMultiplier(value) {\n\t\tthis._feeMultiplier = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += 4;\n\t\tsize += 4;\n\t\tsize += this.signature.size;\n\t\tsize += this.signerPublicKey.size;\n\t\tsize += 4;\n\t\tsize += 1;\n\t\tsize += this.network.size;\n\t\tsize += this.type.size;\n\t\tsize += this.height.size;\n\t\tsize += this.timestamp.size;\n\t\tsize += this.difficulty.size;\n\t\tsize += this.generationHashProof.size;\n\t\tsize += this.previousBlockHash.size;\n\t\tsize += this.transactionsHash.size;\n\t\tsize += this.receiptsHash.size;\n\t\tsize += this.stateHash.size;\n\t\tsize += this.beneficiaryAddress.size;\n\t\tsize += this.feeMultiplier.size;\n\t\treturn size;\n\t}\n\n\tstatic _deserialize(view, instance) {\n\t\tconst size = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tview.shrink(size - 4);\n\t\tconst verifiableEntityHeaderReserved_1 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== verifiableEntityHeaderReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${verifiableEntityHeaderReserved_1})`);\n\t\tconst signature = Signature.deserialize(view.buffer);\n\t\tview.shiftRight(signature.size);\n\t\tconst signerPublicKey = PublicKey.deserialize(view.buffer);\n\t\tview.shiftRight(signerPublicKey.size);\n\t\tconst entityBodyReserved_1 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== entityBodyReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${entityBodyReserved_1})`);\n\t\tconst version = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst network = NetworkType.deserializeAligned(view.buffer);\n\t\tview.shiftRight(network.size);\n\t\tconst type = BlockType.deserializeAligned(view.buffer);\n\t\tview.shiftRight(type.size);\n\t\tconst height = Height.deserializeAligned(view.buffer);\n\t\tview.shiftRight(height.size);\n\t\tconst timestamp = Timestamp.deserializeAligned(view.buffer);\n\t\tview.shiftRight(timestamp.size);\n\t\tconst difficulty = Difficulty.deserializeAligned(view.buffer);\n\t\tview.shiftRight(difficulty.size);\n\t\tconst generationHashProof = VrfProof.deserialize(view.buffer);\n\t\tview.shiftRight(generationHashProof.size);\n\t\tconst previousBlockHash = Hash256.deserialize(view.buffer);\n\t\tview.shiftRight(previousBlockHash.size);\n\t\tconst transactionsHash = Hash256.deserialize(view.buffer);\n\t\tview.shiftRight(transactionsHash.size);\n\t\tconst receiptsHash = Hash256.deserialize(view.buffer);\n\t\tview.shiftRight(receiptsHash.size);\n\t\tconst stateHash = Hash256.deserialize(view.buffer);\n\t\tview.shiftRight(stateHash.size);\n\t\tconst beneficiaryAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(beneficiaryAddress.size);\n\t\tconst feeMultiplier = BlockFeeMultiplier.deserializeAligned(view.buffer);\n\t\tview.shiftRight(feeMultiplier.size);\n\n\t\tinstance._signature = signature;\n\t\tinstance._signerPublicKey = signerPublicKey;\n\t\tinstance._version = version;\n\t\tinstance._network = network;\n\t\tinstance._type = type;\n\t\tinstance._height = height;\n\t\tinstance._timestamp = timestamp;\n\t\tinstance._difficulty = difficulty;\n\t\tinstance._generationHashProof = generationHashProof;\n\t\tinstance._previousBlockHash = previousBlockHash;\n\t\tinstance._transactionsHash = transactionsHash;\n\t\tinstance._receiptsHash = receiptsHash;\n\t\tinstance._stateHash = stateHash;\n\t\tinstance._beneficiaryAddress = beneficiaryAddress;\n\t\tinstance._feeMultiplier = feeMultiplier;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tthis._serialize(buffer);\n\t\treturn buffer.storage;\n\t}\n\n\t_serialize(buffer) {\n\t\tbuffer.write(converter.intToBytes(this.size, 4, false));\n\t\tbuffer.write(converter.intToBytes(this._verifiableEntityHeaderReserved_1, 4, false));\n\t\tbuffer.write(this._signature.serialize());\n\t\tbuffer.write(this._signerPublicKey.serialize());\n\t\tbuffer.write(converter.intToBytes(this._entityBodyReserved_1, 4, false));\n\t\tbuffer.write(converter.intToBytes(this._version, 1, false));\n\t\tbuffer.write(this._network.serialize());\n\t\tbuffer.write(this._type.serialize());\n\t\tbuffer.write(this._height.serialize());\n\t\tbuffer.write(this._timestamp.serialize());\n\t\tbuffer.write(this._difficulty.serialize());\n\t\tbuffer.write(this._generationHashProof.serialize());\n\t\tbuffer.write(this._previousBlockHash.serialize());\n\t\tbuffer.write(this._transactionsHash.serialize());\n\t\tbuffer.write(this._receiptsHash.serialize());\n\t\tbuffer.write(this._stateHash.serialize());\n\t\tbuffer.write(this._beneficiaryAddress.serialize());\n\t\tbuffer.write(this._feeMultiplier.serialize());\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += `signature: ${this._signature.toString()}, `;\n\t\tresult += `signerPublicKey: ${this._signerPublicKey.toString()}, `;\n\t\tresult += `version: ${'0x'.concat(this._version.toString(16))}, `;\n\t\tresult += `network: ${this._network.toString()}, `;\n\t\tresult += `type: ${this._type.toString()}, `;\n\t\tresult += `height: ${this._height.toString()}, `;\n\t\tresult += `timestamp: ${this._timestamp.toString()}, `;\n\t\tresult += `difficulty: ${this._difficulty.toString()}, `;\n\t\tresult += `generationHashProof: ${this._generationHashProof.toString()}, `;\n\t\tresult += `previousBlockHash: ${this._previousBlockHash.toString()}, `;\n\t\tresult += `transactionsHash: ${this._transactionsHash.toString()}, `;\n\t\tresult += `receiptsHash: ${this._receiptsHash.toString()}, `;\n\t\tresult += `stateHash: ${this._stateHash.toString()}, `;\n\t\tresult += `beneficiaryAddress: ${this._beneficiaryAddress.toString()}, `;\n\t\tresult += `feeMultiplier: ${this._feeMultiplier.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tresult.signature = this._signature.toJson();\n\t\tresult.signerPublicKey = this._signerPublicKey.toJson();\n\t\tresult.version = this._version;\n\t\tresult.network = this._network.toJson();\n\t\tresult.type = this._type.toJson();\n\t\tresult.height = this._height.toJson();\n\t\tresult.timestamp = this._timestamp.toJson();\n\t\tresult.difficulty = this._difficulty.toJson();\n\t\tresult.generationHashProof = this._generationHashProof.toJson();\n\t\tresult.previousBlockHash = this._previousBlockHash.toJson();\n\t\tresult.transactionsHash = this._transactionsHash.toJson();\n\t\tresult.receiptsHash = this._receiptsHash.toJson();\n\t\tresult.stateHash = this._stateHash.toJson();\n\t\tresult.beneficiaryAddress = this._beneficiaryAddress.toJson();\n\t\tresult.feeMultiplier = this._feeMultiplier.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class NemesisBlockV1 extends Block {\n\tstatic BLOCK_VERSION = 1;\n\n\tstatic BLOCK_TYPE = BlockType.NEMESIS;\n\n\tstatic TYPE_HINTS = {\n\t\t...Block.TYPE_HINTS,\n\t\ttotalVotingBalance: 'pod:Amount',\n\t\tpreviousImportanceBlockHash: 'pod:Hash256',\n\t\ttransactions: 'array[Transaction]'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = NemesisBlockV1.BLOCK_VERSION;\n\t\tthis._type = NemesisBlockV1.BLOCK_TYPE;\n\t\tthis._votingEligibleAccountsCount = 0;\n\t\tthis._harvestingEligibleAccountsCount = 0n;\n\t\tthis._totalVotingBalance = new Amount();\n\t\tthis._previousImportanceBlockHash = new Hash256();\n\t\tthis._transactions = [];\n\t}\n\n\tsort() {\n\t\tthis._generationHashProof.sort();\n\t}\n\n\tget votingEligibleAccountsCount() {\n\t\treturn this._votingEligibleAccountsCount;\n\t}\n\n\tset votingEligibleAccountsCount(value) {\n\t\tthis._votingEligibleAccountsCount = value;\n\t}\n\n\tget harvestingEligibleAccountsCount() {\n\t\treturn this._harvestingEligibleAccountsCount;\n\t}\n\n\tset harvestingEligibleAccountsCount(value) {\n\t\tthis._harvestingEligibleAccountsCount = value;\n\t}\n\n\tget totalVotingBalance() {\n\t\treturn this._totalVotingBalance;\n\t}\n\n\tset totalVotingBalance(value) {\n\t\tthis._totalVotingBalance = value;\n\t}\n\n\tget previousImportanceBlockHash() {\n\t\treturn this._previousImportanceBlockHash;\n\t}\n\n\tset previousImportanceBlockHash(value) {\n\t\tthis._previousImportanceBlockHash = value;\n\t}\n\n\tget transactions() {\n\t\treturn this._transactions;\n\t}\n\n\tset transactions(value) {\n\t\tthis._transactions = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += 4;\n\t\tsize += 8;\n\t\tsize += this.totalVotingBalance.size;\n\t\tsize += this.previousImportanceBlockHash.size;\n\t\tsize += arrayHelpers.size(this.transactions, 8, true);\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new NemesisBlockV1();\n\n\t\tBlock._deserialize(view, instance);\n\t\tconst votingEligibleAccountsCount = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tconst harvestingEligibleAccountsCount = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst totalVotingBalance = Amount.deserializeAligned(view.buffer);\n\t\tview.shiftRight(totalVotingBalance.size);\n\t\tconst previousImportanceBlockHash = Hash256.deserialize(view.buffer);\n\t\tview.shiftRight(previousImportanceBlockHash.size);\n\t\tconst transactions = arrayHelpers.readVariableSizeElements(view.buffer, TransactionFactory, 8, true);\n\t\tview.shiftRight(arrayHelpers.size(transactions, 8, true));\n\n\t\tinstance._votingEligibleAccountsCount = votingEligibleAccountsCount;\n\t\tinstance._harvestingEligibleAccountsCount = harvestingEligibleAccountsCount;\n\t\tinstance._totalVotingBalance = totalVotingBalance;\n\t\tinstance._previousImportanceBlockHash = previousImportanceBlockHash;\n\t\tinstance._transactions = transactions;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(converter.intToBytes(this._votingEligibleAccountsCount, 4, false));\n\t\tbuffer.write(converter.intToBytes(this._harvestingEligibleAccountsCount, 8, false));\n\t\tbuffer.write(this._totalVotingBalance.serialize());\n\t\tbuffer.write(this._previousImportanceBlockHash.serialize());\n\t\tarrayHelpers.writeVariableSizeElements(buffer, this._transactions, 8, true);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `votingEligibleAccountsCount: ${'0x'.concat(this._votingEligibleAccountsCount.toString(16))}, `;\n\t\tresult += `harvestingEligibleAccountsCount: ${'0x'.concat(this._harvestingEligibleAccountsCount.toString(16))}, `;\n\t\tresult += `totalVotingBalance: ${this._totalVotingBalance.toString()}, `;\n\t\tresult += `previousImportanceBlockHash: ${this._previousImportanceBlockHash.toString()}, `;\n\t\tresult += `transactions: [${this._transactions.map(e => e.toString()).join(',')}], `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.votingEligibleAccountsCount = this._votingEligibleAccountsCount;\n\t\tresult.harvestingEligibleAccountsCount = this._harvestingEligibleAccountsCount.toString();\n\t\tresult.totalVotingBalance = this._totalVotingBalance.toJson();\n\t\tresult.previousImportanceBlockHash = this._previousImportanceBlockHash.toJson();\n\t\tresult.transactions = this._transactions.map(e => e.toJson());\n\t\treturn result;\n\t}\n}\n\nexport class NormalBlockV1 extends Block {\n\tstatic BLOCK_VERSION = 1;\n\n\tstatic BLOCK_TYPE = BlockType.NORMAL;\n\n\tstatic TYPE_HINTS = {\n\t\t...Block.TYPE_HINTS,\n\t\ttransactions: 'array[Transaction]'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = NormalBlockV1.BLOCK_VERSION;\n\t\tthis._type = NormalBlockV1.BLOCK_TYPE;\n\t\tthis._transactions = [];\n\t\tthis._blockHeaderReserved_1 = 0; // reserved field\n\t}\n\n\tsort() {\n\t\tthis._generationHashProof.sort();\n\t}\n\n\tget transactions() {\n\t\treturn this._transactions;\n\t}\n\n\tset transactions(value) {\n\t\tthis._transactions = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.transactions, 8, true);\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new NormalBlockV1();\n\n\t\tBlock._deserialize(view, instance);\n\t\tconst blockHeaderReserved_1 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== blockHeaderReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${blockHeaderReserved_1})`);\n\t\tconst transactions = arrayHelpers.readVariableSizeElements(view.buffer, TransactionFactory, 8, true);\n\t\tview.shiftRight(arrayHelpers.size(transactions, 8, true));\n\n\t\tinstance._transactions = transactions;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(converter.intToBytes(this._blockHeaderReserved_1, 4, false));\n\t\tarrayHelpers.writeVariableSizeElements(buffer, this._transactions, 8, true);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `transactions: [${this._transactions.map(e => e.toString()).join(',')}], `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.transactions = this._transactions.map(e => e.toJson());\n\t\treturn result;\n\t}\n}\n\nexport class ImportanceBlockV1 extends Block {\n\tstatic BLOCK_VERSION = 1;\n\n\tstatic BLOCK_TYPE = BlockType.IMPORTANCE;\n\n\tstatic TYPE_HINTS = {\n\t\t...Block.TYPE_HINTS,\n\t\ttotalVotingBalance: 'pod:Amount',\n\t\tpreviousImportanceBlockHash: 'pod:Hash256',\n\t\ttransactions: 'array[Transaction]'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = ImportanceBlockV1.BLOCK_VERSION;\n\t\tthis._type = ImportanceBlockV1.BLOCK_TYPE;\n\t\tthis._votingEligibleAccountsCount = 0;\n\t\tthis._harvestingEligibleAccountsCount = 0n;\n\t\tthis._totalVotingBalance = new Amount();\n\t\tthis._previousImportanceBlockHash = new Hash256();\n\t\tthis._transactions = [];\n\t}\n\n\tsort() {\n\t\tthis._generationHashProof.sort();\n\t}\n\n\tget votingEligibleAccountsCount() {\n\t\treturn this._votingEligibleAccountsCount;\n\t}\n\n\tset votingEligibleAccountsCount(value) {\n\t\tthis._votingEligibleAccountsCount = value;\n\t}\n\n\tget harvestingEligibleAccountsCount() {\n\t\treturn this._harvestingEligibleAccountsCount;\n\t}\n\n\tset harvestingEligibleAccountsCount(value) {\n\t\tthis._harvestingEligibleAccountsCount = value;\n\t}\n\n\tget totalVotingBalance() {\n\t\treturn this._totalVotingBalance;\n\t}\n\n\tset totalVotingBalance(value) {\n\t\tthis._totalVotingBalance = value;\n\t}\n\n\tget previousImportanceBlockHash() {\n\t\treturn this._previousImportanceBlockHash;\n\t}\n\n\tset previousImportanceBlockHash(value) {\n\t\tthis._previousImportanceBlockHash = value;\n\t}\n\n\tget transactions() {\n\t\treturn this._transactions;\n\t}\n\n\tset transactions(value) {\n\t\tthis._transactions = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += 4;\n\t\tsize += 8;\n\t\tsize += this.totalVotingBalance.size;\n\t\tsize += this.previousImportanceBlockHash.size;\n\t\tsize += arrayHelpers.size(this.transactions, 8, true);\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new ImportanceBlockV1();\n\n\t\tBlock._deserialize(view, instance);\n\t\tconst votingEligibleAccountsCount = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tconst harvestingEligibleAccountsCount = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst totalVotingBalance = Amount.deserializeAligned(view.buffer);\n\t\tview.shiftRight(totalVotingBalance.size);\n\t\tconst previousImportanceBlockHash = Hash256.deserialize(view.buffer);\n\t\tview.shiftRight(previousImportanceBlockHash.size);\n\t\tconst transactions = arrayHelpers.readVariableSizeElements(view.buffer, TransactionFactory, 8, true);\n\t\tview.shiftRight(arrayHelpers.size(transactions, 8, true));\n\n\t\tinstance._votingEligibleAccountsCount = votingEligibleAccountsCount;\n\t\tinstance._harvestingEligibleAccountsCount = harvestingEligibleAccountsCount;\n\t\tinstance._totalVotingBalance = totalVotingBalance;\n\t\tinstance._previousImportanceBlockHash = previousImportanceBlockHash;\n\t\tinstance._transactions = transactions;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(converter.intToBytes(this._votingEligibleAccountsCount, 4, false));\n\t\tbuffer.write(converter.intToBytes(this._harvestingEligibleAccountsCount, 8, false));\n\t\tbuffer.write(this._totalVotingBalance.serialize());\n\t\tbuffer.write(this._previousImportanceBlockHash.serialize());\n\t\tarrayHelpers.writeVariableSizeElements(buffer, this._transactions, 8, true);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `votingEligibleAccountsCount: ${'0x'.concat(this._votingEligibleAccountsCount.toString(16))}, `;\n\t\tresult += `harvestingEligibleAccountsCount: ${'0x'.concat(this._harvestingEligibleAccountsCount.toString(16))}, `;\n\t\tresult += `totalVotingBalance: ${this._totalVotingBalance.toString()}, `;\n\t\tresult += `previousImportanceBlockHash: ${this._previousImportanceBlockHash.toString()}, `;\n\t\tresult += `transactions: [${this._transactions.map(e => e.toString()).join(',')}], `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.votingEligibleAccountsCount = this._votingEligibleAccountsCount;\n\t\tresult.harvestingEligibleAccountsCount = this._harvestingEligibleAccountsCount.toString();\n\t\tresult.totalVotingBalance = this._totalVotingBalance.toJson();\n\t\tresult.previousImportanceBlockHash = this._previousImportanceBlockHash.toJson();\n\t\tresult.transactions = this._transactions.map(e => e.toJson());\n\t\treturn result;\n\t}\n}\n\nexport class FinalizationRound {\n\tstatic TYPE_HINTS = {\n\t\tepoch: 'pod:FinalizationEpoch',\n\t\tpoint: 'pod:FinalizationPoint'\n\t};\n\n\tconstructor() {\n\t\tthis._epoch = new FinalizationEpoch();\n\t\tthis._point = new FinalizationPoint();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget epoch() {\n\t\treturn this._epoch;\n\t}\n\n\tset epoch(value) {\n\t\tthis._epoch = value;\n\t}\n\n\tget point() {\n\t\treturn this._point;\n\t}\n\n\tset point(value) {\n\t\tthis._point = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += this.epoch.size;\n\t\tsize += this.point.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new FinalizationRound();\n\n\t\tconst epoch = FinalizationEpoch.deserialize(view.buffer);\n\t\tview.shiftRight(epoch.size);\n\t\tconst point = FinalizationPoint.deserialize(view.buffer);\n\t\tview.shiftRight(point.size);\n\n\t\tinstance._epoch = epoch;\n\t\tinstance._point = point;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tbuffer.write(this._epoch.serialize());\n\t\tbuffer.write(this._point.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += `epoch: ${this._epoch.toString()}, `;\n\t\tresult += `point: ${this._point.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tresult.epoch = this._epoch.toJson();\n\t\tresult.point = this._point.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class FinalizedBlockHeader {\n\tstatic TYPE_HINTS = {\n\t\tround: 'struct:FinalizationRound',\n\t\theight: 'pod:Height',\n\t\thash: 'pod:Hash256'\n\t};\n\n\tconstructor() {\n\t\tthis._round = new FinalizationRound();\n\t\tthis._height = new Height();\n\t\tthis._hash = new Hash256();\n\t}\n\n\tsort() {\n\t\tthis._round.sort();\n\t}\n\n\tget round() {\n\t\treturn this._round;\n\t}\n\n\tset round(value) {\n\t\tthis._round = value;\n\t}\n\n\tget height() {\n\t\treturn this._height;\n\t}\n\n\tset height(value) {\n\t\tthis._height = value;\n\t}\n\n\tget hash() {\n\t\treturn this._hash;\n\t}\n\n\tset hash(value) {\n\t\tthis._hash = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += this.round.size;\n\t\tsize += this.height.size;\n\t\tsize += this.hash.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new FinalizedBlockHeader();\n\n\t\tconst round = FinalizationRound.deserialize(view.buffer);\n\t\tview.shiftRight(round.size);\n\t\tconst height = Height.deserialize(view.buffer);\n\t\tview.shiftRight(height.size);\n\t\tconst hash = Hash256.deserialize(view.buffer);\n\t\tview.shiftRight(hash.size);\n\n\t\tinstance._round = round;\n\t\tinstance._height = height;\n\t\tinstance._hash = hash;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tbuffer.write(this._round.serialize());\n\t\tbuffer.write(this._height.serialize());\n\t\tbuffer.write(this._hash.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += `round: ${this._round.toString()}, `;\n\t\tresult += `height: ${this._height.toString()}, `;\n\t\tresult += `hash: ${this._hash.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tresult.round = this._round.toJson();\n\t\tresult.height = this._height.toJson();\n\t\tresult.hash = this._hash.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class ReceiptType {\n\tstatic MOSAIC_RENTAL_FEE = new ReceiptType(4685);\n\n\tstatic NAMESPACE_RENTAL_FEE = new ReceiptType(4942);\n\n\tstatic HARVEST_FEE = new ReceiptType(8515);\n\n\tstatic LOCK_HASH_COMPLETED = new ReceiptType(8776);\n\n\tstatic LOCK_HASH_EXPIRED = new ReceiptType(9032);\n\n\tstatic LOCK_SECRET_COMPLETED = new ReceiptType(8786);\n\n\tstatic LOCK_SECRET_EXPIRED = new ReceiptType(9042);\n\n\tstatic LOCK_HASH_CREATED = new ReceiptType(12616);\n\n\tstatic LOCK_SECRET_CREATED = new ReceiptType(12626);\n\n\tstatic MOSAIC_EXPIRED = new ReceiptType(16717);\n\n\tstatic NAMESPACE_EXPIRED = new ReceiptType(16718);\n\n\tstatic NAMESPACE_DELETED = new ReceiptType(16974);\n\n\tstatic INFLATION = new ReceiptType(20803);\n\n\tstatic TRANSACTION_GROUP = new ReceiptType(57667);\n\n\tstatic ADDRESS_ALIAS_RESOLUTION = new ReceiptType(61763);\n\n\tstatic MOSAIC_ALIAS_RESOLUTION = new ReceiptType(62019);\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n\n\tstatic valueToKey(value) {\n\t\tconst values = [\n\t\t\t4685, 4942, 8515, 8776, 9032, 8786, 9042, 12616, 12626, 16717, 16718, 16974, 20803, 57667, 61763, 62019\n\t\t];\n\t\tconst keys = [\n\t\t\t'MOSAIC_RENTAL_FEE', 'NAMESPACE_RENTAL_FEE', 'HARVEST_FEE', 'LOCK_HASH_COMPLETED', 'LOCK_HASH_EXPIRED', 'LOCK_SECRET_COMPLETED',\n\t\t\t'LOCK_SECRET_EXPIRED', 'LOCK_HASH_CREATED', 'LOCK_SECRET_CREATED', 'MOSAIC_EXPIRED', 'NAMESPACE_EXPIRED', 'NAMESPACE_DELETED',\n\t\t\t'INFLATION', 'TRANSACTION_GROUP', 'ADDRESS_ALIAS_RESOLUTION', 'MOSAIC_ALIAS_RESOLUTION'\n\t\t];\n\n\t\tconst index = values.indexOf(value);\n\t\tif (-1 === index)\n\t\t\tthrow RangeError(`invalid enum value ${value}`);\n\n\t\treturn keys[index];\n\t}\n\n\tstatic fromValue(value) {\n\t\treturn ReceiptType[this.valueToKey(value)];\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 2;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToIntUnaligned(byteArray, 2, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToInt(byteArray, 2, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 2, false);\n\t}\n\n\ttoString() {\n\t\treturn `ReceiptType.${ReceiptType.valueToKey(this.value)}`;\n\t}\n\n\ttoJson() {\n\t\treturn this.value;\n\t}\n}\n\nexport class Receipt {\n\tstatic TYPE_HINTS = {\n\t\ttype: 'enum:ReceiptType'\n\t};\n\n\tconstructor() {\n\t\tthis._version = 0;\n\t\tthis._type = ReceiptType.MOSAIC_RENTAL_FEE;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget version() {\n\t\treturn this._version;\n\t}\n\n\tset version(value) {\n\t\tthis._version = value;\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tset type(value) {\n\t\tthis._type = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += 4;\n\t\tsize += 2;\n\t\tsize += this.type.size;\n\t\treturn size;\n\t}\n\n\tstatic _deserialize(view, instance) {\n\t\tconst size = converter.bytesToIntUnaligned(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tview.shrink(size - 4);\n\t\tconst version = converter.bytesToIntUnaligned(view.buffer, 2, false);\n\t\tview.shiftRight(2);\n\t\tconst type = ReceiptType.deserialize(view.buffer);\n\t\tview.shiftRight(type.size);\n\n\t\tinstance._version = version;\n\t\tinstance._type = type;\n\t}\n\n\tstatic _deserializeAligned(view, instance) {\n\t\tconst size = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tview.shrink(size - 4);\n\t\tconst version = converter.bytesToInt(view.buffer, 2, false);\n\t\tview.shiftRight(2);\n\t\tconst type = ReceiptType.deserializeAligned(view.buffer);\n\t\tview.shiftRight(type.size);\n\n\t\tinstance._version = version;\n\t\tinstance._type = type;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tthis._serialize(buffer);\n\t\treturn buffer.storage;\n\t}\n\n\t_serialize(buffer) {\n\t\tbuffer.write(converter.intToBytes(this.size, 4, false));\n\t\tbuffer.write(converter.intToBytes(this._version, 2, false));\n\t\tbuffer.write(this._type.serialize());\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += `version: ${'0x'.concat(this._version.toString(16))}, `;\n\t\tresult += `type: ${this._type.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tresult.version = this._version;\n\t\tresult.type = this._type.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class HarvestFeeReceipt extends Receipt {\n\tstatic RECEIPT_TYPE = ReceiptType.HARVEST_FEE;\n\n\tstatic TYPE_HINTS = {\n\t\t...Receipt.TYPE_HINTS,\n\t\tmosaic: 'struct:Mosaic',\n\t\ttargetAddress: 'pod:Address'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._type = HarvestFeeReceipt.RECEIPT_TYPE;\n\t\tthis._mosaic = new Mosaic();\n\t\tthis._targetAddress = new Address();\n\t}\n\n\tsort() {\n\t\tthis._mosaic.sort();\n\t}\n\n\tget mosaic() {\n\t\treturn this._mosaic;\n\t}\n\n\tset mosaic(value) {\n\t\tthis._mosaic = value;\n\t}\n\n\tget targetAddress() {\n\t\treturn this._targetAddress;\n\t}\n\n\tset targetAddress(value) {\n\t\tthis._targetAddress = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.mosaic.size;\n\t\tsize += this.targetAddress.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new HarvestFeeReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst targetAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._targetAddress = targetAddress;\n\t\treturn instance;\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new HarvestFeeReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst targetAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._targetAddress = targetAddress;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._mosaic.serialize());\n\t\tbuffer.write(this._targetAddress.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `mosaic: ${this._mosaic.toString()}, `;\n\t\tresult += `targetAddress: ${this._targetAddress.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.mosaic = this._mosaic.toJson();\n\t\tresult.targetAddress = this._targetAddress.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class InflationReceipt extends Receipt {\n\tstatic RECEIPT_TYPE = ReceiptType.INFLATION;\n\n\tstatic TYPE_HINTS = {\n\t\t...Receipt.TYPE_HINTS,\n\t\tmosaic: 'struct:Mosaic'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._type = InflationReceipt.RECEIPT_TYPE;\n\t\tthis._mosaic = new Mosaic();\n\t}\n\n\tsort() {\n\t\tthis._mosaic.sort();\n\t}\n\n\tget mosaic() {\n\t\treturn this._mosaic;\n\t}\n\n\tset mosaic(value) {\n\t\tthis._mosaic = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.mosaic.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new InflationReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\treturn instance;\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new InflationReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._mosaic.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `mosaic: ${this._mosaic.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.mosaic = this._mosaic.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class LockHashCreatedFeeReceipt extends Receipt {\n\tstatic RECEIPT_TYPE = ReceiptType.LOCK_HASH_CREATED;\n\n\tstatic TYPE_HINTS = {\n\t\t...Receipt.TYPE_HINTS,\n\t\tmosaic: 'struct:Mosaic',\n\t\ttargetAddress: 'pod:Address'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._type = LockHashCreatedFeeReceipt.RECEIPT_TYPE;\n\t\tthis._mosaic = new Mosaic();\n\t\tthis._targetAddress = new Address();\n\t}\n\n\tsort() {\n\t\tthis._mosaic.sort();\n\t}\n\n\tget mosaic() {\n\t\treturn this._mosaic;\n\t}\n\n\tset mosaic(value) {\n\t\tthis._mosaic = value;\n\t}\n\n\tget targetAddress() {\n\t\treturn this._targetAddress;\n\t}\n\n\tset targetAddress(value) {\n\t\tthis._targetAddress = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.mosaic.size;\n\t\tsize += this.targetAddress.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new LockHashCreatedFeeReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst targetAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._targetAddress = targetAddress;\n\t\treturn instance;\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new LockHashCreatedFeeReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst targetAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._targetAddress = targetAddress;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._mosaic.serialize());\n\t\tbuffer.write(this._targetAddress.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `mosaic: ${this._mosaic.toString()}, `;\n\t\tresult += `targetAddress: ${this._targetAddress.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.mosaic = this._mosaic.toJson();\n\t\tresult.targetAddress = this._targetAddress.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class LockHashCompletedFeeReceipt extends Receipt {\n\tstatic RECEIPT_TYPE = ReceiptType.LOCK_HASH_COMPLETED;\n\n\tstatic TYPE_HINTS = {\n\t\t...Receipt.TYPE_HINTS,\n\t\tmosaic: 'struct:Mosaic',\n\t\ttargetAddress: 'pod:Address'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._type = LockHashCompletedFeeReceipt.RECEIPT_TYPE;\n\t\tthis._mosaic = new Mosaic();\n\t\tthis._targetAddress = new Address();\n\t}\n\n\tsort() {\n\t\tthis._mosaic.sort();\n\t}\n\n\tget mosaic() {\n\t\treturn this._mosaic;\n\t}\n\n\tset mosaic(value) {\n\t\tthis._mosaic = value;\n\t}\n\n\tget targetAddress() {\n\t\treturn this._targetAddress;\n\t}\n\n\tset targetAddress(value) {\n\t\tthis._targetAddress = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.mosaic.size;\n\t\tsize += this.targetAddress.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new LockHashCompletedFeeReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst targetAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._targetAddress = targetAddress;\n\t\treturn instance;\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new LockHashCompletedFeeReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst targetAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._targetAddress = targetAddress;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._mosaic.serialize());\n\t\tbuffer.write(this._targetAddress.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `mosaic: ${this._mosaic.toString()}, `;\n\t\tresult += `targetAddress: ${this._targetAddress.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.mosaic = this._mosaic.toJson();\n\t\tresult.targetAddress = this._targetAddress.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class LockHashExpiredFeeReceipt extends Receipt {\n\tstatic RECEIPT_TYPE = ReceiptType.LOCK_HASH_EXPIRED;\n\n\tstatic TYPE_HINTS = {\n\t\t...Receipt.TYPE_HINTS,\n\t\tmosaic: 'struct:Mosaic',\n\t\ttargetAddress: 'pod:Address'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._type = LockHashExpiredFeeReceipt.RECEIPT_TYPE;\n\t\tthis._mosaic = new Mosaic();\n\t\tthis._targetAddress = new Address();\n\t}\n\n\tsort() {\n\t\tthis._mosaic.sort();\n\t}\n\n\tget mosaic() {\n\t\treturn this._mosaic;\n\t}\n\n\tset mosaic(value) {\n\t\tthis._mosaic = value;\n\t}\n\n\tget targetAddress() {\n\t\treturn this._targetAddress;\n\t}\n\n\tset targetAddress(value) {\n\t\tthis._targetAddress = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.mosaic.size;\n\t\tsize += this.targetAddress.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new LockHashExpiredFeeReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst targetAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._targetAddress = targetAddress;\n\t\treturn instance;\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new LockHashExpiredFeeReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst targetAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._targetAddress = targetAddress;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._mosaic.serialize());\n\t\tbuffer.write(this._targetAddress.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `mosaic: ${this._mosaic.toString()}, `;\n\t\tresult += `targetAddress: ${this._targetAddress.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.mosaic = this._mosaic.toJson();\n\t\tresult.targetAddress = this._targetAddress.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class LockSecretCreatedFeeReceipt extends Receipt {\n\tstatic RECEIPT_TYPE = ReceiptType.LOCK_SECRET_CREATED;\n\n\tstatic TYPE_HINTS = {\n\t\t...Receipt.TYPE_HINTS,\n\t\tmosaic: 'struct:Mosaic',\n\t\ttargetAddress: 'pod:Address'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._type = LockSecretCreatedFeeReceipt.RECEIPT_TYPE;\n\t\tthis._mosaic = new Mosaic();\n\t\tthis._targetAddress = new Address();\n\t}\n\n\tsort() {\n\t\tthis._mosaic.sort();\n\t}\n\n\tget mosaic() {\n\t\treturn this._mosaic;\n\t}\n\n\tset mosaic(value) {\n\t\tthis._mosaic = value;\n\t}\n\n\tget targetAddress() {\n\t\treturn this._targetAddress;\n\t}\n\n\tset targetAddress(value) {\n\t\tthis._targetAddress = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.mosaic.size;\n\t\tsize += this.targetAddress.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new LockSecretCreatedFeeReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst targetAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._targetAddress = targetAddress;\n\t\treturn instance;\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new LockSecretCreatedFeeReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst targetAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._targetAddress = targetAddress;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._mosaic.serialize());\n\t\tbuffer.write(this._targetAddress.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `mosaic: ${this._mosaic.toString()}, `;\n\t\tresult += `targetAddress: ${this._targetAddress.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.mosaic = this._mosaic.toJson();\n\t\tresult.targetAddress = this._targetAddress.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class LockSecretCompletedFeeReceipt extends Receipt {\n\tstatic RECEIPT_TYPE = ReceiptType.LOCK_SECRET_COMPLETED;\n\n\tstatic TYPE_HINTS = {\n\t\t...Receipt.TYPE_HINTS,\n\t\tmosaic: 'struct:Mosaic',\n\t\ttargetAddress: 'pod:Address'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._type = LockSecretCompletedFeeReceipt.RECEIPT_TYPE;\n\t\tthis._mosaic = new Mosaic();\n\t\tthis._targetAddress = new Address();\n\t}\n\n\tsort() {\n\t\tthis._mosaic.sort();\n\t}\n\n\tget mosaic() {\n\t\treturn this._mosaic;\n\t}\n\n\tset mosaic(value) {\n\t\tthis._mosaic = value;\n\t}\n\n\tget targetAddress() {\n\t\treturn this._targetAddress;\n\t}\n\n\tset targetAddress(value) {\n\t\tthis._targetAddress = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.mosaic.size;\n\t\tsize += this.targetAddress.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new LockSecretCompletedFeeReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst targetAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._targetAddress = targetAddress;\n\t\treturn instance;\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new LockSecretCompletedFeeReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst targetAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._targetAddress = targetAddress;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._mosaic.serialize());\n\t\tbuffer.write(this._targetAddress.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `mosaic: ${this._mosaic.toString()}, `;\n\t\tresult += `targetAddress: ${this._targetAddress.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.mosaic = this._mosaic.toJson();\n\t\tresult.targetAddress = this._targetAddress.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class LockSecretExpiredFeeReceipt extends Receipt {\n\tstatic RECEIPT_TYPE = ReceiptType.LOCK_SECRET_EXPIRED;\n\n\tstatic TYPE_HINTS = {\n\t\t...Receipt.TYPE_HINTS,\n\t\tmosaic: 'struct:Mosaic',\n\t\ttargetAddress: 'pod:Address'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._type = LockSecretExpiredFeeReceipt.RECEIPT_TYPE;\n\t\tthis._mosaic = new Mosaic();\n\t\tthis._targetAddress = new Address();\n\t}\n\n\tsort() {\n\t\tthis._mosaic.sort();\n\t}\n\n\tget mosaic() {\n\t\treturn this._mosaic;\n\t}\n\n\tset mosaic(value) {\n\t\tthis._mosaic = value;\n\t}\n\n\tget targetAddress() {\n\t\treturn this._targetAddress;\n\t}\n\n\tset targetAddress(value) {\n\t\tthis._targetAddress = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.mosaic.size;\n\t\tsize += this.targetAddress.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new LockSecretExpiredFeeReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst targetAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._targetAddress = targetAddress;\n\t\treturn instance;\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new LockSecretExpiredFeeReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst targetAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._targetAddress = targetAddress;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._mosaic.serialize());\n\t\tbuffer.write(this._targetAddress.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `mosaic: ${this._mosaic.toString()}, `;\n\t\tresult += `targetAddress: ${this._targetAddress.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.mosaic = this._mosaic.toJson();\n\t\tresult.targetAddress = this._targetAddress.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class MosaicExpiredReceipt extends Receipt {\n\tstatic RECEIPT_TYPE = ReceiptType.MOSAIC_EXPIRED;\n\n\tstatic TYPE_HINTS = {\n\t\t...Receipt.TYPE_HINTS,\n\t\tartifactId: 'pod:MosaicId'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._type = MosaicExpiredReceipt.RECEIPT_TYPE;\n\t\tthis._artifactId = new MosaicId();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget artifactId() {\n\t\treturn this._artifactId;\n\t}\n\n\tset artifactId(value) {\n\t\tthis._artifactId = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.artifactId.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new MosaicExpiredReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst artifactId = MosaicId.deserialize(view.buffer);\n\t\tview.shiftRight(artifactId.size);\n\n\t\tinstance._artifactId = artifactId;\n\t\treturn instance;\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new MosaicExpiredReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst artifactId = MosaicId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(artifactId.size);\n\n\t\tinstance._artifactId = artifactId;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._artifactId.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `artifactId: ${this._artifactId.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.artifactId = this._artifactId.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class MosaicRentalFeeReceipt extends Receipt {\n\tstatic RECEIPT_TYPE = ReceiptType.MOSAIC_RENTAL_FEE;\n\n\tstatic TYPE_HINTS = {\n\t\t...Receipt.TYPE_HINTS,\n\t\tmosaic: 'struct:Mosaic',\n\t\tsenderAddress: 'pod:Address',\n\t\trecipientAddress: 'pod:Address'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._type = MosaicRentalFeeReceipt.RECEIPT_TYPE;\n\t\tthis._mosaic = new Mosaic();\n\t\tthis._senderAddress = new Address();\n\t\tthis._recipientAddress = new Address();\n\t}\n\n\tsort() {\n\t\tthis._mosaic.sort();\n\t}\n\n\tget mosaic() {\n\t\treturn this._mosaic;\n\t}\n\n\tset mosaic(value) {\n\t\tthis._mosaic = value;\n\t}\n\n\tget senderAddress() {\n\t\treturn this._senderAddress;\n\t}\n\n\tset senderAddress(value) {\n\t\tthis._senderAddress = value;\n\t}\n\n\tget recipientAddress() {\n\t\treturn this._recipientAddress;\n\t}\n\n\tset recipientAddress(value) {\n\t\tthis._recipientAddress = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.mosaic.size;\n\t\tsize += this.senderAddress.size;\n\t\tsize += this.recipientAddress.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new MosaicRentalFeeReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst senderAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(senderAddress.size);\n\t\tconst recipientAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(recipientAddress.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._senderAddress = senderAddress;\n\t\tinstance._recipientAddress = recipientAddress;\n\t\treturn instance;\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new MosaicRentalFeeReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst senderAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(senderAddress.size);\n\t\tconst recipientAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(recipientAddress.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._senderAddress = senderAddress;\n\t\tinstance._recipientAddress = recipientAddress;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._mosaic.serialize());\n\t\tbuffer.write(this._senderAddress.serialize());\n\t\tbuffer.write(this._recipientAddress.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `mosaic: ${this._mosaic.toString()}, `;\n\t\tresult += `senderAddress: ${this._senderAddress.toString()}, `;\n\t\tresult += `recipientAddress: ${this._recipientAddress.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.mosaic = this._mosaic.toJson();\n\t\tresult.senderAddress = this._senderAddress.toJson();\n\t\tresult.recipientAddress = this._recipientAddress.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class NamespaceId extends BaseValue {\n\tstatic SIZE = 8;\n\n\tconstructor(namespaceId = 0n) {\n\t\tsuper(NamespaceId.SIZE, namespaceId);\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new NamespaceId(converter.bytesToBigIntUnaligned(byteArray, 8, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new NamespaceId(converter.bytesToBigInt(byteArray, 8, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 8, false);\n\t}\n}\n\nexport class NamespaceRegistrationType {\n\tstatic ROOT = new NamespaceRegistrationType(0);\n\n\tstatic CHILD = new NamespaceRegistrationType(1);\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n\n\tstatic valueToKey(value) {\n\t\tconst values = [\n\t\t\t0, 1\n\t\t];\n\t\tconst keys = [\n\t\t\t'ROOT', 'CHILD'\n\t\t];\n\n\t\tconst index = values.indexOf(value);\n\t\tif (-1 === index)\n\t\t\tthrow RangeError(`invalid enum value ${value}`);\n\n\t\treturn keys[index];\n\t}\n\n\tstatic fromValue(value) {\n\t\treturn NamespaceRegistrationType[this.valueToKey(value)];\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 1;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToIntUnaligned(byteArray, 1, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToInt(byteArray, 1, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 1, false);\n\t}\n\n\ttoString() {\n\t\treturn `NamespaceRegistrationType.${NamespaceRegistrationType.valueToKey(this.value)}`;\n\t}\n\n\ttoJson() {\n\t\treturn this.value;\n\t}\n}\n\nexport class AliasAction {\n\tstatic UNLINK = new AliasAction(0);\n\n\tstatic LINK = new AliasAction(1);\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n\n\tstatic valueToKey(value) {\n\t\tconst values = [\n\t\t\t0, 1\n\t\t];\n\t\tconst keys = [\n\t\t\t'UNLINK', 'LINK'\n\t\t];\n\n\t\tconst index = values.indexOf(value);\n\t\tif (-1 === index)\n\t\t\tthrow RangeError(`invalid enum value ${value}`);\n\n\t\treturn keys[index];\n\t}\n\n\tstatic fromValue(value) {\n\t\treturn AliasAction[this.valueToKey(value)];\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 1;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToIntUnaligned(byteArray, 1, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToInt(byteArray, 1, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 1, false);\n\t}\n\n\ttoString() {\n\t\treturn `AliasAction.${AliasAction.valueToKey(this.value)}`;\n\t}\n\n\ttoJson() {\n\t\treturn this.value;\n\t}\n}\n\nexport class NamespaceExpiredReceipt extends Receipt {\n\tstatic RECEIPT_TYPE = ReceiptType.NAMESPACE_EXPIRED;\n\n\tstatic TYPE_HINTS = {\n\t\t...Receipt.TYPE_HINTS,\n\t\tartifactId: 'pod:NamespaceId'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._type = NamespaceExpiredReceipt.RECEIPT_TYPE;\n\t\tthis._artifactId = new NamespaceId();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget artifactId() {\n\t\treturn this._artifactId;\n\t}\n\n\tset artifactId(value) {\n\t\tthis._artifactId = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.artifactId.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new NamespaceExpiredReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst artifactId = NamespaceId.deserialize(view.buffer);\n\t\tview.shiftRight(artifactId.size);\n\n\t\tinstance._artifactId = artifactId;\n\t\treturn instance;\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new NamespaceExpiredReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst artifactId = NamespaceId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(artifactId.size);\n\n\t\tinstance._artifactId = artifactId;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._artifactId.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `artifactId: ${this._artifactId.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.artifactId = this._artifactId.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class NamespaceDeletedReceipt extends Receipt {\n\tstatic RECEIPT_TYPE = ReceiptType.NAMESPACE_DELETED;\n\n\tstatic TYPE_HINTS = {\n\t\t...Receipt.TYPE_HINTS,\n\t\tartifactId: 'pod:NamespaceId'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._type = NamespaceDeletedReceipt.RECEIPT_TYPE;\n\t\tthis._artifactId = new NamespaceId();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget artifactId() {\n\t\treturn this._artifactId;\n\t}\n\n\tset artifactId(value) {\n\t\tthis._artifactId = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.artifactId.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new NamespaceDeletedReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst artifactId = NamespaceId.deserialize(view.buffer);\n\t\tview.shiftRight(artifactId.size);\n\n\t\tinstance._artifactId = artifactId;\n\t\treturn instance;\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new NamespaceDeletedReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst artifactId = NamespaceId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(artifactId.size);\n\n\t\tinstance._artifactId = artifactId;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._artifactId.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `artifactId: ${this._artifactId.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.artifactId = this._artifactId.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class NamespaceRentalFeeReceipt extends Receipt {\n\tstatic RECEIPT_TYPE = ReceiptType.NAMESPACE_RENTAL_FEE;\n\n\tstatic TYPE_HINTS = {\n\t\t...Receipt.TYPE_HINTS,\n\t\tmosaic: 'struct:Mosaic',\n\t\tsenderAddress: 'pod:Address',\n\t\trecipientAddress: 'pod:Address'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._type = NamespaceRentalFeeReceipt.RECEIPT_TYPE;\n\t\tthis._mosaic = new Mosaic();\n\t\tthis._senderAddress = new Address();\n\t\tthis._recipientAddress = new Address();\n\t}\n\n\tsort() {\n\t\tthis._mosaic.sort();\n\t}\n\n\tget mosaic() {\n\t\treturn this._mosaic;\n\t}\n\n\tset mosaic(value) {\n\t\tthis._mosaic = value;\n\t}\n\n\tget senderAddress() {\n\t\treturn this._senderAddress;\n\t}\n\n\tset senderAddress(value) {\n\t\tthis._senderAddress = value;\n\t}\n\n\tget recipientAddress() {\n\t\treturn this._recipientAddress;\n\t}\n\n\tset recipientAddress(value) {\n\t\tthis._recipientAddress = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.mosaic.size;\n\t\tsize += this.senderAddress.size;\n\t\tsize += this.recipientAddress.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new NamespaceRentalFeeReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst senderAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(senderAddress.size);\n\t\tconst recipientAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(recipientAddress.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._senderAddress = senderAddress;\n\t\tinstance._recipientAddress = recipientAddress;\n\t\treturn instance;\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new NamespaceRentalFeeReceipt();\n\n\t\tReceipt._deserialize(view, instance);\n\t\tconst mosaic = Mosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst senderAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(senderAddress.size);\n\t\tconst recipientAddress = Address.deserialize(view.buffer);\n\t\tview.shiftRight(recipientAddress.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._senderAddress = senderAddress;\n\t\tinstance._recipientAddress = recipientAddress;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._mosaic.serialize());\n\t\tbuffer.write(this._senderAddress.serialize());\n\t\tbuffer.write(this._recipientAddress.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `mosaic: ${this._mosaic.toString()}, `;\n\t\tresult += `senderAddress: ${this._senderAddress.toString()}, `;\n\t\tresult += `recipientAddress: ${this._recipientAddress.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.mosaic = this._mosaic.toJson();\n\t\tresult.senderAddress = this._senderAddress.toJson();\n\t\tresult.recipientAddress = this._recipientAddress.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class ReceiptSource {\n\tstatic TYPE_HINTS = {\n\t};\n\n\tconstructor() {\n\t\tthis._primaryId = 0;\n\t\tthis._secondaryId = 0;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget primaryId() {\n\t\treturn this._primaryId;\n\t}\n\n\tset primaryId(value) {\n\t\tthis._primaryId = value;\n\t}\n\n\tget secondaryId() {\n\t\treturn this._secondaryId;\n\t}\n\n\tset secondaryId(value) {\n\t\tthis._secondaryId = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += 4;\n\t\tsize += 4;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new ReceiptSource();\n\n\t\tconst primaryId = converter.bytesToIntUnaligned(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tconst secondaryId = converter.bytesToIntUnaligned(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\n\t\tinstance._primaryId = primaryId;\n\t\tinstance._secondaryId = secondaryId;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tbuffer.write(converter.intToBytes(this._primaryId, 4, false));\n\t\tbuffer.write(converter.intToBytes(this._secondaryId, 4, false));\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += `primaryId: ${'0x'.concat(this._primaryId.toString(16))}, `;\n\t\tresult += `secondaryId: ${'0x'.concat(this._secondaryId.toString(16))}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tresult.primaryId = this._primaryId;\n\t\tresult.secondaryId = this._secondaryId;\n\t\treturn result;\n\t}\n}\n\nexport class AddressResolutionEntry {\n\tstatic TYPE_HINTS = {\n\t\tsource: 'struct:ReceiptSource',\n\t\tresolvedValue: 'pod:Address'\n\t};\n\n\tconstructor() {\n\t\tthis._source = new ReceiptSource();\n\t\tthis._resolvedValue = new Address();\n\t}\n\n\tsort() {\n\t\tthis._source.sort();\n\t}\n\n\tget source() {\n\t\treturn this._source;\n\t}\n\n\tset source(value) {\n\t\tthis._source = value;\n\t}\n\n\tget resolvedValue() {\n\t\treturn this._resolvedValue;\n\t}\n\n\tset resolvedValue(value) {\n\t\tthis._resolvedValue = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += this.source.size;\n\t\tsize += this.resolvedValue.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new AddressResolutionEntry();\n\n\t\tconst source = ReceiptSource.deserialize(view.buffer);\n\t\tview.shiftRight(source.size);\n\t\tconst resolvedValue = Address.deserialize(view.buffer);\n\t\tview.shiftRight(resolvedValue.size);\n\n\t\tinstance._source = source;\n\t\tinstance._resolvedValue = resolvedValue;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tbuffer.write(this._source.serialize());\n\t\tbuffer.write(this._resolvedValue.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += `source: ${this._source.toString()}, `;\n\t\tresult += `resolvedValue: ${this._resolvedValue.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tresult.source = this._source.toJson();\n\t\tresult.resolvedValue = this._resolvedValue.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class AddressResolutionStatement {\n\tstatic TYPE_HINTS = {\n\t\tunresolved: 'pod:UnresolvedAddress',\n\t\tresolutionEntries: 'array[AddressResolutionEntry]'\n\t};\n\n\tconstructor() {\n\t\tthis._unresolved = new UnresolvedAddress();\n\t\tthis._resolutionEntries = [];\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget unresolved() {\n\t\treturn this._unresolved;\n\t}\n\n\tset unresolved(value) {\n\t\tthis._unresolved = value;\n\t}\n\n\tget resolutionEntries() {\n\t\treturn this._resolutionEntries;\n\t}\n\n\tset resolutionEntries(value) {\n\t\tthis._resolutionEntries = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += this.unresolved.size;\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.resolutionEntries);\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new AddressResolutionStatement();\n\n\t\tconst unresolved = UnresolvedAddress.deserialize(view.buffer);\n\t\tview.shiftRight(unresolved.size);\n\t\tconst resolutionEntriesCount = converter.bytesToIntUnaligned(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tconst resolutionEntries = arrayHelpers.readArrayCount(view.buffer, AddressResolutionEntry, resolutionEntriesCount);\n\t\tview.shiftRight(arrayHelpers.size(resolutionEntries));\n\n\t\tinstance._unresolved = unresolved;\n\t\tinstance._resolutionEntries = resolutionEntries;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tbuffer.write(this._unresolved.serialize());\n\t\tbuffer.write(converter.intToBytes(this._resolutionEntries.length, 4, false)); // bound: resolution_entries_count\n\t\tarrayHelpers.writeArray(buffer, this._resolutionEntries);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += `unresolved: ${this._unresolved.toString()}, `;\n\t\tresult += `resolutionEntries: [${this._resolutionEntries.map(e => e.toString()).join(',')}], `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tresult.unresolved = this._unresolved.toJson();\n\t\tresult.resolutionEntries = this._resolutionEntries.map(e => e.toJson());\n\t\treturn result;\n\t}\n}\n\nexport class MosaicResolutionEntry {\n\tstatic TYPE_HINTS = {\n\t\tsource: 'struct:ReceiptSource',\n\t\tresolvedValue: 'pod:MosaicId'\n\t};\n\n\tconstructor() {\n\t\tthis._source = new ReceiptSource();\n\t\tthis._resolvedValue = new MosaicId();\n\t}\n\n\tsort() {\n\t\tthis._source.sort();\n\t}\n\n\tget source() {\n\t\treturn this._source;\n\t}\n\n\tset source(value) {\n\t\tthis._source = value;\n\t}\n\n\tget resolvedValue() {\n\t\treturn this._resolvedValue;\n\t}\n\n\tset resolvedValue(value) {\n\t\tthis._resolvedValue = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += this.source.size;\n\t\tsize += this.resolvedValue.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new MosaicResolutionEntry();\n\n\t\tconst source = ReceiptSource.deserialize(view.buffer);\n\t\tview.shiftRight(source.size);\n\t\tconst resolvedValue = MosaicId.deserialize(view.buffer);\n\t\tview.shiftRight(resolvedValue.size);\n\n\t\tinstance._source = source;\n\t\tinstance._resolvedValue = resolvedValue;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tbuffer.write(this._source.serialize());\n\t\tbuffer.write(this._resolvedValue.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += `source: ${this._source.toString()}, `;\n\t\tresult += `resolvedValue: ${this._resolvedValue.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tresult.source = this._source.toJson();\n\t\tresult.resolvedValue = this._resolvedValue.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class MosaicResolutionStatement {\n\tstatic TYPE_HINTS = {\n\t\tunresolved: 'pod:UnresolvedMosaicId',\n\t\tresolutionEntries: 'array[MosaicResolutionEntry]'\n\t};\n\n\tconstructor() {\n\t\tthis._unresolved = new UnresolvedMosaicId();\n\t\tthis._resolutionEntries = [];\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget unresolved() {\n\t\treturn this._unresolved;\n\t}\n\n\tset unresolved(value) {\n\t\tthis._unresolved = value;\n\t}\n\n\tget resolutionEntries() {\n\t\treturn this._resolutionEntries;\n\t}\n\n\tset resolutionEntries(value) {\n\t\tthis._resolutionEntries = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += this.unresolved.size;\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.resolutionEntries);\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new MosaicResolutionStatement();\n\n\t\tconst unresolved = UnresolvedMosaicId.deserialize(view.buffer);\n\t\tview.shiftRight(unresolved.size);\n\t\tconst resolutionEntriesCount = converter.bytesToIntUnaligned(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tconst resolutionEntries = arrayHelpers.readArrayCount(view.buffer, MosaicResolutionEntry, resolutionEntriesCount);\n\t\tview.shiftRight(arrayHelpers.size(resolutionEntries));\n\n\t\tinstance._unresolved = unresolved;\n\t\tinstance._resolutionEntries = resolutionEntries;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tbuffer.write(this._unresolved.serialize());\n\t\tbuffer.write(converter.intToBytes(this._resolutionEntries.length, 4, false)); // bound: resolution_entries_count\n\t\tarrayHelpers.writeArray(buffer, this._resolutionEntries);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += `unresolved: ${this._unresolved.toString()}, `;\n\t\tresult += `resolutionEntries: [${this._resolutionEntries.map(e => e.toString()).join(',')}], `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tresult.unresolved = this._unresolved.toJson();\n\t\tresult.resolutionEntries = this._resolutionEntries.map(e => e.toJson());\n\t\treturn result;\n\t}\n}\n\nexport class TransactionStatement {\n\tstatic TYPE_HINTS = {\n\t\treceipts: 'array[Receipt]'\n\t};\n\n\tconstructor() {\n\t\tthis._primaryId = 0;\n\t\tthis._secondaryId = 0;\n\t\tthis._receipts = [];\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget primaryId() {\n\t\treturn this._primaryId;\n\t}\n\n\tset primaryId(value) {\n\t\tthis._primaryId = value;\n\t}\n\n\tget secondaryId() {\n\t\treturn this._secondaryId;\n\t}\n\n\tset secondaryId(value) {\n\t\tthis._secondaryId = value;\n\t}\n\n\tget receipts() {\n\t\treturn this._receipts;\n\t}\n\n\tset receipts(value) {\n\t\tthis._receipts = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += 4;\n\t\tsize += 4;\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.receipts);\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new TransactionStatement();\n\n\t\tconst primaryId = converter.bytesToIntUnaligned(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tconst secondaryId = converter.bytesToIntUnaligned(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tconst receiptCount = converter.bytesToIntUnaligned(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tconst receipts = arrayHelpers.readArrayCount(view.buffer, ReceiptFactory, receiptCount);\n\t\tview.shiftRight(arrayHelpers.size(receipts));\n\n\t\tinstance._primaryId = primaryId;\n\t\tinstance._secondaryId = secondaryId;\n\t\tinstance._receipts = receipts;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tbuffer.write(converter.intToBytes(this._primaryId, 4, false));\n\t\tbuffer.write(converter.intToBytes(this._secondaryId, 4, false));\n\t\tbuffer.write(converter.intToBytes(this._receipts.length, 4, false)); // bound: receipt_count\n\t\tarrayHelpers.writeArray(buffer, this._receipts);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += `primaryId: ${'0x'.concat(this._primaryId.toString(16))}, `;\n\t\tresult += `secondaryId: ${'0x'.concat(this._secondaryId.toString(16))}, `;\n\t\tresult += `receipts: [${this._receipts.map(e => e.toString()).join(',')}], `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tresult.primaryId = this._primaryId;\n\t\tresult.secondaryId = this._secondaryId;\n\t\tresult.receipts = this._receipts.map(e => e.toJson());\n\t\treturn result;\n\t}\n}\n\nexport class BlockStatement {\n\tstatic TYPE_HINTS = {\n\t\ttransactionStatements: 'array[TransactionStatement]',\n\t\taddressResolutionStatements: 'array[AddressResolutionStatement]',\n\t\tmosaicResolutionStatements: 'array[MosaicResolutionStatement]'\n\t};\n\n\tconstructor() {\n\t\tthis._transactionStatements = [];\n\t\tthis._addressResolutionStatements = [];\n\t\tthis._mosaicResolutionStatements = [];\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget transactionStatements() {\n\t\treturn this._transactionStatements;\n\t}\n\n\tset transactionStatements(value) {\n\t\tthis._transactionStatements = value;\n\t}\n\n\tget addressResolutionStatements() {\n\t\treturn this._addressResolutionStatements;\n\t}\n\n\tset addressResolutionStatements(value) {\n\t\tthis._addressResolutionStatements = value;\n\t}\n\n\tget mosaicResolutionStatements() {\n\t\treturn this._mosaicResolutionStatements;\n\t}\n\n\tset mosaicResolutionStatements(value) {\n\t\tthis._mosaicResolutionStatements = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.transactionStatements);\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.addressResolutionStatements);\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.mosaicResolutionStatements);\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new BlockStatement();\n\n\t\tconst transactionStatementCount = converter.bytesToIntUnaligned(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tconst transactionStatements = arrayHelpers.readArrayCount(view.buffer, TransactionStatement, transactionStatementCount);\n\t\tview.shiftRight(arrayHelpers.size(transactionStatements));\n\t\tconst addressResolutionStatementCount = converter.bytesToIntUnaligned(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tconst addressResolutionStatements = arrayHelpers.readArrayCount(view.buffer, AddressResolutionStatement, addressResolutionStatementCount);\n\t\tview.shiftRight(arrayHelpers.size(addressResolutionStatements));\n\t\tconst mosaicResolutionStatementCount = converter.bytesToIntUnaligned(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tconst mosaicResolutionStatements = arrayHelpers.readArrayCount(view.buffer, MosaicResolutionStatement, mosaicResolutionStatementCount);\n\t\tview.shiftRight(arrayHelpers.size(mosaicResolutionStatements));\n\n\t\tinstance._transactionStatements = transactionStatements;\n\t\tinstance._addressResolutionStatements = addressResolutionStatements;\n\t\tinstance._mosaicResolutionStatements = mosaicResolutionStatements;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tbuffer.write(converter.intToBytes(this._transactionStatements.length, 4, false)); // bound: transaction_statement_count\n\t\tarrayHelpers.writeArray(buffer, this._transactionStatements);\n\t\tbuffer.write(converter.intToBytes(this._addressResolutionStatements.length, 4, false)); // bound: address_resolution_statement_count\n\t\tarrayHelpers.writeArray(buffer, this._addressResolutionStatements);\n\t\tbuffer.write(converter.intToBytes(this._mosaicResolutionStatements.length, 4, false)); // bound: mosaic_resolution_statement_count\n\t\tarrayHelpers.writeArray(buffer, this._mosaicResolutionStatements);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += `transactionStatements: [${this._transactionStatements.map(e => e.toString()).join(',')}], `;\n\t\tresult += `addressResolutionStatements: [${this._addressResolutionStatements.map(e => e.toString()).join(',')}], `;\n\t\tresult += `mosaicResolutionStatements: [${this._mosaicResolutionStatements.map(e => e.toString()).join(',')}], `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tresult.transactionStatements = this._transactionStatements.map(e => e.toJson());\n\t\tresult.addressResolutionStatements = this._addressResolutionStatements.map(e => e.toJson());\n\t\tresult.mosaicResolutionStatements = this._mosaicResolutionStatements.map(e => e.toJson());\n\t\treturn result;\n\t}\n}\n\nexport class AccountKeyLinkTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.ACCOUNT_KEY_LINK;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\tlinkedPublicKey: 'pod:PublicKey',\n\t\tlinkAction: 'enum:LinkAction'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = AccountKeyLinkTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = AccountKeyLinkTransactionV1.TRANSACTION_TYPE;\n\t\tthis._linkedPublicKey = new PublicKey();\n\t\tthis._linkAction = LinkAction.UNLINK;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget linkedPublicKey() {\n\t\treturn this._linkedPublicKey;\n\t}\n\n\tset linkedPublicKey(value) {\n\t\tthis._linkedPublicKey = value;\n\t}\n\n\tget linkAction() {\n\t\treturn this._linkAction;\n\t}\n\n\tset linkAction(value) {\n\t\tthis._linkAction = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.linkedPublicKey.size;\n\t\tsize += this.linkAction.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new AccountKeyLinkTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst linkedPublicKey = PublicKey.deserialize(view.buffer);\n\t\tview.shiftRight(linkedPublicKey.size);\n\t\tconst linkAction = LinkAction.deserializeAligned(view.buffer);\n\t\tview.shiftRight(linkAction.size);\n\n\t\tinstance._linkedPublicKey = linkedPublicKey;\n\t\tinstance._linkAction = linkAction;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._linkedPublicKey.serialize());\n\t\tbuffer.write(this._linkAction.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `linkedPublicKey: ${this._linkedPublicKey.toString()}, `;\n\t\tresult += `linkAction: ${this._linkAction.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.linkedPublicKey = this._linkedPublicKey.toJson();\n\t\tresult.linkAction = this._linkAction.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedAccountKeyLinkTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.ACCOUNT_KEY_LINK;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\tlinkedPublicKey: 'pod:PublicKey',\n\t\tlinkAction: 'enum:LinkAction'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedAccountKeyLinkTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedAccountKeyLinkTransactionV1.TRANSACTION_TYPE;\n\t\tthis._linkedPublicKey = new PublicKey();\n\t\tthis._linkAction = LinkAction.UNLINK;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget linkedPublicKey() {\n\t\treturn this._linkedPublicKey;\n\t}\n\n\tset linkedPublicKey(value) {\n\t\tthis._linkedPublicKey = value;\n\t}\n\n\tget linkAction() {\n\t\treturn this._linkAction;\n\t}\n\n\tset linkAction(value) {\n\t\tthis._linkAction = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.linkedPublicKey.size;\n\t\tsize += this.linkAction.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedAccountKeyLinkTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst linkedPublicKey = PublicKey.deserialize(view.buffer);\n\t\tview.shiftRight(linkedPublicKey.size);\n\t\tconst linkAction = LinkAction.deserializeAligned(view.buffer);\n\t\tview.shiftRight(linkAction.size);\n\n\t\tinstance._linkedPublicKey = linkedPublicKey;\n\t\tinstance._linkAction = linkAction;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._linkedPublicKey.serialize());\n\t\tbuffer.write(this._linkAction.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `linkedPublicKey: ${this._linkedPublicKey.toString()}, `;\n\t\tresult += `linkAction: ${this._linkAction.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.linkedPublicKey = this._linkedPublicKey.toJson();\n\t\tresult.linkAction = this._linkAction.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class NodeKeyLinkTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.NODE_KEY_LINK;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\tlinkedPublicKey: 'pod:PublicKey',\n\t\tlinkAction: 'enum:LinkAction'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = NodeKeyLinkTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = NodeKeyLinkTransactionV1.TRANSACTION_TYPE;\n\t\tthis._linkedPublicKey = new PublicKey();\n\t\tthis._linkAction = LinkAction.UNLINK;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget linkedPublicKey() {\n\t\treturn this._linkedPublicKey;\n\t}\n\n\tset linkedPublicKey(value) {\n\t\tthis._linkedPublicKey = value;\n\t}\n\n\tget linkAction() {\n\t\treturn this._linkAction;\n\t}\n\n\tset linkAction(value) {\n\t\tthis._linkAction = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.linkedPublicKey.size;\n\t\tsize += this.linkAction.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new NodeKeyLinkTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst linkedPublicKey = PublicKey.deserialize(view.buffer);\n\t\tview.shiftRight(linkedPublicKey.size);\n\t\tconst linkAction = LinkAction.deserializeAligned(view.buffer);\n\t\tview.shiftRight(linkAction.size);\n\n\t\tinstance._linkedPublicKey = linkedPublicKey;\n\t\tinstance._linkAction = linkAction;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._linkedPublicKey.serialize());\n\t\tbuffer.write(this._linkAction.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `linkedPublicKey: ${this._linkedPublicKey.toString()}, `;\n\t\tresult += `linkAction: ${this._linkAction.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.linkedPublicKey = this._linkedPublicKey.toJson();\n\t\tresult.linkAction = this._linkAction.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedNodeKeyLinkTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.NODE_KEY_LINK;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\tlinkedPublicKey: 'pod:PublicKey',\n\t\tlinkAction: 'enum:LinkAction'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedNodeKeyLinkTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedNodeKeyLinkTransactionV1.TRANSACTION_TYPE;\n\t\tthis._linkedPublicKey = new PublicKey();\n\t\tthis._linkAction = LinkAction.UNLINK;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget linkedPublicKey() {\n\t\treturn this._linkedPublicKey;\n\t}\n\n\tset linkedPublicKey(value) {\n\t\tthis._linkedPublicKey = value;\n\t}\n\n\tget linkAction() {\n\t\treturn this._linkAction;\n\t}\n\n\tset linkAction(value) {\n\t\tthis._linkAction = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.linkedPublicKey.size;\n\t\tsize += this.linkAction.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedNodeKeyLinkTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst linkedPublicKey = PublicKey.deserialize(view.buffer);\n\t\tview.shiftRight(linkedPublicKey.size);\n\t\tconst linkAction = LinkAction.deserializeAligned(view.buffer);\n\t\tview.shiftRight(linkAction.size);\n\n\t\tinstance._linkedPublicKey = linkedPublicKey;\n\t\tinstance._linkAction = linkAction;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._linkedPublicKey.serialize());\n\t\tbuffer.write(this._linkAction.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `linkedPublicKey: ${this._linkedPublicKey.toString()}, `;\n\t\tresult += `linkAction: ${this._linkAction.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.linkedPublicKey = this._linkedPublicKey.toJson();\n\t\tresult.linkAction = this._linkAction.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class Cosignature {\n\tstatic TYPE_HINTS = {\n\t\tsignerPublicKey: 'pod:PublicKey',\n\t\tsignature: 'pod:Signature'\n\t};\n\n\tconstructor() {\n\t\tthis._version = 0n;\n\t\tthis._signerPublicKey = new PublicKey();\n\t\tthis._signature = new Signature();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget version() {\n\t\treturn this._version;\n\t}\n\n\tset version(value) {\n\t\tthis._version = value;\n\t}\n\n\tget signerPublicKey() {\n\t\treturn this._signerPublicKey;\n\t}\n\n\tset signerPublicKey(value) {\n\t\tthis._signerPublicKey = value;\n\t}\n\n\tget signature() {\n\t\treturn this._signature;\n\t}\n\n\tset signature(value) {\n\t\tthis._signature = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += 8;\n\t\tsize += this.signerPublicKey.size;\n\t\tsize += this.signature.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new Cosignature();\n\n\t\tconst version = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst signerPublicKey = PublicKey.deserialize(view.buffer);\n\t\tview.shiftRight(signerPublicKey.size);\n\t\tconst signature = Signature.deserialize(view.buffer);\n\t\tview.shiftRight(signature.size);\n\n\t\tinstance._version = version;\n\t\tinstance._signerPublicKey = signerPublicKey;\n\t\tinstance._signature = signature;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tbuffer.write(converter.intToBytes(this._version, 8, false));\n\t\tbuffer.write(this._signerPublicKey.serialize());\n\t\tbuffer.write(this._signature.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += `version: ${'0x'.concat(this._version.toString(16))}, `;\n\t\tresult += `signerPublicKey: ${this._signerPublicKey.toString()}, `;\n\t\tresult += `signature: ${this._signature.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tresult.version = this._version.toString();\n\t\tresult.signerPublicKey = this._signerPublicKey.toJson();\n\t\tresult.signature = this._signature.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class DetachedCosignature {\n\tstatic TYPE_HINTS = {\n\t\tsignerPublicKey: 'pod:PublicKey',\n\t\tsignature: 'pod:Signature',\n\t\tparentHash: 'pod:Hash256'\n\t};\n\n\tconstructor() {\n\t\tthis._version = 0n;\n\t\tthis._signerPublicKey = new PublicKey();\n\t\tthis._signature = new Signature();\n\t\tthis._parentHash = new Hash256();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget version() {\n\t\treturn this._version;\n\t}\n\n\tset version(value) {\n\t\tthis._version = value;\n\t}\n\n\tget signerPublicKey() {\n\t\treturn this._signerPublicKey;\n\t}\n\n\tset signerPublicKey(value) {\n\t\tthis._signerPublicKey = value;\n\t}\n\n\tget signature() {\n\t\treturn this._signature;\n\t}\n\n\tset signature(value) {\n\t\tthis._signature = value;\n\t}\n\n\tget parentHash() {\n\t\treturn this._parentHash;\n\t}\n\n\tset parentHash(value) {\n\t\tthis._parentHash = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += 8;\n\t\tsize += this.signerPublicKey.size;\n\t\tsize += this.signature.size;\n\t\tsize += this.parentHash.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new DetachedCosignature();\n\n\t\tconst version = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst signerPublicKey = PublicKey.deserialize(view.buffer);\n\t\tview.shiftRight(signerPublicKey.size);\n\t\tconst signature = Signature.deserialize(view.buffer);\n\t\tview.shiftRight(signature.size);\n\t\tconst parentHash = Hash256.deserialize(view.buffer);\n\t\tview.shiftRight(parentHash.size);\n\n\t\tinstance._version = version;\n\t\tinstance._signerPublicKey = signerPublicKey;\n\t\tinstance._signature = signature;\n\t\tinstance._parentHash = parentHash;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tbuffer.write(converter.intToBytes(this._version, 8, false));\n\t\tbuffer.write(this._signerPublicKey.serialize());\n\t\tbuffer.write(this._signature.serialize());\n\t\tbuffer.write(this._parentHash.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += `version: ${'0x'.concat(this._version.toString(16))}, `;\n\t\tresult += `signerPublicKey: ${this._signerPublicKey.toString()}, `;\n\t\tresult += `signature: ${this._signature.toString()}, `;\n\t\tresult += `parentHash: ${this._parentHash.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tresult.version = this._version.toString();\n\t\tresult.signerPublicKey = this._signerPublicKey.toJson();\n\t\tresult.signature = this._signature.toJson();\n\t\tresult.parentHash = this._parentHash.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class AggregateCompleteTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.AGGREGATE_COMPLETE;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\ttransactionsHash: 'pod:Hash256',\n\t\ttransactions: 'array[EmbeddedTransaction]',\n\t\tcosignatures: 'array[Cosignature]'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = AggregateCompleteTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = AggregateCompleteTransactionV1.TRANSACTION_TYPE;\n\t\tthis._transactionsHash = new Hash256();\n\t\tthis._transactions = [];\n\t\tthis._cosignatures = [];\n\t\tthis._aggregateTransactionHeaderReserved_1 = 0; // reserved field\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget transactionsHash() {\n\t\treturn this._transactionsHash;\n\t}\n\n\tset transactionsHash(value) {\n\t\tthis._transactionsHash = value;\n\t}\n\n\tget transactions() {\n\t\treturn this._transactions;\n\t}\n\n\tset transactions(value) {\n\t\tthis._transactions = value;\n\t}\n\n\tget cosignatures() {\n\t\treturn this._cosignatures;\n\t}\n\n\tset cosignatures(value) {\n\t\tthis._cosignatures = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.transactionsHash.size;\n\t\tsize += 4;\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.transactions, 8, false);\n\t\tsize += arrayHelpers.size(this.cosignatures);\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new AggregateCompleteTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst transactionsHash = Hash256.deserialize(view.buffer);\n\t\tview.shiftRight(transactionsHash.size);\n\t\tconst payloadSize = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tconst aggregateTransactionHeaderReserved_1 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== aggregateTransactionHeaderReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${aggregateTransactionHeaderReserved_1})`);\n\t\tconst transactions = arrayHelpers.readVariableSizeElements(view.window(payloadSize), EmbeddedTransactionFactory, 8, false);\n\t\tview.shiftRight(payloadSize);\n\t\tconst cosignatures = arrayHelpers.readArray(view.buffer, Cosignature);\n\t\tview.shiftRight(arrayHelpers.size(cosignatures));\n\n\t\tinstance._transactionsHash = transactionsHash;\n\t\tinstance._transactions = transactions;\n\t\tinstance._cosignatures = cosignatures;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._transactionsHash.serialize());\n\t\tbuffer.write(converter.intToBytes(arrayHelpers.size(this.transactions, 8, false), 4, false)); // bound: payload_size\n\t\tbuffer.write(converter.intToBytes(this._aggregateTransactionHeaderReserved_1, 4, false));\n\t\tarrayHelpers.writeVariableSizeElements(buffer, this._transactions, 8, false);\n\t\tarrayHelpers.writeArray(buffer, this._cosignatures);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `transactionsHash: ${this._transactionsHash.toString()}, `;\n\t\tresult += `transactions: [${this._transactions.map(e => e.toString()).join(',')}], `;\n\t\tresult += `cosignatures: [${this._cosignatures.map(e => e.toString()).join(',')}], `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.transactionsHash = this._transactionsHash.toJson();\n\t\tresult.transactions = this._transactions.map(e => e.toJson());\n\t\tresult.cosignatures = this._cosignatures.map(e => e.toJson());\n\t\treturn result;\n\t}\n}\n\nexport class AggregateCompleteTransactionV2 extends Transaction {\n\tstatic TRANSACTION_VERSION = 2;\n\n\tstatic TRANSACTION_TYPE = TransactionType.AGGREGATE_COMPLETE;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\ttransactionsHash: 'pod:Hash256',\n\t\ttransactions: 'array[EmbeddedTransaction]',\n\t\tcosignatures: 'array[Cosignature]'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = AggregateCompleteTransactionV2.TRANSACTION_VERSION;\n\t\tthis._type = AggregateCompleteTransactionV2.TRANSACTION_TYPE;\n\t\tthis._transactionsHash = new Hash256();\n\t\tthis._transactions = [];\n\t\tthis._cosignatures = [];\n\t\tthis._aggregateTransactionHeaderReserved_1 = 0; // reserved field\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget transactionsHash() {\n\t\treturn this._transactionsHash;\n\t}\n\n\tset transactionsHash(value) {\n\t\tthis._transactionsHash = value;\n\t}\n\n\tget transactions() {\n\t\treturn this._transactions;\n\t}\n\n\tset transactions(value) {\n\t\tthis._transactions = value;\n\t}\n\n\tget cosignatures() {\n\t\treturn this._cosignatures;\n\t}\n\n\tset cosignatures(value) {\n\t\tthis._cosignatures = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.transactionsHash.size;\n\t\tsize += 4;\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.transactions, 8, false);\n\t\tsize += arrayHelpers.size(this.cosignatures);\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new AggregateCompleteTransactionV2();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst transactionsHash = Hash256.deserialize(view.buffer);\n\t\tview.shiftRight(transactionsHash.size);\n\t\tconst payloadSize = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tconst aggregateTransactionHeaderReserved_1 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== aggregateTransactionHeaderReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${aggregateTransactionHeaderReserved_1})`);\n\t\tconst transactions = arrayHelpers.readVariableSizeElements(view.window(payloadSize), EmbeddedTransactionFactory, 8, false);\n\t\tview.shiftRight(payloadSize);\n\t\tconst cosignatures = arrayHelpers.readArray(view.buffer, Cosignature);\n\t\tview.shiftRight(arrayHelpers.size(cosignatures));\n\n\t\tinstance._transactionsHash = transactionsHash;\n\t\tinstance._transactions = transactions;\n\t\tinstance._cosignatures = cosignatures;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._transactionsHash.serialize());\n\t\tbuffer.write(converter.intToBytes(arrayHelpers.size(this.transactions, 8, false), 4, false)); // bound: payload_size\n\t\tbuffer.write(converter.intToBytes(this._aggregateTransactionHeaderReserved_1, 4, false));\n\t\tarrayHelpers.writeVariableSizeElements(buffer, this._transactions, 8, false);\n\t\tarrayHelpers.writeArray(buffer, this._cosignatures);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `transactionsHash: ${this._transactionsHash.toString()}, `;\n\t\tresult += `transactions: [${this._transactions.map(e => e.toString()).join(',')}], `;\n\t\tresult += `cosignatures: [${this._cosignatures.map(e => e.toString()).join(',')}], `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.transactionsHash = this._transactionsHash.toJson();\n\t\tresult.transactions = this._transactions.map(e => e.toJson());\n\t\tresult.cosignatures = this._cosignatures.map(e => e.toJson());\n\t\treturn result;\n\t}\n}\n\nexport class AggregateBondedTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.AGGREGATE_BONDED;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\ttransactionsHash: 'pod:Hash256',\n\t\ttransactions: 'array[EmbeddedTransaction]',\n\t\tcosignatures: 'array[Cosignature]'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = AggregateBondedTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = AggregateBondedTransactionV1.TRANSACTION_TYPE;\n\t\tthis._transactionsHash = new Hash256();\n\t\tthis._transactions = [];\n\t\tthis._cosignatures = [];\n\t\tthis._aggregateTransactionHeaderReserved_1 = 0; // reserved field\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget transactionsHash() {\n\t\treturn this._transactionsHash;\n\t}\n\n\tset transactionsHash(value) {\n\t\tthis._transactionsHash = value;\n\t}\n\n\tget transactions() {\n\t\treturn this._transactions;\n\t}\n\n\tset transactions(value) {\n\t\tthis._transactions = value;\n\t}\n\n\tget cosignatures() {\n\t\treturn this._cosignatures;\n\t}\n\n\tset cosignatures(value) {\n\t\tthis._cosignatures = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.transactionsHash.size;\n\t\tsize += 4;\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.transactions, 8, false);\n\t\tsize += arrayHelpers.size(this.cosignatures);\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new AggregateBondedTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst transactionsHash = Hash256.deserialize(view.buffer);\n\t\tview.shiftRight(transactionsHash.size);\n\t\tconst payloadSize = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tconst aggregateTransactionHeaderReserved_1 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== aggregateTransactionHeaderReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${aggregateTransactionHeaderReserved_1})`);\n\t\tconst transactions = arrayHelpers.readVariableSizeElements(view.window(payloadSize), EmbeddedTransactionFactory, 8, false);\n\t\tview.shiftRight(payloadSize);\n\t\tconst cosignatures = arrayHelpers.readArray(view.buffer, Cosignature);\n\t\tview.shiftRight(arrayHelpers.size(cosignatures));\n\n\t\tinstance._transactionsHash = transactionsHash;\n\t\tinstance._transactions = transactions;\n\t\tinstance._cosignatures = cosignatures;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._transactionsHash.serialize());\n\t\tbuffer.write(converter.intToBytes(arrayHelpers.size(this.transactions, 8, false), 4, false)); // bound: payload_size\n\t\tbuffer.write(converter.intToBytes(this._aggregateTransactionHeaderReserved_1, 4, false));\n\t\tarrayHelpers.writeVariableSizeElements(buffer, this._transactions, 8, false);\n\t\tarrayHelpers.writeArray(buffer, this._cosignatures);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `transactionsHash: ${this._transactionsHash.toString()}, `;\n\t\tresult += `transactions: [${this._transactions.map(e => e.toString()).join(',')}], `;\n\t\tresult += `cosignatures: [${this._cosignatures.map(e => e.toString()).join(',')}], `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.transactionsHash = this._transactionsHash.toJson();\n\t\tresult.transactions = this._transactions.map(e => e.toJson());\n\t\tresult.cosignatures = this._cosignatures.map(e => e.toJson());\n\t\treturn result;\n\t}\n}\n\nexport class AggregateBondedTransactionV2 extends Transaction {\n\tstatic TRANSACTION_VERSION = 2;\n\n\tstatic TRANSACTION_TYPE = TransactionType.AGGREGATE_BONDED;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\ttransactionsHash: 'pod:Hash256',\n\t\ttransactions: 'array[EmbeddedTransaction]',\n\t\tcosignatures: 'array[Cosignature]'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = AggregateBondedTransactionV2.TRANSACTION_VERSION;\n\t\tthis._type = AggregateBondedTransactionV2.TRANSACTION_TYPE;\n\t\tthis._transactionsHash = new Hash256();\n\t\tthis._transactions = [];\n\t\tthis._cosignatures = [];\n\t\tthis._aggregateTransactionHeaderReserved_1 = 0; // reserved field\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget transactionsHash() {\n\t\treturn this._transactionsHash;\n\t}\n\n\tset transactionsHash(value) {\n\t\tthis._transactionsHash = value;\n\t}\n\n\tget transactions() {\n\t\treturn this._transactions;\n\t}\n\n\tset transactions(value) {\n\t\tthis._transactions = value;\n\t}\n\n\tget cosignatures() {\n\t\treturn this._cosignatures;\n\t}\n\n\tset cosignatures(value) {\n\t\tthis._cosignatures = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.transactionsHash.size;\n\t\tsize += 4;\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.transactions, 8, false);\n\t\tsize += arrayHelpers.size(this.cosignatures);\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new AggregateBondedTransactionV2();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst transactionsHash = Hash256.deserialize(view.buffer);\n\t\tview.shiftRight(transactionsHash.size);\n\t\tconst payloadSize = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tconst aggregateTransactionHeaderReserved_1 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== aggregateTransactionHeaderReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${aggregateTransactionHeaderReserved_1})`);\n\t\tconst transactions = arrayHelpers.readVariableSizeElements(view.window(payloadSize), EmbeddedTransactionFactory, 8, false);\n\t\tview.shiftRight(payloadSize);\n\t\tconst cosignatures = arrayHelpers.readArray(view.buffer, Cosignature);\n\t\tview.shiftRight(arrayHelpers.size(cosignatures));\n\n\t\tinstance._transactionsHash = transactionsHash;\n\t\tinstance._transactions = transactions;\n\t\tinstance._cosignatures = cosignatures;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._transactionsHash.serialize());\n\t\tbuffer.write(converter.intToBytes(arrayHelpers.size(this.transactions, 8, false), 4, false)); // bound: payload_size\n\t\tbuffer.write(converter.intToBytes(this._aggregateTransactionHeaderReserved_1, 4, false));\n\t\tarrayHelpers.writeVariableSizeElements(buffer, this._transactions, 8, false);\n\t\tarrayHelpers.writeArray(buffer, this._cosignatures);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `transactionsHash: ${this._transactionsHash.toString()}, `;\n\t\tresult += `transactions: [${this._transactions.map(e => e.toString()).join(',')}], `;\n\t\tresult += `cosignatures: [${this._cosignatures.map(e => e.toString()).join(',')}], `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.transactionsHash = this._transactionsHash.toJson();\n\t\tresult.transactions = this._transactions.map(e => e.toJson());\n\t\tresult.cosignatures = this._cosignatures.map(e => e.toJson());\n\t\treturn result;\n\t}\n}\n\nexport class VotingKeyLinkTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.VOTING_KEY_LINK;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\tlinkedPublicKey: 'pod:VotingPublicKey',\n\t\tstartEpoch: 'pod:FinalizationEpoch',\n\t\tendEpoch: 'pod:FinalizationEpoch',\n\t\tlinkAction: 'enum:LinkAction'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = VotingKeyLinkTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = VotingKeyLinkTransactionV1.TRANSACTION_TYPE;\n\t\tthis._linkedPublicKey = new VotingPublicKey();\n\t\tthis._startEpoch = new FinalizationEpoch();\n\t\tthis._endEpoch = new FinalizationEpoch();\n\t\tthis._linkAction = LinkAction.UNLINK;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget linkedPublicKey() {\n\t\treturn this._linkedPublicKey;\n\t}\n\n\tset linkedPublicKey(value) {\n\t\tthis._linkedPublicKey = value;\n\t}\n\n\tget startEpoch() {\n\t\treturn this._startEpoch;\n\t}\n\n\tset startEpoch(value) {\n\t\tthis._startEpoch = value;\n\t}\n\n\tget endEpoch() {\n\t\treturn this._endEpoch;\n\t}\n\n\tset endEpoch(value) {\n\t\tthis._endEpoch = value;\n\t}\n\n\tget linkAction() {\n\t\treturn this._linkAction;\n\t}\n\n\tset linkAction(value) {\n\t\tthis._linkAction = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.linkedPublicKey.size;\n\t\tsize += this.startEpoch.size;\n\t\tsize += this.endEpoch.size;\n\t\tsize += this.linkAction.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new VotingKeyLinkTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst linkedPublicKey = VotingPublicKey.deserialize(view.buffer);\n\t\tview.shiftRight(linkedPublicKey.size);\n\t\tconst startEpoch = FinalizationEpoch.deserializeAligned(view.buffer);\n\t\tview.shiftRight(startEpoch.size);\n\t\tconst endEpoch = FinalizationEpoch.deserializeAligned(view.buffer);\n\t\tview.shiftRight(endEpoch.size);\n\t\tconst linkAction = LinkAction.deserializeAligned(view.buffer);\n\t\tview.shiftRight(linkAction.size);\n\n\t\tinstance._linkedPublicKey = linkedPublicKey;\n\t\tinstance._startEpoch = startEpoch;\n\t\tinstance._endEpoch = endEpoch;\n\t\tinstance._linkAction = linkAction;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._linkedPublicKey.serialize());\n\t\tbuffer.write(this._startEpoch.serialize());\n\t\tbuffer.write(this._endEpoch.serialize());\n\t\tbuffer.write(this._linkAction.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `linkedPublicKey: ${this._linkedPublicKey.toString()}, `;\n\t\tresult += `startEpoch: ${this._startEpoch.toString()}, `;\n\t\tresult += `endEpoch: ${this._endEpoch.toString()}, `;\n\t\tresult += `linkAction: ${this._linkAction.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.linkedPublicKey = this._linkedPublicKey.toJson();\n\t\tresult.startEpoch = this._startEpoch.toJson();\n\t\tresult.endEpoch = this._endEpoch.toJson();\n\t\tresult.linkAction = this._linkAction.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedVotingKeyLinkTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.VOTING_KEY_LINK;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\tlinkedPublicKey: 'pod:VotingPublicKey',\n\t\tstartEpoch: 'pod:FinalizationEpoch',\n\t\tendEpoch: 'pod:FinalizationEpoch',\n\t\tlinkAction: 'enum:LinkAction'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedVotingKeyLinkTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedVotingKeyLinkTransactionV1.TRANSACTION_TYPE;\n\t\tthis._linkedPublicKey = new VotingPublicKey();\n\t\tthis._startEpoch = new FinalizationEpoch();\n\t\tthis._endEpoch = new FinalizationEpoch();\n\t\tthis._linkAction = LinkAction.UNLINK;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget linkedPublicKey() {\n\t\treturn this._linkedPublicKey;\n\t}\n\n\tset linkedPublicKey(value) {\n\t\tthis._linkedPublicKey = value;\n\t}\n\n\tget startEpoch() {\n\t\treturn this._startEpoch;\n\t}\n\n\tset startEpoch(value) {\n\t\tthis._startEpoch = value;\n\t}\n\n\tget endEpoch() {\n\t\treturn this._endEpoch;\n\t}\n\n\tset endEpoch(value) {\n\t\tthis._endEpoch = value;\n\t}\n\n\tget linkAction() {\n\t\treturn this._linkAction;\n\t}\n\n\tset linkAction(value) {\n\t\tthis._linkAction = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.linkedPublicKey.size;\n\t\tsize += this.startEpoch.size;\n\t\tsize += this.endEpoch.size;\n\t\tsize += this.linkAction.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedVotingKeyLinkTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst linkedPublicKey = VotingPublicKey.deserialize(view.buffer);\n\t\tview.shiftRight(linkedPublicKey.size);\n\t\tconst startEpoch = FinalizationEpoch.deserializeAligned(view.buffer);\n\t\tview.shiftRight(startEpoch.size);\n\t\tconst endEpoch = FinalizationEpoch.deserializeAligned(view.buffer);\n\t\tview.shiftRight(endEpoch.size);\n\t\tconst linkAction = LinkAction.deserializeAligned(view.buffer);\n\t\tview.shiftRight(linkAction.size);\n\n\t\tinstance._linkedPublicKey = linkedPublicKey;\n\t\tinstance._startEpoch = startEpoch;\n\t\tinstance._endEpoch = endEpoch;\n\t\tinstance._linkAction = linkAction;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._linkedPublicKey.serialize());\n\t\tbuffer.write(this._startEpoch.serialize());\n\t\tbuffer.write(this._endEpoch.serialize());\n\t\tbuffer.write(this._linkAction.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `linkedPublicKey: ${this._linkedPublicKey.toString()}, `;\n\t\tresult += `startEpoch: ${this._startEpoch.toString()}, `;\n\t\tresult += `endEpoch: ${this._endEpoch.toString()}, `;\n\t\tresult += `linkAction: ${this._linkAction.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.linkedPublicKey = this._linkedPublicKey.toJson();\n\t\tresult.startEpoch = this._startEpoch.toJson();\n\t\tresult.endEpoch = this._endEpoch.toJson();\n\t\tresult.linkAction = this._linkAction.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class VrfKeyLinkTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.VRF_KEY_LINK;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\tlinkedPublicKey: 'pod:PublicKey',\n\t\tlinkAction: 'enum:LinkAction'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = VrfKeyLinkTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = VrfKeyLinkTransactionV1.TRANSACTION_TYPE;\n\t\tthis._linkedPublicKey = new PublicKey();\n\t\tthis._linkAction = LinkAction.UNLINK;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget linkedPublicKey() {\n\t\treturn this._linkedPublicKey;\n\t}\n\n\tset linkedPublicKey(value) {\n\t\tthis._linkedPublicKey = value;\n\t}\n\n\tget linkAction() {\n\t\treturn this._linkAction;\n\t}\n\n\tset linkAction(value) {\n\t\tthis._linkAction = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.linkedPublicKey.size;\n\t\tsize += this.linkAction.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new VrfKeyLinkTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst linkedPublicKey = PublicKey.deserialize(view.buffer);\n\t\tview.shiftRight(linkedPublicKey.size);\n\t\tconst linkAction = LinkAction.deserializeAligned(view.buffer);\n\t\tview.shiftRight(linkAction.size);\n\n\t\tinstance._linkedPublicKey = linkedPublicKey;\n\t\tinstance._linkAction = linkAction;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._linkedPublicKey.serialize());\n\t\tbuffer.write(this._linkAction.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `linkedPublicKey: ${this._linkedPublicKey.toString()}, `;\n\t\tresult += `linkAction: ${this._linkAction.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.linkedPublicKey = this._linkedPublicKey.toJson();\n\t\tresult.linkAction = this._linkAction.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedVrfKeyLinkTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.VRF_KEY_LINK;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\tlinkedPublicKey: 'pod:PublicKey',\n\t\tlinkAction: 'enum:LinkAction'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedVrfKeyLinkTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedVrfKeyLinkTransactionV1.TRANSACTION_TYPE;\n\t\tthis._linkedPublicKey = new PublicKey();\n\t\tthis._linkAction = LinkAction.UNLINK;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget linkedPublicKey() {\n\t\treturn this._linkedPublicKey;\n\t}\n\n\tset linkedPublicKey(value) {\n\t\tthis._linkedPublicKey = value;\n\t}\n\n\tget linkAction() {\n\t\treturn this._linkAction;\n\t}\n\n\tset linkAction(value) {\n\t\tthis._linkAction = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.linkedPublicKey.size;\n\t\tsize += this.linkAction.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedVrfKeyLinkTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst linkedPublicKey = PublicKey.deserialize(view.buffer);\n\t\tview.shiftRight(linkedPublicKey.size);\n\t\tconst linkAction = LinkAction.deserializeAligned(view.buffer);\n\t\tview.shiftRight(linkAction.size);\n\n\t\tinstance._linkedPublicKey = linkedPublicKey;\n\t\tinstance._linkAction = linkAction;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._linkedPublicKey.serialize());\n\t\tbuffer.write(this._linkAction.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `linkedPublicKey: ${this._linkedPublicKey.toString()}, `;\n\t\tresult += `linkAction: ${this._linkAction.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.linkedPublicKey = this._linkedPublicKey.toJson();\n\t\tresult.linkAction = this._linkAction.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class HashLockTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.HASH_LOCK;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\tmosaic: 'struct:UnresolvedMosaic',\n\t\tduration: 'pod:BlockDuration',\n\t\thash: 'pod:Hash256'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = HashLockTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = HashLockTransactionV1.TRANSACTION_TYPE;\n\t\tthis._mosaic = new UnresolvedMosaic();\n\t\tthis._duration = new BlockDuration();\n\t\tthis._hash = new Hash256();\n\t}\n\n\tsort() {\n\t\tthis._mosaic.sort();\n\t}\n\n\tget mosaic() {\n\t\treturn this._mosaic;\n\t}\n\n\tset mosaic(value) {\n\t\tthis._mosaic = value;\n\t}\n\n\tget duration() {\n\t\treturn this._duration;\n\t}\n\n\tset duration(value) {\n\t\tthis._duration = value;\n\t}\n\n\tget hash() {\n\t\treturn this._hash;\n\t}\n\n\tset hash(value) {\n\t\tthis._hash = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.mosaic.size;\n\t\tsize += this.duration.size;\n\t\tsize += this.hash.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new HashLockTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst mosaic = UnresolvedMosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst duration = BlockDuration.deserializeAligned(view.buffer);\n\t\tview.shiftRight(duration.size);\n\t\tconst hash = Hash256.deserialize(view.buffer);\n\t\tview.shiftRight(hash.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._duration = duration;\n\t\tinstance._hash = hash;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._mosaic.serialize());\n\t\tbuffer.write(this._duration.serialize());\n\t\tbuffer.write(this._hash.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `mosaic: ${this._mosaic.toString()}, `;\n\t\tresult += `duration: ${this._duration.toString()}, `;\n\t\tresult += `hash: ${this._hash.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.mosaic = this._mosaic.toJson();\n\t\tresult.duration = this._duration.toJson();\n\t\tresult.hash = this._hash.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedHashLockTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.HASH_LOCK;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\tmosaic: 'struct:UnresolvedMosaic',\n\t\tduration: 'pod:BlockDuration',\n\t\thash: 'pod:Hash256'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedHashLockTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedHashLockTransactionV1.TRANSACTION_TYPE;\n\t\tthis._mosaic = new UnresolvedMosaic();\n\t\tthis._duration = new BlockDuration();\n\t\tthis._hash = new Hash256();\n\t}\n\n\tsort() {\n\t\tthis._mosaic.sort();\n\t}\n\n\tget mosaic() {\n\t\treturn this._mosaic;\n\t}\n\n\tset mosaic(value) {\n\t\tthis._mosaic = value;\n\t}\n\n\tget duration() {\n\t\treturn this._duration;\n\t}\n\n\tset duration(value) {\n\t\tthis._duration = value;\n\t}\n\n\tget hash() {\n\t\treturn this._hash;\n\t}\n\n\tset hash(value) {\n\t\tthis._hash = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.mosaic.size;\n\t\tsize += this.duration.size;\n\t\tsize += this.hash.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedHashLockTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst mosaic = UnresolvedMosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst duration = BlockDuration.deserializeAligned(view.buffer);\n\t\tview.shiftRight(duration.size);\n\t\tconst hash = Hash256.deserialize(view.buffer);\n\t\tview.shiftRight(hash.size);\n\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._duration = duration;\n\t\tinstance._hash = hash;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._mosaic.serialize());\n\t\tbuffer.write(this._duration.serialize());\n\t\tbuffer.write(this._hash.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `mosaic: ${this._mosaic.toString()}, `;\n\t\tresult += `duration: ${this._duration.toString()}, `;\n\t\tresult += `hash: ${this._hash.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.mosaic = this._mosaic.toJson();\n\t\tresult.duration = this._duration.toJson();\n\t\tresult.hash = this._hash.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class LockHashAlgorithm {\n\tstatic SHA3_256 = new LockHashAlgorithm(0);\n\n\tstatic HASH_160 = new LockHashAlgorithm(1);\n\n\tstatic HASH_256 = new LockHashAlgorithm(2);\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n\n\tstatic valueToKey(value) {\n\t\tconst values = [\n\t\t\t0, 1, 2\n\t\t];\n\t\tconst keys = [\n\t\t\t'SHA3_256', 'HASH_160', 'HASH_256'\n\t\t];\n\n\t\tconst index = values.indexOf(value);\n\t\tif (-1 === index)\n\t\t\tthrow RangeError(`invalid enum value ${value}`);\n\n\t\treturn keys[index];\n\t}\n\n\tstatic fromValue(value) {\n\t\treturn LockHashAlgorithm[this.valueToKey(value)];\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 1;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToIntUnaligned(byteArray, 1, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToInt(byteArray, 1, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 1, false);\n\t}\n\n\ttoString() {\n\t\treturn `LockHashAlgorithm.${LockHashAlgorithm.valueToKey(this.value)}`;\n\t}\n\n\ttoJson() {\n\t\treturn this.value;\n\t}\n}\n\nexport class SecretLockTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.SECRET_LOCK;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\trecipientAddress: 'pod:UnresolvedAddress',\n\t\tsecret: 'pod:Hash256',\n\t\tmosaic: 'struct:UnresolvedMosaic',\n\t\tduration: 'pod:BlockDuration',\n\t\thashAlgorithm: 'enum:LockHashAlgorithm'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = SecretLockTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = SecretLockTransactionV1.TRANSACTION_TYPE;\n\t\tthis._recipientAddress = new UnresolvedAddress();\n\t\tthis._secret = new Hash256();\n\t\tthis._mosaic = new UnresolvedMosaic();\n\t\tthis._duration = new BlockDuration();\n\t\tthis._hashAlgorithm = LockHashAlgorithm.SHA3_256;\n\t}\n\n\tsort() {\n\t\tthis._mosaic.sort();\n\t}\n\n\tget recipientAddress() {\n\t\treturn this._recipientAddress;\n\t}\n\n\tset recipientAddress(value) {\n\t\tthis._recipientAddress = value;\n\t}\n\n\tget secret() {\n\t\treturn this._secret;\n\t}\n\n\tset secret(value) {\n\t\tthis._secret = value;\n\t}\n\n\tget mosaic() {\n\t\treturn this._mosaic;\n\t}\n\n\tset mosaic(value) {\n\t\tthis._mosaic = value;\n\t}\n\n\tget duration() {\n\t\treturn this._duration;\n\t}\n\n\tset duration(value) {\n\t\tthis._duration = value;\n\t}\n\n\tget hashAlgorithm() {\n\t\treturn this._hashAlgorithm;\n\t}\n\n\tset hashAlgorithm(value) {\n\t\tthis._hashAlgorithm = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.recipientAddress.size;\n\t\tsize += this.secret.size;\n\t\tsize += this.mosaic.size;\n\t\tsize += this.duration.size;\n\t\tsize += this.hashAlgorithm.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new SecretLockTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst recipientAddress = UnresolvedAddress.deserialize(view.buffer);\n\t\tview.shiftRight(recipientAddress.size);\n\t\tconst secret = Hash256.deserialize(view.buffer);\n\t\tview.shiftRight(secret.size);\n\t\tconst mosaic = UnresolvedMosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst duration = BlockDuration.deserializeAligned(view.buffer);\n\t\tview.shiftRight(duration.size);\n\t\tconst hashAlgorithm = LockHashAlgorithm.deserializeAligned(view.buffer);\n\t\tview.shiftRight(hashAlgorithm.size);\n\n\t\tinstance._recipientAddress = recipientAddress;\n\t\tinstance._secret = secret;\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._duration = duration;\n\t\tinstance._hashAlgorithm = hashAlgorithm;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._recipientAddress.serialize());\n\t\tbuffer.write(this._secret.serialize());\n\t\tbuffer.write(this._mosaic.serialize());\n\t\tbuffer.write(this._duration.serialize());\n\t\tbuffer.write(this._hashAlgorithm.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `recipientAddress: ${this._recipientAddress.toString()}, `;\n\t\tresult += `secret: ${this._secret.toString()}, `;\n\t\tresult += `mosaic: ${this._mosaic.toString()}, `;\n\t\tresult += `duration: ${this._duration.toString()}, `;\n\t\tresult += `hashAlgorithm: ${this._hashAlgorithm.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.recipientAddress = this._recipientAddress.toJson();\n\t\tresult.secret = this._secret.toJson();\n\t\tresult.mosaic = this._mosaic.toJson();\n\t\tresult.duration = this._duration.toJson();\n\t\tresult.hashAlgorithm = this._hashAlgorithm.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedSecretLockTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.SECRET_LOCK;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\trecipientAddress: 'pod:UnresolvedAddress',\n\t\tsecret: 'pod:Hash256',\n\t\tmosaic: 'struct:UnresolvedMosaic',\n\t\tduration: 'pod:BlockDuration',\n\t\thashAlgorithm: 'enum:LockHashAlgorithm'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedSecretLockTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedSecretLockTransactionV1.TRANSACTION_TYPE;\n\t\tthis._recipientAddress = new UnresolvedAddress();\n\t\tthis._secret = new Hash256();\n\t\tthis._mosaic = new UnresolvedMosaic();\n\t\tthis._duration = new BlockDuration();\n\t\tthis._hashAlgorithm = LockHashAlgorithm.SHA3_256;\n\t}\n\n\tsort() {\n\t\tthis._mosaic.sort();\n\t}\n\n\tget recipientAddress() {\n\t\treturn this._recipientAddress;\n\t}\n\n\tset recipientAddress(value) {\n\t\tthis._recipientAddress = value;\n\t}\n\n\tget secret() {\n\t\treturn this._secret;\n\t}\n\n\tset secret(value) {\n\t\tthis._secret = value;\n\t}\n\n\tget mosaic() {\n\t\treturn this._mosaic;\n\t}\n\n\tset mosaic(value) {\n\t\tthis._mosaic = value;\n\t}\n\n\tget duration() {\n\t\treturn this._duration;\n\t}\n\n\tset duration(value) {\n\t\tthis._duration = value;\n\t}\n\n\tget hashAlgorithm() {\n\t\treturn this._hashAlgorithm;\n\t}\n\n\tset hashAlgorithm(value) {\n\t\tthis._hashAlgorithm = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.recipientAddress.size;\n\t\tsize += this.secret.size;\n\t\tsize += this.mosaic.size;\n\t\tsize += this.duration.size;\n\t\tsize += this.hashAlgorithm.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedSecretLockTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst recipientAddress = UnresolvedAddress.deserialize(view.buffer);\n\t\tview.shiftRight(recipientAddress.size);\n\t\tconst secret = Hash256.deserialize(view.buffer);\n\t\tview.shiftRight(secret.size);\n\t\tconst mosaic = UnresolvedMosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\t\tconst duration = BlockDuration.deserializeAligned(view.buffer);\n\t\tview.shiftRight(duration.size);\n\t\tconst hashAlgorithm = LockHashAlgorithm.deserializeAligned(view.buffer);\n\t\tview.shiftRight(hashAlgorithm.size);\n\n\t\tinstance._recipientAddress = recipientAddress;\n\t\tinstance._secret = secret;\n\t\tinstance._mosaic = mosaic;\n\t\tinstance._duration = duration;\n\t\tinstance._hashAlgorithm = hashAlgorithm;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._recipientAddress.serialize());\n\t\tbuffer.write(this._secret.serialize());\n\t\tbuffer.write(this._mosaic.serialize());\n\t\tbuffer.write(this._duration.serialize());\n\t\tbuffer.write(this._hashAlgorithm.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `recipientAddress: ${this._recipientAddress.toString()}, `;\n\t\tresult += `secret: ${this._secret.toString()}, `;\n\t\tresult += `mosaic: ${this._mosaic.toString()}, `;\n\t\tresult += `duration: ${this._duration.toString()}, `;\n\t\tresult += `hashAlgorithm: ${this._hashAlgorithm.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.recipientAddress = this._recipientAddress.toJson();\n\t\tresult.secret = this._secret.toJson();\n\t\tresult.mosaic = this._mosaic.toJson();\n\t\tresult.duration = this._duration.toJson();\n\t\tresult.hashAlgorithm = this._hashAlgorithm.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class SecretProofTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.SECRET_PROOF;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\trecipientAddress: 'pod:UnresolvedAddress',\n\t\tsecret: 'pod:Hash256',\n\t\thashAlgorithm: 'enum:LockHashAlgorithm',\n\t\tproof: 'bytes_array'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = SecretProofTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = SecretProofTransactionV1.TRANSACTION_TYPE;\n\t\tthis._recipientAddress = new UnresolvedAddress();\n\t\tthis._secret = new Hash256();\n\t\tthis._hashAlgorithm = LockHashAlgorithm.SHA3_256;\n\t\tthis._proof = new Uint8Array();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget recipientAddress() {\n\t\treturn this._recipientAddress;\n\t}\n\n\tset recipientAddress(value) {\n\t\tthis._recipientAddress = value;\n\t}\n\n\tget secret() {\n\t\treturn this._secret;\n\t}\n\n\tset secret(value) {\n\t\tthis._secret = value;\n\t}\n\n\tget hashAlgorithm() {\n\t\treturn this._hashAlgorithm;\n\t}\n\n\tset hashAlgorithm(value) {\n\t\tthis._hashAlgorithm = value;\n\t}\n\n\tget proof() {\n\t\treturn this._proof;\n\t}\n\n\tset proof(value) {\n\t\tthis._proof = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.recipientAddress.size;\n\t\tsize += this.secret.size;\n\t\tsize += 2;\n\t\tsize += this.hashAlgorithm.size;\n\t\tsize += this._proof.length;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new SecretProofTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst recipientAddress = UnresolvedAddress.deserialize(view.buffer);\n\t\tview.shiftRight(recipientAddress.size);\n\t\tconst secret = Hash256.deserialize(view.buffer);\n\t\tview.shiftRight(secret.size);\n\t\tconst proofSize = converter.bytesToInt(view.buffer, 2, false);\n\t\tview.shiftRight(2);\n\t\tconst hashAlgorithm = LockHashAlgorithm.deserializeAligned(view.buffer);\n\t\tview.shiftRight(hashAlgorithm.size);\n\t\tconst proof = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, proofSize);\n\t\tview.shiftRight(proofSize);\n\n\t\tinstance._recipientAddress = recipientAddress;\n\t\tinstance._secret = secret;\n\t\tinstance._hashAlgorithm = hashAlgorithm;\n\t\tinstance._proof = proof;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._recipientAddress.serialize());\n\t\tbuffer.write(this._secret.serialize());\n\t\tbuffer.write(converter.intToBytes(this._proof.length, 2, false)); // bound: proof_size\n\t\tbuffer.write(this._hashAlgorithm.serialize());\n\t\tbuffer.write(this._proof);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `recipientAddress: ${this._recipientAddress.toString()}, `;\n\t\tresult += `secret: ${this._secret.toString()}, `;\n\t\tresult += `hashAlgorithm: ${this._hashAlgorithm.toString()}, `;\n\t\tresult += `proof: hex(${converter.uint8ToHex(this._proof)}), `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.recipientAddress = this._recipientAddress.toJson();\n\t\tresult.secret = this._secret.toJson();\n\t\tresult.hashAlgorithm = this._hashAlgorithm.toJson();\n\t\tresult.proof = converter.uint8ToHex(this._proof);\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedSecretProofTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.SECRET_PROOF;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\trecipientAddress: 'pod:UnresolvedAddress',\n\t\tsecret: 'pod:Hash256',\n\t\thashAlgorithm: 'enum:LockHashAlgorithm',\n\t\tproof: 'bytes_array'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedSecretProofTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedSecretProofTransactionV1.TRANSACTION_TYPE;\n\t\tthis._recipientAddress = new UnresolvedAddress();\n\t\tthis._secret = new Hash256();\n\t\tthis._hashAlgorithm = LockHashAlgorithm.SHA3_256;\n\t\tthis._proof = new Uint8Array();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget recipientAddress() {\n\t\treturn this._recipientAddress;\n\t}\n\n\tset recipientAddress(value) {\n\t\tthis._recipientAddress = value;\n\t}\n\n\tget secret() {\n\t\treturn this._secret;\n\t}\n\n\tset secret(value) {\n\t\tthis._secret = value;\n\t}\n\n\tget hashAlgorithm() {\n\t\treturn this._hashAlgorithm;\n\t}\n\n\tset hashAlgorithm(value) {\n\t\tthis._hashAlgorithm = value;\n\t}\n\n\tget proof() {\n\t\treturn this._proof;\n\t}\n\n\tset proof(value) {\n\t\tthis._proof = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.recipientAddress.size;\n\t\tsize += this.secret.size;\n\t\tsize += 2;\n\t\tsize += this.hashAlgorithm.size;\n\t\tsize += this._proof.length;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedSecretProofTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst recipientAddress = UnresolvedAddress.deserialize(view.buffer);\n\t\tview.shiftRight(recipientAddress.size);\n\t\tconst secret = Hash256.deserialize(view.buffer);\n\t\tview.shiftRight(secret.size);\n\t\tconst proofSize = converter.bytesToInt(view.buffer, 2, false);\n\t\tview.shiftRight(2);\n\t\tconst hashAlgorithm = LockHashAlgorithm.deserializeAligned(view.buffer);\n\t\tview.shiftRight(hashAlgorithm.size);\n\t\tconst proof = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, proofSize);\n\t\tview.shiftRight(proofSize);\n\n\t\tinstance._recipientAddress = recipientAddress;\n\t\tinstance._secret = secret;\n\t\tinstance._hashAlgorithm = hashAlgorithm;\n\t\tinstance._proof = proof;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._recipientAddress.serialize());\n\t\tbuffer.write(this._secret.serialize());\n\t\tbuffer.write(converter.intToBytes(this._proof.length, 2, false)); // bound: proof_size\n\t\tbuffer.write(this._hashAlgorithm.serialize());\n\t\tbuffer.write(this._proof);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `recipientAddress: ${this._recipientAddress.toString()}, `;\n\t\tresult += `secret: ${this._secret.toString()}, `;\n\t\tresult += `hashAlgorithm: ${this._hashAlgorithm.toString()}, `;\n\t\tresult += `proof: hex(${converter.uint8ToHex(this._proof)}), `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.recipientAddress = this._recipientAddress.toJson();\n\t\tresult.secret = this._secret.toJson();\n\t\tresult.hashAlgorithm = this._hashAlgorithm.toJson();\n\t\tresult.proof = converter.uint8ToHex(this._proof);\n\t\treturn result;\n\t}\n}\n\nexport class AccountMetadataTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.ACCOUNT_METADATA;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\ttargetAddress: 'pod:UnresolvedAddress',\n\t\tvalue: 'bytes_array'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = AccountMetadataTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = AccountMetadataTransactionV1.TRANSACTION_TYPE;\n\t\tthis._targetAddress = new UnresolvedAddress();\n\t\tthis._scopedMetadataKey = 0n;\n\t\tthis._valueSizeDelta = 0;\n\t\tthis._value = new Uint8Array();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget targetAddress() {\n\t\treturn this._targetAddress;\n\t}\n\n\tset targetAddress(value) {\n\t\tthis._targetAddress = value;\n\t}\n\n\tget scopedMetadataKey() {\n\t\treturn this._scopedMetadataKey;\n\t}\n\n\tset scopedMetadataKey(value) {\n\t\tthis._scopedMetadataKey = value;\n\t}\n\n\tget valueSizeDelta() {\n\t\treturn this._valueSizeDelta;\n\t}\n\n\tset valueSizeDelta(value) {\n\t\tthis._valueSizeDelta = value;\n\t}\n\n\tget value() {\n\t\treturn this._value;\n\t}\n\n\tset value(value) {\n\t\tthis._value = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.targetAddress.size;\n\t\tsize += 8;\n\t\tsize += 2;\n\t\tsize += 2;\n\t\tsize += this._value.length;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new AccountMetadataTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst targetAddress = UnresolvedAddress.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\t\tconst scopedMetadataKey = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst valueSizeDelta = converter.bytesToInt(view.buffer, 2, true);\n\t\tview.shiftRight(2);\n\t\tconst valueSize = converter.bytesToInt(view.buffer, 2, false);\n\t\tview.shiftRight(2);\n\t\tconst value = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, valueSize);\n\t\tview.shiftRight(valueSize);\n\n\t\tinstance._targetAddress = targetAddress;\n\t\tinstance._scopedMetadataKey = scopedMetadataKey;\n\t\tinstance._valueSizeDelta = valueSizeDelta;\n\t\tinstance._value = value;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._targetAddress.serialize());\n\t\tbuffer.write(converter.intToBytes(this._scopedMetadataKey, 8, false));\n\t\tbuffer.write(converter.intToBytes(this._valueSizeDelta, 2, true));\n\t\tbuffer.write(converter.intToBytes(this._value.length, 2, false)); // bound: value_size\n\t\tbuffer.write(this._value);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `targetAddress: ${this._targetAddress.toString()}, `;\n\t\tresult += `scopedMetadataKey: ${'0x'.concat(this._scopedMetadataKey.toString(16))}, `;\n\t\tresult += `valueSizeDelta: ${'0x'.concat(this._valueSizeDelta.toString(16))}, `;\n\t\tresult += `value: hex(${converter.uint8ToHex(this._value)}), `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.targetAddress = this._targetAddress.toJson();\n\t\tresult.scopedMetadataKey = this._scopedMetadataKey.toString();\n\t\tresult.valueSizeDelta = this._valueSizeDelta;\n\t\tresult.value = converter.uint8ToHex(this._value);\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedAccountMetadataTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.ACCOUNT_METADATA;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\ttargetAddress: 'pod:UnresolvedAddress',\n\t\tvalue: 'bytes_array'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedAccountMetadataTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedAccountMetadataTransactionV1.TRANSACTION_TYPE;\n\t\tthis._targetAddress = new UnresolvedAddress();\n\t\tthis._scopedMetadataKey = 0n;\n\t\tthis._valueSizeDelta = 0;\n\t\tthis._value = new Uint8Array();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget targetAddress() {\n\t\treturn this._targetAddress;\n\t}\n\n\tset targetAddress(value) {\n\t\tthis._targetAddress = value;\n\t}\n\n\tget scopedMetadataKey() {\n\t\treturn this._scopedMetadataKey;\n\t}\n\n\tset scopedMetadataKey(value) {\n\t\tthis._scopedMetadataKey = value;\n\t}\n\n\tget valueSizeDelta() {\n\t\treturn this._valueSizeDelta;\n\t}\n\n\tset valueSizeDelta(value) {\n\t\tthis._valueSizeDelta = value;\n\t}\n\n\tget value() {\n\t\treturn this._value;\n\t}\n\n\tset value(value) {\n\t\tthis._value = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.targetAddress.size;\n\t\tsize += 8;\n\t\tsize += 2;\n\t\tsize += 2;\n\t\tsize += this._value.length;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedAccountMetadataTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst targetAddress = UnresolvedAddress.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\t\tconst scopedMetadataKey = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst valueSizeDelta = converter.bytesToInt(view.buffer, 2, true);\n\t\tview.shiftRight(2);\n\t\tconst valueSize = converter.bytesToInt(view.buffer, 2, false);\n\t\tview.shiftRight(2);\n\t\tconst value = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, valueSize);\n\t\tview.shiftRight(valueSize);\n\n\t\tinstance._targetAddress = targetAddress;\n\t\tinstance._scopedMetadataKey = scopedMetadataKey;\n\t\tinstance._valueSizeDelta = valueSizeDelta;\n\t\tinstance._value = value;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._targetAddress.serialize());\n\t\tbuffer.write(converter.intToBytes(this._scopedMetadataKey, 8, false));\n\t\tbuffer.write(converter.intToBytes(this._valueSizeDelta, 2, true));\n\t\tbuffer.write(converter.intToBytes(this._value.length, 2, false)); // bound: value_size\n\t\tbuffer.write(this._value);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `targetAddress: ${this._targetAddress.toString()}, `;\n\t\tresult += `scopedMetadataKey: ${'0x'.concat(this._scopedMetadataKey.toString(16))}, `;\n\t\tresult += `valueSizeDelta: ${'0x'.concat(this._valueSizeDelta.toString(16))}, `;\n\t\tresult += `value: hex(${converter.uint8ToHex(this._value)}), `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.targetAddress = this._targetAddress.toJson();\n\t\tresult.scopedMetadataKey = this._scopedMetadataKey.toString();\n\t\tresult.valueSizeDelta = this._valueSizeDelta;\n\t\tresult.value = converter.uint8ToHex(this._value);\n\t\treturn result;\n\t}\n}\n\nexport class MosaicMetadataTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.MOSAIC_METADATA;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\ttargetAddress: 'pod:UnresolvedAddress',\n\t\ttargetMosaicId: 'pod:UnresolvedMosaicId',\n\t\tvalue: 'bytes_array'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = MosaicMetadataTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = MosaicMetadataTransactionV1.TRANSACTION_TYPE;\n\t\tthis._targetAddress = new UnresolvedAddress();\n\t\tthis._scopedMetadataKey = 0n;\n\t\tthis._targetMosaicId = new UnresolvedMosaicId();\n\t\tthis._valueSizeDelta = 0;\n\t\tthis._value = new Uint8Array();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget targetAddress() {\n\t\treturn this._targetAddress;\n\t}\n\n\tset targetAddress(value) {\n\t\tthis._targetAddress = value;\n\t}\n\n\tget scopedMetadataKey() {\n\t\treturn this._scopedMetadataKey;\n\t}\n\n\tset scopedMetadataKey(value) {\n\t\tthis._scopedMetadataKey = value;\n\t}\n\n\tget targetMosaicId() {\n\t\treturn this._targetMosaicId;\n\t}\n\n\tset targetMosaicId(value) {\n\t\tthis._targetMosaicId = value;\n\t}\n\n\tget valueSizeDelta() {\n\t\treturn this._valueSizeDelta;\n\t}\n\n\tset valueSizeDelta(value) {\n\t\tthis._valueSizeDelta = value;\n\t}\n\n\tget value() {\n\t\treturn this._value;\n\t}\n\n\tset value(value) {\n\t\tthis._value = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.targetAddress.size;\n\t\tsize += 8;\n\t\tsize += this.targetMosaicId.size;\n\t\tsize += 2;\n\t\tsize += 2;\n\t\tsize += this._value.length;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new MosaicMetadataTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst targetAddress = UnresolvedAddress.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\t\tconst scopedMetadataKey = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst targetMosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(targetMosaicId.size);\n\t\tconst valueSizeDelta = converter.bytesToInt(view.buffer, 2, true);\n\t\tview.shiftRight(2);\n\t\tconst valueSize = converter.bytesToInt(view.buffer, 2, false);\n\t\tview.shiftRight(2);\n\t\tconst value = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, valueSize);\n\t\tview.shiftRight(valueSize);\n\n\t\tinstance._targetAddress = targetAddress;\n\t\tinstance._scopedMetadataKey = scopedMetadataKey;\n\t\tinstance._targetMosaicId = targetMosaicId;\n\t\tinstance._valueSizeDelta = valueSizeDelta;\n\t\tinstance._value = value;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._targetAddress.serialize());\n\t\tbuffer.write(converter.intToBytes(this._scopedMetadataKey, 8, false));\n\t\tbuffer.write(this._targetMosaicId.serialize());\n\t\tbuffer.write(converter.intToBytes(this._valueSizeDelta, 2, true));\n\t\tbuffer.write(converter.intToBytes(this._value.length, 2, false)); // bound: value_size\n\t\tbuffer.write(this._value);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `targetAddress: ${this._targetAddress.toString()}, `;\n\t\tresult += `scopedMetadataKey: ${'0x'.concat(this._scopedMetadataKey.toString(16))}, `;\n\t\tresult += `targetMosaicId: ${this._targetMosaicId.toString()}, `;\n\t\tresult += `valueSizeDelta: ${'0x'.concat(this._valueSizeDelta.toString(16))}, `;\n\t\tresult += `value: hex(${converter.uint8ToHex(this._value)}), `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.targetAddress = this._targetAddress.toJson();\n\t\tresult.scopedMetadataKey = this._scopedMetadataKey.toString();\n\t\tresult.targetMosaicId = this._targetMosaicId.toJson();\n\t\tresult.valueSizeDelta = this._valueSizeDelta;\n\t\tresult.value = converter.uint8ToHex(this._value);\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedMosaicMetadataTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.MOSAIC_METADATA;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\ttargetAddress: 'pod:UnresolvedAddress',\n\t\ttargetMosaicId: 'pod:UnresolvedMosaicId',\n\t\tvalue: 'bytes_array'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedMosaicMetadataTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedMosaicMetadataTransactionV1.TRANSACTION_TYPE;\n\t\tthis._targetAddress = new UnresolvedAddress();\n\t\tthis._scopedMetadataKey = 0n;\n\t\tthis._targetMosaicId = new UnresolvedMosaicId();\n\t\tthis._valueSizeDelta = 0;\n\t\tthis._value = new Uint8Array();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget targetAddress() {\n\t\treturn this._targetAddress;\n\t}\n\n\tset targetAddress(value) {\n\t\tthis._targetAddress = value;\n\t}\n\n\tget scopedMetadataKey() {\n\t\treturn this._scopedMetadataKey;\n\t}\n\n\tset scopedMetadataKey(value) {\n\t\tthis._scopedMetadataKey = value;\n\t}\n\n\tget targetMosaicId() {\n\t\treturn this._targetMosaicId;\n\t}\n\n\tset targetMosaicId(value) {\n\t\tthis._targetMosaicId = value;\n\t}\n\n\tget valueSizeDelta() {\n\t\treturn this._valueSizeDelta;\n\t}\n\n\tset valueSizeDelta(value) {\n\t\tthis._valueSizeDelta = value;\n\t}\n\n\tget value() {\n\t\treturn this._value;\n\t}\n\n\tset value(value) {\n\t\tthis._value = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.targetAddress.size;\n\t\tsize += 8;\n\t\tsize += this.targetMosaicId.size;\n\t\tsize += 2;\n\t\tsize += 2;\n\t\tsize += this._value.length;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedMosaicMetadataTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst targetAddress = UnresolvedAddress.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\t\tconst scopedMetadataKey = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst targetMosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(targetMosaicId.size);\n\t\tconst valueSizeDelta = converter.bytesToInt(view.buffer, 2, true);\n\t\tview.shiftRight(2);\n\t\tconst valueSize = converter.bytesToInt(view.buffer, 2, false);\n\t\tview.shiftRight(2);\n\t\tconst value = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, valueSize);\n\t\tview.shiftRight(valueSize);\n\n\t\tinstance._targetAddress = targetAddress;\n\t\tinstance._scopedMetadataKey = scopedMetadataKey;\n\t\tinstance._targetMosaicId = targetMosaicId;\n\t\tinstance._valueSizeDelta = valueSizeDelta;\n\t\tinstance._value = value;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._targetAddress.serialize());\n\t\tbuffer.write(converter.intToBytes(this._scopedMetadataKey, 8, false));\n\t\tbuffer.write(this._targetMosaicId.serialize());\n\t\tbuffer.write(converter.intToBytes(this._valueSizeDelta, 2, true));\n\t\tbuffer.write(converter.intToBytes(this._value.length, 2, false)); // bound: value_size\n\t\tbuffer.write(this._value);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `targetAddress: ${this._targetAddress.toString()}, `;\n\t\tresult += `scopedMetadataKey: ${'0x'.concat(this._scopedMetadataKey.toString(16))}, `;\n\t\tresult += `targetMosaicId: ${this._targetMosaicId.toString()}, `;\n\t\tresult += `valueSizeDelta: ${'0x'.concat(this._valueSizeDelta.toString(16))}, `;\n\t\tresult += `value: hex(${converter.uint8ToHex(this._value)}), `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.targetAddress = this._targetAddress.toJson();\n\t\tresult.scopedMetadataKey = this._scopedMetadataKey.toString();\n\t\tresult.targetMosaicId = this._targetMosaicId.toJson();\n\t\tresult.valueSizeDelta = this._valueSizeDelta;\n\t\tresult.value = converter.uint8ToHex(this._value);\n\t\treturn result;\n\t}\n}\n\nexport class NamespaceMetadataTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.NAMESPACE_METADATA;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\ttargetAddress: 'pod:UnresolvedAddress',\n\t\ttargetNamespaceId: 'pod:NamespaceId',\n\t\tvalue: 'bytes_array'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = NamespaceMetadataTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = NamespaceMetadataTransactionV1.TRANSACTION_TYPE;\n\t\tthis._targetAddress = new UnresolvedAddress();\n\t\tthis._scopedMetadataKey = 0n;\n\t\tthis._targetNamespaceId = new NamespaceId();\n\t\tthis._valueSizeDelta = 0;\n\t\tthis._value = new Uint8Array();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget targetAddress() {\n\t\treturn this._targetAddress;\n\t}\n\n\tset targetAddress(value) {\n\t\tthis._targetAddress = value;\n\t}\n\n\tget scopedMetadataKey() {\n\t\treturn this._scopedMetadataKey;\n\t}\n\n\tset scopedMetadataKey(value) {\n\t\tthis._scopedMetadataKey = value;\n\t}\n\n\tget targetNamespaceId() {\n\t\treturn this._targetNamespaceId;\n\t}\n\n\tset targetNamespaceId(value) {\n\t\tthis._targetNamespaceId = value;\n\t}\n\n\tget valueSizeDelta() {\n\t\treturn this._valueSizeDelta;\n\t}\n\n\tset valueSizeDelta(value) {\n\t\tthis._valueSizeDelta = value;\n\t}\n\n\tget value() {\n\t\treturn this._value;\n\t}\n\n\tset value(value) {\n\t\tthis._value = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.targetAddress.size;\n\t\tsize += 8;\n\t\tsize += this.targetNamespaceId.size;\n\t\tsize += 2;\n\t\tsize += 2;\n\t\tsize += this._value.length;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new NamespaceMetadataTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst targetAddress = UnresolvedAddress.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\t\tconst scopedMetadataKey = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst targetNamespaceId = NamespaceId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(targetNamespaceId.size);\n\t\tconst valueSizeDelta = converter.bytesToInt(view.buffer, 2, true);\n\t\tview.shiftRight(2);\n\t\tconst valueSize = converter.bytesToInt(view.buffer, 2, false);\n\t\tview.shiftRight(2);\n\t\tconst value = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, valueSize);\n\t\tview.shiftRight(valueSize);\n\n\t\tinstance._targetAddress = targetAddress;\n\t\tinstance._scopedMetadataKey = scopedMetadataKey;\n\t\tinstance._targetNamespaceId = targetNamespaceId;\n\t\tinstance._valueSizeDelta = valueSizeDelta;\n\t\tinstance._value = value;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._targetAddress.serialize());\n\t\tbuffer.write(converter.intToBytes(this._scopedMetadataKey, 8, false));\n\t\tbuffer.write(this._targetNamespaceId.serialize());\n\t\tbuffer.write(converter.intToBytes(this._valueSizeDelta, 2, true));\n\t\tbuffer.write(converter.intToBytes(this._value.length, 2, false)); // bound: value_size\n\t\tbuffer.write(this._value);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `targetAddress: ${this._targetAddress.toString()}, `;\n\t\tresult += `scopedMetadataKey: ${'0x'.concat(this._scopedMetadataKey.toString(16))}, `;\n\t\tresult += `targetNamespaceId: ${this._targetNamespaceId.toString()}, `;\n\t\tresult += `valueSizeDelta: ${'0x'.concat(this._valueSizeDelta.toString(16))}, `;\n\t\tresult += `value: hex(${converter.uint8ToHex(this._value)}), `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.targetAddress = this._targetAddress.toJson();\n\t\tresult.scopedMetadataKey = this._scopedMetadataKey.toString();\n\t\tresult.targetNamespaceId = this._targetNamespaceId.toJson();\n\t\tresult.valueSizeDelta = this._valueSizeDelta;\n\t\tresult.value = converter.uint8ToHex(this._value);\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedNamespaceMetadataTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.NAMESPACE_METADATA;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\ttargetAddress: 'pod:UnresolvedAddress',\n\t\ttargetNamespaceId: 'pod:NamespaceId',\n\t\tvalue: 'bytes_array'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedNamespaceMetadataTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedNamespaceMetadataTransactionV1.TRANSACTION_TYPE;\n\t\tthis._targetAddress = new UnresolvedAddress();\n\t\tthis._scopedMetadataKey = 0n;\n\t\tthis._targetNamespaceId = new NamespaceId();\n\t\tthis._valueSizeDelta = 0;\n\t\tthis._value = new Uint8Array();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget targetAddress() {\n\t\treturn this._targetAddress;\n\t}\n\n\tset targetAddress(value) {\n\t\tthis._targetAddress = value;\n\t}\n\n\tget scopedMetadataKey() {\n\t\treturn this._scopedMetadataKey;\n\t}\n\n\tset scopedMetadataKey(value) {\n\t\tthis._scopedMetadataKey = value;\n\t}\n\n\tget targetNamespaceId() {\n\t\treturn this._targetNamespaceId;\n\t}\n\n\tset targetNamespaceId(value) {\n\t\tthis._targetNamespaceId = value;\n\t}\n\n\tget valueSizeDelta() {\n\t\treturn this._valueSizeDelta;\n\t}\n\n\tset valueSizeDelta(value) {\n\t\tthis._valueSizeDelta = value;\n\t}\n\n\tget value() {\n\t\treturn this._value;\n\t}\n\n\tset value(value) {\n\t\tthis._value = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.targetAddress.size;\n\t\tsize += 8;\n\t\tsize += this.targetNamespaceId.size;\n\t\tsize += 2;\n\t\tsize += 2;\n\t\tsize += this._value.length;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedNamespaceMetadataTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst targetAddress = UnresolvedAddress.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\t\tconst scopedMetadataKey = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst targetNamespaceId = NamespaceId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(targetNamespaceId.size);\n\t\tconst valueSizeDelta = converter.bytesToInt(view.buffer, 2, true);\n\t\tview.shiftRight(2);\n\t\tconst valueSize = converter.bytesToInt(view.buffer, 2, false);\n\t\tview.shiftRight(2);\n\t\tconst value = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, valueSize);\n\t\tview.shiftRight(valueSize);\n\n\t\tinstance._targetAddress = targetAddress;\n\t\tinstance._scopedMetadataKey = scopedMetadataKey;\n\t\tinstance._targetNamespaceId = targetNamespaceId;\n\t\tinstance._valueSizeDelta = valueSizeDelta;\n\t\tinstance._value = value;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._targetAddress.serialize());\n\t\tbuffer.write(converter.intToBytes(this._scopedMetadataKey, 8, false));\n\t\tbuffer.write(this._targetNamespaceId.serialize());\n\t\tbuffer.write(converter.intToBytes(this._valueSizeDelta, 2, true));\n\t\tbuffer.write(converter.intToBytes(this._value.length, 2, false)); // bound: value_size\n\t\tbuffer.write(this._value);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `targetAddress: ${this._targetAddress.toString()}, `;\n\t\tresult += `scopedMetadataKey: ${'0x'.concat(this._scopedMetadataKey.toString(16))}, `;\n\t\tresult += `targetNamespaceId: ${this._targetNamespaceId.toString()}, `;\n\t\tresult += `valueSizeDelta: ${'0x'.concat(this._valueSizeDelta.toString(16))}, `;\n\t\tresult += `value: hex(${converter.uint8ToHex(this._value)}), `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.targetAddress = this._targetAddress.toJson();\n\t\tresult.scopedMetadataKey = this._scopedMetadataKey.toString();\n\t\tresult.targetNamespaceId = this._targetNamespaceId.toJson();\n\t\tresult.valueSizeDelta = this._valueSizeDelta;\n\t\tresult.value = converter.uint8ToHex(this._value);\n\t\treturn result;\n\t}\n}\n\nexport class MosaicNonce extends BaseValue {\n\tstatic SIZE = 4;\n\n\tconstructor(mosaicNonce = 0) {\n\t\tsuper(MosaicNonce.SIZE, mosaicNonce);\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new MosaicNonce(converter.bytesToIntUnaligned(byteArray, 4, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new MosaicNonce(converter.bytesToInt(byteArray, 4, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 4, false);\n\t}\n}\n\nexport class MosaicFlags {\n\tstatic NONE = new MosaicFlags(0);\n\n\tstatic SUPPLY_MUTABLE = new MosaicFlags(1);\n\n\tstatic TRANSFERABLE = new MosaicFlags(2);\n\n\tstatic RESTRICTABLE = new MosaicFlags(4);\n\n\tstatic REVOKABLE = new MosaicFlags(8);\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n\n\thas(flag) {\n\t\treturn 0 !== (this.value & flag);\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 1;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new MosaicFlags(converter.bytesToIntUnaligned(byteArray, 1, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new MosaicFlags(converter.bytesToInt(byteArray, 1, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 1, false);\n\t}\n\n\ttoString() {\n\t\tconst values = [\n\t\t\t0, 1, 2, 4, 8\n\t\t];\n\t\tconst keys = [\n\t\t\t'NONE', 'SUPPLY_MUTABLE', 'TRANSFERABLE', 'RESTRICTABLE', 'REVOKABLE'\n\t\t];\n\n\t\tif (0 === this.value) {\n\t\t\tconst index = values.indexOf(this.value);\n\t\t\treturn `MosaicFlags.${keys[index]}`;\n\t\t}\n\n\t\tconst positions = values.map(flag => (this.value & flag)).filter(n => n).map(n => values.indexOf(n));\n\t\treturn positions.map(n => `MosaicFlags.${keys[n]}`).join('|');\n\t}\n\n\ttoJson() {\n\t\treturn this.value;\n\t}\n}\n\nexport class MosaicSupplyChangeAction {\n\tstatic DECREASE = new MosaicSupplyChangeAction(0);\n\n\tstatic INCREASE = new MosaicSupplyChangeAction(1);\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n\n\tstatic valueToKey(value) {\n\t\tconst values = [\n\t\t\t0, 1\n\t\t];\n\t\tconst keys = [\n\t\t\t'DECREASE', 'INCREASE'\n\t\t];\n\n\t\tconst index = values.indexOf(value);\n\t\tif (-1 === index)\n\t\t\tthrow RangeError(`invalid enum value ${value}`);\n\n\t\treturn keys[index];\n\t}\n\n\tstatic fromValue(value) {\n\t\treturn MosaicSupplyChangeAction[this.valueToKey(value)];\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 1;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToIntUnaligned(byteArray, 1, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToInt(byteArray, 1, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 1, false);\n\t}\n\n\ttoString() {\n\t\treturn `MosaicSupplyChangeAction.${MosaicSupplyChangeAction.valueToKey(this.value)}`;\n\t}\n\n\ttoJson() {\n\t\treturn this.value;\n\t}\n}\n\nexport class MosaicDefinitionTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.MOSAIC_DEFINITION;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\tid: 'pod:MosaicId',\n\t\tduration: 'pod:BlockDuration',\n\t\tnonce: 'pod:MosaicNonce',\n\t\tflags: 'enum:MosaicFlags'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = MosaicDefinitionTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = MosaicDefinitionTransactionV1.TRANSACTION_TYPE;\n\t\tthis._id = new MosaicId();\n\t\tthis._duration = new BlockDuration();\n\t\tthis._nonce = new MosaicNonce();\n\t\tthis._flags = MosaicFlags.NONE;\n\t\tthis._divisibility = 0;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget id() {\n\t\treturn this._id;\n\t}\n\n\tset id(value) {\n\t\tthis._id = value;\n\t}\n\n\tget duration() {\n\t\treturn this._duration;\n\t}\n\n\tset duration(value) {\n\t\tthis._duration = value;\n\t}\n\n\tget nonce() {\n\t\treturn this._nonce;\n\t}\n\n\tset nonce(value) {\n\t\tthis._nonce = value;\n\t}\n\n\tget flags() {\n\t\treturn this._flags;\n\t}\n\n\tset flags(value) {\n\t\tthis._flags = value;\n\t}\n\n\tget divisibility() {\n\t\treturn this._divisibility;\n\t}\n\n\tset divisibility(value) {\n\t\tthis._divisibility = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.id.size;\n\t\tsize += this.duration.size;\n\t\tsize += this.nonce.size;\n\t\tsize += this.flags.size;\n\t\tsize += 1;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new MosaicDefinitionTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst id = MosaicId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(id.size);\n\t\tconst duration = BlockDuration.deserializeAligned(view.buffer);\n\t\tview.shiftRight(duration.size);\n\t\tconst nonce = MosaicNonce.deserializeAligned(view.buffer);\n\t\tview.shiftRight(nonce.size);\n\t\tconst flags = MosaicFlags.deserializeAligned(view.buffer);\n\t\tview.shiftRight(flags.size);\n\t\tconst divisibility = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\n\t\tinstance._id = id;\n\t\tinstance._duration = duration;\n\t\tinstance._nonce = nonce;\n\t\tinstance._flags = flags;\n\t\tinstance._divisibility = divisibility;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._id.serialize());\n\t\tbuffer.write(this._duration.serialize());\n\t\tbuffer.write(this._nonce.serialize());\n\t\tbuffer.write(this._flags.serialize());\n\t\tbuffer.write(converter.intToBytes(this._divisibility, 1, false));\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `id: ${this._id.toString()}, `;\n\t\tresult += `duration: ${this._duration.toString()}, `;\n\t\tresult += `nonce: ${this._nonce.toString()}, `;\n\t\tresult += `flags: ${this._flags.toString()}, `;\n\t\tresult += `divisibility: ${'0x'.concat(this._divisibility.toString(16))}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.id = this._id.toJson();\n\t\tresult.duration = this._duration.toJson();\n\t\tresult.nonce = this._nonce.toJson();\n\t\tresult.flags = this._flags.toJson();\n\t\tresult.divisibility = this._divisibility;\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedMosaicDefinitionTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.MOSAIC_DEFINITION;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\tid: 'pod:MosaicId',\n\t\tduration: 'pod:BlockDuration',\n\t\tnonce: 'pod:MosaicNonce',\n\t\tflags: 'enum:MosaicFlags'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedMosaicDefinitionTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedMosaicDefinitionTransactionV1.TRANSACTION_TYPE;\n\t\tthis._id = new MosaicId();\n\t\tthis._duration = new BlockDuration();\n\t\tthis._nonce = new MosaicNonce();\n\t\tthis._flags = MosaicFlags.NONE;\n\t\tthis._divisibility = 0;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget id() {\n\t\treturn this._id;\n\t}\n\n\tset id(value) {\n\t\tthis._id = value;\n\t}\n\n\tget duration() {\n\t\treturn this._duration;\n\t}\n\n\tset duration(value) {\n\t\tthis._duration = value;\n\t}\n\n\tget nonce() {\n\t\treturn this._nonce;\n\t}\n\n\tset nonce(value) {\n\t\tthis._nonce = value;\n\t}\n\n\tget flags() {\n\t\treturn this._flags;\n\t}\n\n\tset flags(value) {\n\t\tthis._flags = value;\n\t}\n\n\tget divisibility() {\n\t\treturn this._divisibility;\n\t}\n\n\tset divisibility(value) {\n\t\tthis._divisibility = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.id.size;\n\t\tsize += this.duration.size;\n\t\tsize += this.nonce.size;\n\t\tsize += this.flags.size;\n\t\tsize += 1;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedMosaicDefinitionTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst id = MosaicId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(id.size);\n\t\tconst duration = BlockDuration.deserializeAligned(view.buffer);\n\t\tview.shiftRight(duration.size);\n\t\tconst nonce = MosaicNonce.deserializeAligned(view.buffer);\n\t\tview.shiftRight(nonce.size);\n\t\tconst flags = MosaicFlags.deserializeAligned(view.buffer);\n\t\tview.shiftRight(flags.size);\n\t\tconst divisibility = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\n\t\tinstance._id = id;\n\t\tinstance._duration = duration;\n\t\tinstance._nonce = nonce;\n\t\tinstance._flags = flags;\n\t\tinstance._divisibility = divisibility;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._id.serialize());\n\t\tbuffer.write(this._duration.serialize());\n\t\tbuffer.write(this._nonce.serialize());\n\t\tbuffer.write(this._flags.serialize());\n\t\tbuffer.write(converter.intToBytes(this._divisibility, 1, false));\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `id: ${this._id.toString()}, `;\n\t\tresult += `duration: ${this._duration.toString()}, `;\n\t\tresult += `nonce: ${this._nonce.toString()}, `;\n\t\tresult += `flags: ${this._flags.toString()}, `;\n\t\tresult += `divisibility: ${'0x'.concat(this._divisibility.toString(16))}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.id = this._id.toJson();\n\t\tresult.duration = this._duration.toJson();\n\t\tresult.nonce = this._nonce.toJson();\n\t\tresult.flags = this._flags.toJson();\n\t\tresult.divisibility = this._divisibility;\n\t\treturn result;\n\t}\n}\n\nexport class MosaicSupplyChangeTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.MOSAIC_SUPPLY_CHANGE;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\tmosaicId: 'pod:UnresolvedMosaicId',\n\t\tdelta: 'pod:Amount',\n\t\taction: 'enum:MosaicSupplyChangeAction'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = MosaicSupplyChangeTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = MosaicSupplyChangeTransactionV1.TRANSACTION_TYPE;\n\t\tthis._mosaicId = new UnresolvedMosaicId();\n\t\tthis._delta = new Amount();\n\t\tthis._action = MosaicSupplyChangeAction.DECREASE;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget mosaicId() {\n\t\treturn this._mosaicId;\n\t}\n\n\tset mosaicId(value) {\n\t\tthis._mosaicId = value;\n\t}\n\n\tget delta() {\n\t\treturn this._delta;\n\t}\n\n\tset delta(value) {\n\t\tthis._delta = value;\n\t}\n\n\tget action() {\n\t\treturn this._action;\n\t}\n\n\tset action(value) {\n\t\tthis._action = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.mosaicId.size;\n\t\tsize += this.delta.size;\n\t\tsize += this.action.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new MosaicSupplyChangeTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst mosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(mosaicId.size);\n\t\tconst delta = Amount.deserializeAligned(view.buffer);\n\t\tview.shiftRight(delta.size);\n\t\tconst action = MosaicSupplyChangeAction.deserializeAligned(view.buffer);\n\t\tview.shiftRight(action.size);\n\n\t\tinstance._mosaicId = mosaicId;\n\t\tinstance._delta = delta;\n\t\tinstance._action = action;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._mosaicId.serialize());\n\t\tbuffer.write(this._delta.serialize());\n\t\tbuffer.write(this._action.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `mosaicId: ${this._mosaicId.toString()}, `;\n\t\tresult += `delta: ${this._delta.toString()}, `;\n\t\tresult += `action: ${this._action.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.mosaicId = this._mosaicId.toJson();\n\t\tresult.delta = this._delta.toJson();\n\t\tresult.action = this._action.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedMosaicSupplyChangeTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.MOSAIC_SUPPLY_CHANGE;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\tmosaicId: 'pod:UnresolvedMosaicId',\n\t\tdelta: 'pod:Amount',\n\t\taction: 'enum:MosaicSupplyChangeAction'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedMosaicSupplyChangeTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedMosaicSupplyChangeTransactionV1.TRANSACTION_TYPE;\n\t\tthis._mosaicId = new UnresolvedMosaicId();\n\t\tthis._delta = new Amount();\n\t\tthis._action = MosaicSupplyChangeAction.DECREASE;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget mosaicId() {\n\t\treturn this._mosaicId;\n\t}\n\n\tset mosaicId(value) {\n\t\tthis._mosaicId = value;\n\t}\n\n\tget delta() {\n\t\treturn this._delta;\n\t}\n\n\tset delta(value) {\n\t\tthis._delta = value;\n\t}\n\n\tget action() {\n\t\treturn this._action;\n\t}\n\n\tset action(value) {\n\t\tthis._action = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.mosaicId.size;\n\t\tsize += this.delta.size;\n\t\tsize += this.action.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedMosaicSupplyChangeTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst mosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(mosaicId.size);\n\t\tconst delta = Amount.deserializeAligned(view.buffer);\n\t\tview.shiftRight(delta.size);\n\t\tconst action = MosaicSupplyChangeAction.deserializeAligned(view.buffer);\n\t\tview.shiftRight(action.size);\n\n\t\tinstance._mosaicId = mosaicId;\n\t\tinstance._delta = delta;\n\t\tinstance._action = action;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._mosaicId.serialize());\n\t\tbuffer.write(this._delta.serialize());\n\t\tbuffer.write(this._action.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `mosaicId: ${this._mosaicId.toString()}, `;\n\t\tresult += `delta: ${this._delta.toString()}, `;\n\t\tresult += `action: ${this._action.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.mosaicId = this._mosaicId.toJson();\n\t\tresult.delta = this._delta.toJson();\n\t\tresult.action = this._action.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class MosaicSupplyRevocationTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.MOSAIC_SUPPLY_REVOCATION;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\tsourceAddress: 'pod:UnresolvedAddress',\n\t\tmosaic: 'struct:UnresolvedMosaic'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = MosaicSupplyRevocationTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = MosaicSupplyRevocationTransactionV1.TRANSACTION_TYPE;\n\t\tthis._sourceAddress = new UnresolvedAddress();\n\t\tthis._mosaic = new UnresolvedMosaic();\n\t}\n\n\tsort() {\n\t\tthis._mosaic.sort();\n\t}\n\n\tget sourceAddress() {\n\t\treturn this._sourceAddress;\n\t}\n\n\tset sourceAddress(value) {\n\t\tthis._sourceAddress = value;\n\t}\n\n\tget mosaic() {\n\t\treturn this._mosaic;\n\t}\n\n\tset mosaic(value) {\n\t\tthis._mosaic = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.sourceAddress.size;\n\t\tsize += this.mosaic.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new MosaicSupplyRevocationTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst sourceAddress = UnresolvedAddress.deserialize(view.buffer);\n\t\tview.shiftRight(sourceAddress.size);\n\t\tconst mosaic = UnresolvedMosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\n\t\tinstance._sourceAddress = sourceAddress;\n\t\tinstance._mosaic = mosaic;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._sourceAddress.serialize());\n\t\tbuffer.write(this._mosaic.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `sourceAddress: ${this._sourceAddress.toString()}, `;\n\t\tresult += `mosaic: ${this._mosaic.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.sourceAddress = this._sourceAddress.toJson();\n\t\tresult.mosaic = this._mosaic.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedMosaicSupplyRevocationTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.MOSAIC_SUPPLY_REVOCATION;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\tsourceAddress: 'pod:UnresolvedAddress',\n\t\tmosaic: 'struct:UnresolvedMosaic'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedMosaicSupplyRevocationTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedMosaicSupplyRevocationTransactionV1.TRANSACTION_TYPE;\n\t\tthis._sourceAddress = new UnresolvedAddress();\n\t\tthis._mosaic = new UnresolvedMosaic();\n\t}\n\n\tsort() {\n\t\tthis._mosaic.sort();\n\t}\n\n\tget sourceAddress() {\n\t\treturn this._sourceAddress;\n\t}\n\n\tset sourceAddress(value) {\n\t\tthis._sourceAddress = value;\n\t}\n\n\tget mosaic() {\n\t\treturn this._mosaic;\n\t}\n\n\tset mosaic(value) {\n\t\tthis._mosaic = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.sourceAddress.size;\n\t\tsize += this.mosaic.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedMosaicSupplyRevocationTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst sourceAddress = UnresolvedAddress.deserialize(view.buffer);\n\t\tview.shiftRight(sourceAddress.size);\n\t\tconst mosaic = UnresolvedMosaic.deserialize(view.buffer);\n\t\tview.shiftRight(mosaic.size);\n\n\t\tinstance._sourceAddress = sourceAddress;\n\t\tinstance._mosaic = mosaic;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._sourceAddress.serialize());\n\t\tbuffer.write(this._mosaic.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `sourceAddress: ${this._sourceAddress.toString()}, `;\n\t\tresult += `mosaic: ${this._mosaic.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.sourceAddress = this._sourceAddress.toJson();\n\t\tresult.mosaic = this._mosaic.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class MultisigAccountModificationTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.MULTISIG_ACCOUNT_MODIFICATION;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\taddressAdditions: 'array[UnresolvedAddress]',\n\t\taddressDeletions: 'array[UnresolvedAddress]'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = MultisigAccountModificationTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = MultisigAccountModificationTransactionV1.TRANSACTION_TYPE;\n\t\tthis._minRemovalDelta = 0;\n\t\tthis._minApprovalDelta = 0;\n\t\tthis._addressAdditions = [];\n\t\tthis._addressDeletions = [];\n\t\tthis._multisigAccountModificationTransactionBodyReserved_1 = 0; // reserved field\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget minRemovalDelta() {\n\t\treturn this._minRemovalDelta;\n\t}\n\n\tset minRemovalDelta(value) {\n\t\tthis._minRemovalDelta = value;\n\t}\n\n\tget minApprovalDelta() {\n\t\treturn this._minApprovalDelta;\n\t}\n\n\tset minApprovalDelta(value) {\n\t\tthis._minApprovalDelta = value;\n\t}\n\n\tget addressAdditions() {\n\t\treturn this._addressAdditions;\n\t}\n\n\tset addressAdditions(value) {\n\t\tthis._addressAdditions = value;\n\t}\n\n\tget addressDeletions() {\n\t\treturn this._addressDeletions;\n\t}\n\n\tset addressDeletions(value) {\n\t\tthis._addressDeletions = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += 1;\n\t\tsize += 1;\n\t\tsize += 1;\n\t\tsize += 1;\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.addressAdditions);\n\t\tsize += arrayHelpers.size(this.addressDeletions);\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new MultisigAccountModificationTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst minRemovalDelta = converter.bytesToInt(view.buffer, 1, true);\n\t\tview.shiftRight(1);\n\t\tconst minApprovalDelta = converter.bytesToInt(view.buffer, 1, true);\n\t\tview.shiftRight(1);\n\t\tconst addressAdditionsCount = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst addressDeletionsCount = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst multisigAccountModificationTransactionBodyReserved_1 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== multisigAccountModificationTransactionBodyReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${multisigAccountModificationTransactionBodyReserved_1})`);\n\t\tconst addressAdditions = arrayHelpers.readArrayCount(view.buffer, UnresolvedAddress, addressAdditionsCount);\n\t\tview.shiftRight(arrayHelpers.size(addressAdditions));\n\t\tconst addressDeletions = arrayHelpers.readArrayCount(view.buffer, UnresolvedAddress, addressDeletionsCount);\n\t\tview.shiftRight(arrayHelpers.size(addressDeletions));\n\n\t\tinstance._minRemovalDelta = minRemovalDelta;\n\t\tinstance._minApprovalDelta = minApprovalDelta;\n\t\tinstance._addressAdditions = addressAdditions;\n\t\tinstance._addressDeletions = addressDeletions;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(converter.intToBytes(this._minRemovalDelta, 1, true));\n\t\tbuffer.write(converter.intToBytes(this._minApprovalDelta, 1, true));\n\t\tbuffer.write(converter.intToBytes(this._addressAdditions.length, 1, false)); // bound: address_additions_count\n\t\tbuffer.write(converter.intToBytes(this._addressDeletions.length, 1, false)); // bound: address_deletions_count\n\t\tbuffer.write(converter.intToBytes(this._multisigAccountModificationTransactionBodyReserved_1, 4, false));\n\t\tarrayHelpers.writeArray(buffer, this._addressAdditions);\n\t\tarrayHelpers.writeArray(buffer, this._addressDeletions);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `minRemovalDelta: ${'0x'.concat(this._minRemovalDelta.toString(16))}, `;\n\t\tresult += `minApprovalDelta: ${'0x'.concat(this._minApprovalDelta.toString(16))}, `;\n\t\tresult += `addressAdditions: [${this._addressAdditions.map(e => e.toString()).join(',')}], `;\n\t\tresult += `addressDeletions: [${this._addressDeletions.map(e => e.toString()).join(',')}], `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.minRemovalDelta = this._minRemovalDelta;\n\t\tresult.minApprovalDelta = this._minApprovalDelta;\n\t\tresult.addressAdditions = this._addressAdditions.map(e => e.toJson());\n\t\tresult.addressDeletions = this._addressDeletions.map(e => e.toJson());\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedMultisigAccountModificationTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.MULTISIG_ACCOUNT_MODIFICATION;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\taddressAdditions: 'array[UnresolvedAddress]',\n\t\taddressDeletions: 'array[UnresolvedAddress]'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedMultisigAccountModificationTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedMultisigAccountModificationTransactionV1.TRANSACTION_TYPE;\n\t\tthis._minRemovalDelta = 0;\n\t\tthis._minApprovalDelta = 0;\n\t\tthis._addressAdditions = [];\n\t\tthis._addressDeletions = [];\n\t\tthis._multisigAccountModificationTransactionBodyReserved_1 = 0; // reserved field\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget minRemovalDelta() {\n\t\treturn this._minRemovalDelta;\n\t}\n\n\tset minRemovalDelta(value) {\n\t\tthis._minRemovalDelta = value;\n\t}\n\n\tget minApprovalDelta() {\n\t\treturn this._minApprovalDelta;\n\t}\n\n\tset minApprovalDelta(value) {\n\t\tthis._minApprovalDelta = value;\n\t}\n\n\tget addressAdditions() {\n\t\treturn this._addressAdditions;\n\t}\n\n\tset addressAdditions(value) {\n\t\tthis._addressAdditions = value;\n\t}\n\n\tget addressDeletions() {\n\t\treturn this._addressDeletions;\n\t}\n\n\tset addressDeletions(value) {\n\t\tthis._addressDeletions = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += 1;\n\t\tsize += 1;\n\t\tsize += 1;\n\t\tsize += 1;\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.addressAdditions);\n\t\tsize += arrayHelpers.size(this.addressDeletions);\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedMultisigAccountModificationTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst minRemovalDelta = converter.bytesToInt(view.buffer, 1, true);\n\t\tview.shiftRight(1);\n\t\tconst minApprovalDelta = converter.bytesToInt(view.buffer, 1, true);\n\t\tview.shiftRight(1);\n\t\tconst addressAdditionsCount = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst addressDeletionsCount = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst multisigAccountModificationTransactionBodyReserved_1 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== multisigAccountModificationTransactionBodyReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${multisigAccountModificationTransactionBodyReserved_1})`);\n\t\tconst addressAdditions = arrayHelpers.readArrayCount(view.buffer, UnresolvedAddress, addressAdditionsCount);\n\t\tview.shiftRight(arrayHelpers.size(addressAdditions));\n\t\tconst addressDeletions = arrayHelpers.readArrayCount(view.buffer, UnresolvedAddress, addressDeletionsCount);\n\t\tview.shiftRight(arrayHelpers.size(addressDeletions));\n\n\t\tinstance._minRemovalDelta = minRemovalDelta;\n\t\tinstance._minApprovalDelta = minApprovalDelta;\n\t\tinstance._addressAdditions = addressAdditions;\n\t\tinstance._addressDeletions = addressDeletions;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(converter.intToBytes(this._minRemovalDelta, 1, true));\n\t\tbuffer.write(converter.intToBytes(this._minApprovalDelta, 1, true));\n\t\tbuffer.write(converter.intToBytes(this._addressAdditions.length, 1, false)); // bound: address_additions_count\n\t\tbuffer.write(converter.intToBytes(this._addressDeletions.length, 1, false)); // bound: address_deletions_count\n\t\tbuffer.write(converter.intToBytes(this._multisigAccountModificationTransactionBodyReserved_1, 4, false));\n\t\tarrayHelpers.writeArray(buffer, this._addressAdditions);\n\t\tarrayHelpers.writeArray(buffer, this._addressDeletions);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `minRemovalDelta: ${'0x'.concat(this._minRemovalDelta.toString(16))}, `;\n\t\tresult += `minApprovalDelta: ${'0x'.concat(this._minApprovalDelta.toString(16))}, `;\n\t\tresult += `addressAdditions: [${this._addressAdditions.map(e => e.toString()).join(',')}], `;\n\t\tresult += `addressDeletions: [${this._addressDeletions.map(e => e.toString()).join(',')}], `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.minRemovalDelta = this._minRemovalDelta;\n\t\tresult.minApprovalDelta = this._minApprovalDelta;\n\t\tresult.addressAdditions = this._addressAdditions.map(e => e.toJson());\n\t\tresult.addressDeletions = this._addressDeletions.map(e => e.toJson());\n\t\treturn result;\n\t}\n}\n\nexport class AddressAliasTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.ADDRESS_ALIAS;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\tnamespaceId: 'pod:NamespaceId',\n\t\taddress: 'pod:Address',\n\t\taliasAction: 'enum:AliasAction'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = AddressAliasTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = AddressAliasTransactionV1.TRANSACTION_TYPE;\n\t\tthis._namespaceId = new NamespaceId();\n\t\tthis._address = new Address();\n\t\tthis._aliasAction = AliasAction.UNLINK;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget namespaceId() {\n\t\treturn this._namespaceId;\n\t}\n\n\tset namespaceId(value) {\n\t\tthis._namespaceId = value;\n\t}\n\n\tget address() {\n\t\treturn this._address;\n\t}\n\n\tset address(value) {\n\t\tthis._address = value;\n\t}\n\n\tget aliasAction() {\n\t\treturn this._aliasAction;\n\t}\n\n\tset aliasAction(value) {\n\t\tthis._aliasAction = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.namespaceId.size;\n\t\tsize += this.address.size;\n\t\tsize += this.aliasAction.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new AddressAliasTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst namespaceId = NamespaceId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(namespaceId.size);\n\t\tconst address = Address.deserialize(view.buffer);\n\t\tview.shiftRight(address.size);\n\t\tconst aliasAction = AliasAction.deserializeAligned(view.buffer);\n\t\tview.shiftRight(aliasAction.size);\n\n\t\tinstance._namespaceId = namespaceId;\n\t\tinstance._address = address;\n\t\tinstance._aliasAction = aliasAction;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._namespaceId.serialize());\n\t\tbuffer.write(this._address.serialize());\n\t\tbuffer.write(this._aliasAction.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `namespaceId: ${this._namespaceId.toString()}, `;\n\t\tresult += `address: ${this._address.toString()}, `;\n\t\tresult += `aliasAction: ${this._aliasAction.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.namespaceId = this._namespaceId.toJson();\n\t\tresult.address = this._address.toJson();\n\t\tresult.aliasAction = this._aliasAction.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedAddressAliasTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.ADDRESS_ALIAS;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\tnamespaceId: 'pod:NamespaceId',\n\t\taddress: 'pod:Address',\n\t\taliasAction: 'enum:AliasAction'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedAddressAliasTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedAddressAliasTransactionV1.TRANSACTION_TYPE;\n\t\tthis._namespaceId = new NamespaceId();\n\t\tthis._address = new Address();\n\t\tthis._aliasAction = AliasAction.UNLINK;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget namespaceId() {\n\t\treturn this._namespaceId;\n\t}\n\n\tset namespaceId(value) {\n\t\tthis._namespaceId = value;\n\t}\n\n\tget address() {\n\t\treturn this._address;\n\t}\n\n\tset address(value) {\n\t\tthis._address = value;\n\t}\n\n\tget aliasAction() {\n\t\treturn this._aliasAction;\n\t}\n\n\tset aliasAction(value) {\n\t\tthis._aliasAction = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.namespaceId.size;\n\t\tsize += this.address.size;\n\t\tsize += this.aliasAction.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedAddressAliasTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst namespaceId = NamespaceId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(namespaceId.size);\n\t\tconst address = Address.deserialize(view.buffer);\n\t\tview.shiftRight(address.size);\n\t\tconst aliasAction = AliasAction.deserializeAligned(view.buffer);\n\t\tview.shiftRight(aliasAction.size);\n\n\t\tinstance._namespaceId = namespaceId;\n\t\tinstance._address = address;\n\t\tinstance._aliasAction = aliasAction;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._namespaceId.serialize());\n\t\tbuffer.write(this._address.serialize());\n\t\tbuffer.write(this._aliasAction.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `namespaceId: ${this._namespaceId.toString()}, `;\n\t\tresult += `address: ${this._address.toString()}, `;\n\t\tresult += `aliasAction: ${this._aliasAction.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.namespaceId = this._namespaceId.toJson();\n\t\tresult.address = this._address.toJson();\n\t\tresult.aliasAction = this._aliasAction.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class MosaicAliasTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.MOSAIC_ALIAS;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\tnamespaceId: 'pod:NamespaceId',\n\t\tmosaicId: 'pod:MosaicId',\n\t\taliasAction: 'enum:AliasAction'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = MosaicAliasTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = MosaicAliasTransactionV1.TRANSACTION_TYPE;\n\t\tthis._namespaceId = new NamespaceId();\n\t\tthis._mosaicId = new MosaicId();\n\t\tthis._aliasAction = AliasAction.UNLINK;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget namespaceId() {\n\t\treturn this._namespaceId;\n\t}\n\n\tset namespaceId(value) {\n\t\tthis._namespaceId = value;\n\t}\n\n\tget mosaicId() {\n\t\treturn this._mosaicId;\n\t}\n\n\tset mosaicId(value) {\n\t\tthis._mosaicId = value;\n\t}\n\n\tget aliasAction() {\n\t\treturn this._aliasAction;\n\t}\n\n\tset aliasAction(value) {\n\t\tthis._aliasAction = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.namespaceId.size;\n\t\tsize += this.mosaicId.size;\n\t\tsize += this.aliasAction.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new MosaicAliasTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst namespaceId = NamespaceId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(namespaceId.size);\n\t\tconst mosaicId = MosaicId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(mosaicId.size);\n\t\tconst aliasAction = AliasAction.deserializeAligned(view.buffer);\n\t\tview.shiftRight(aliasAction.size);\n\n\t\tinstance._namespaceId = namespaceId;\n\t\tinstance._mosaicId = mosaicId;\n\t\tinstance._aliasAction = aliasAction;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._namespaceId.serialize());\n\t\tbuffer.write(this._mosaicId.serialize());\n\t\tbuffer.write(this._aliasAction.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `namespaceId: ${this._namespaceId.toString()}, `;\n\t\tresult += `mosaicId: ${this._mosaicId.toString()}, `;\n\t\tresult += `aliasAction: ${this._aliasAction.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.namespaceId = this._namespaceId.toJson();\n\t\tresult.mosaicId = this._mosaicId.toJson();\n\t\tresult.aliasAction = this._aliasAction.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedMosaicAliasTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.MOSAIC_ALIAS;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\tnamespaceId: 'pod:NamespaceId',\n\t\tmosaicId: 'pod:MosaicId',\n\t\taliasAction: 'enum:AliasAction'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedMosaicAliasTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedMosaicAliasTransactionV1.TRANSACTION_TYPE;\n\t\tthis._namespaceId = new NamespaceId();\n\t\tthis._mosaicId = new MosaicId();\n\t\tthis._aliasAction = AliasAction.UNLINK;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget namespaceId() {\n\t\treturn this._namespaceId;\n\t}\n\n\tset namespaceId(value) {\n\t\tthis._namespaceId = value;\n\t}\n\n\tget mosaicId() {\n\t\treturn this._mosaicId;\n\t}\n\n\tset mosaicId(value) {\n\t\tthis._mosaicId = value;\n\t}\n\n\tget aliasAction() {\n\t\treturn this._aliasAction;\n\t}\n\n\tset aliasAction(value) {\n\t\tthis._aliasAction = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.namespaceId.size;\n\t\tsize += this.mosaicId.size;\n\t\tsize += this.aliasAction.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedMosaicAliasTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst namespaceId = NamespaceId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(namespaceId.size);\n\t\tconst mosaicId = MosaicId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(mosaicId.size);\n\t\tconst aliasAction = AliasAction.deserializeAligned(view.buffer);\n\t\tview.shiftRight(aliasAction.size);\n\n\t\tinstance._namespaceId = namespaceId;\n\t\tinstance._mosaicId = mosaicId;\n\t\tinstance._aliasAction = aliasAction;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._namespaceId.serialize());\n\t\tbuffer.write(this._mosaicId.serialize());\n\t\tbuffer.write(this._aliasAction.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `namespaceId: ${this._namespaceId.toString()}, `;\n\t\tresult += `mosaicId: ${this._mosaicId.toString()}, `;\n\t\tresult += `aliasAction: ${this._aliasAction.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.namespaceId = this._namespaceId.toJson();\n\t\tresult.mosaicId = this._mosaicId.toJson();\n\t\tresult.aliasAction = this._aliasAction.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class NamespaceRegistrationTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.NAMESPACE_REGISTRATION;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\tduration: 'pod:BlockDuration',\n\t\tparentId: 'pod:NamespaceId',\n\t\tid: 'pod:NamespaceId',\n\t\tregistrationType: 'enum:NamespaceRegistrationType',\n\t\tname: 'bytes_array'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = NamespaceRegistrationTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = NamespaceRegistrationTransactionV1.TRANSACTION_TYPE;\n\t\tthis._duration = new BlockDuration();\n\t\tthis._parentId = null;\n\t\tthis._id = new NamespaceId();\n\t\tthis._registrationType = NamespaceRegistrationType.ROOT;\n\t\tthis._name = new Uint8Array();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget duration() {\n\t\treturn this._duration;\n\t}\n\n\tset duration(value) {\n\t\tthis._duration = value;\n\t}\n\n\tget parentId() {\n\t\treturn this._parentId;\n\t}\n\n\tset parentId(value) {\n\t\tthis._parentId = value;\n\t}\n\n\tget id() {\n\t\treturn this._id;\n\t}\n\n\tset id(value) {\n\t\tthis._id = value;\n\t}\n\n\tget registrationType() {\n\t\treturn this._registrationType;\n\t}\n\n\tset registrationType(value) {\n\t\tthis._registrationType = value;\n\t}\n\n\tget name() {\n\t\treturn this._name;\n\t}\n\n\tset name(value) {\n\t\tthis._name = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tif (NamespaceRegistrationType.ROOT === this.registrationType)\n\t\t\tsize += this.duration.size;\n\n\t\tif (NamespaceRegistrationType.CHILD === this.registrationType)\n\t\t\tsize += this.parentId.size;\n\n\t\tsize += this.id.size;\n\t\tsize += this.registrationType.size;\n\t\tsize += 1;\n\t\tsize += this._name.length;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new NamespaceRegistrationTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\t// deserialize to temporary buffer for further processing\n\t\tconst durationTemporary = BlockDuration.deserialize(view.buffer);\n\t\tconst registration_type_condition = view.window(durationTemporary.size);\n\t\tview.shiftRight(durationTemporary.size); // skip temporary\n\n\t\tconst id = NamespaceId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(id.size);\n\t\tconst registrationType = NamespaceRegistrationType.deserializeAligned(view.buffer);\n\t\tview.shiftRight(registrationType.size);\n\t\tlet duration = new BlockDuration();\n\t\tif (NamespaceRegistrationType.ROOT === registrationType)\n\t\t\tduration = BlockDuration.deserializeAligned(registration_type_condition);\n\n\t\tlet parentId = new NamespaceId();\n\t\tif (NamespaceRegistrationType.CHILD === registrationType)\n\t\t\tparentId = NamespaceId.deserializeAligned(registration_type_condition);\n\n\t\tconst nameSize = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst name = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, nameSize);\n\t\tview.shiftRight(nameSize);\n\n\t\tinstance._duration = duration;\n\t\tinstance._parentId = parentId;\n\t\tinstance._id = id;\n\t\tinstance._registrationType = registrationType;\n\t\tinstance._name = name;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tif (NamespaceRegistrationType.ROOT === this.registrationType)\n\t\t\tbuffer.write(this._duration.serialize());\n\n\t\tif (NamespaceRegistrationType.CHILD === this.registrationType)\n\t\t\tbuffer.write(this._parentId.serialize());\n\n\t\tbuffer.write(this._id.serialize());\n\t\tbuffer.write(this._registrationType.serialize());\n\t\tbuffer.write(converter.intToBytes(this._name.length, 1, false)); // bound: name_size\n\t\tbuffer.write(this._name);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tif (NamespaceRegistrationType.ROOT === this.registrationType)\n\t\t\tresult += `duration: ${this._duration.toString()}, `;\n\n\t\tif (NamespaceRegistrationType.CHILD === this.registrationType)\n\t\t\tresult += `parentId: ${this._parentId.toString()}, `;\n\n\t\tresult += `id: ${this._id.toString()}, `;\n\t\tresult += `registrationType: ${this._registrationType.toString()}, `;\n\t\tresult += `name: hex(${converter.uint8ToHex(this._name)}), `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tif (NamespaceRegistrationType.ROOT === this.registrationType)\n\t\t\tresult.duration = this._duration.toJson();\n\n\t\tif (NamespaceRegistrationType.CHILD === this.registrationType)\n\t\t\tresult.parentId = this._parentId.toJson();\n\n\t\tresult.id = this._id.toJson();\n\t\tresult.registrationType = this._registrationType.toJson();\n\t\tresult.name = converter.uint8ToHex(this._name);\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedNamespaceRegistrationTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.NAMESPACE_REGISTRATION;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\tduration: 'pod:BlockDuration',\n\t\tparentId: 'pod:NamespaceId',\n\t\tid: 'pod:NamespaceId',\n\t\tregistrationType: 'enum:NamespaceRegistrationType',\n\t\tname: 'bytes_array'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedNamespaceRegistrationTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedNamespaceRegistrationTransactionV1.TRANSACTION_TYPE;\n\t\tthis._duration = new BlockDuration();\n\t\tthis._parentId = null;\n\t\tthis._id = new NamespaceId();\n\t\tthis._registrationType = NamespaceRegistrationType.ROOT;\n\t\tthis._name = new Uint8Array();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget duration() {\n\t\treturn this._duration;\n\t}\n\n\tset duration(value) {\n\t\tthis._duration = value;\n\t}\n\n\tget parentId() {\n\t\treturn this._parentId;\n\t}\n\n\tset parentId(value) {\n\t\tthis._parentId = value;\n\t}\n\n\tget id() {\n\t\treturn this._id;\n\t}\n\n\tset id(value) {\n\t\tthis._id = value;\n\t}\n\n\tget registrationType() {\n\t\treturn this._registrationType;\n\t}\n\n\tset registrationType(value) {\n\t\tthis._registrationType = value;\n\t}\n\n\tget name() {\n\t\treturn this._name;\n\t}\n\n\tset name(value) {\n\t\tthis._name = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tif (NamespaceRegistrationType.ROOT === this.registrationType)\n\t\t\tsize += this.duration.size;\n\n\t\tif (NamespaceRegistrationType.CHILD === this.registrationType)\n\t\t\tsize += this.parentId.size;\n\n\t\tsize += this.id.size;\n\t\tsize += this.registrationType.size;\n\t\tsize += 1;\n\t\tsize += this._name.length;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedNamespaceRegistrationTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\t// deserialize to temporary buffer for further processing\n\t\tconst durationTemporary = BlockDuration.deserialize(view.buffer);\n\t\tconst registration_type_condition = view.window(durationTemporary.size);\n\t\tview.shiftRight(durationTemporary.size); // skip temporary\n\n\t\tconst id = NamespaceId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(id.size);\n\t\tconst registrationType = NamespaceRegistrationType.deserializeAligned(view.buffer);\n\t\tview.shiftRight(registrationType.size);\n\t\tlet duration = new BlockDuration();\n\t\tif (NamespaceRegistrationType.ROOT === registrationType)\n\t\t\tduration = BlockDuration.deserializeAligned(registration_type_condition);\n\n\t\tlet parentId = new NamespaceId();\n\t\tif (NamespaceRegistrationType.CHILD === registrationType)\n\t\t\tparentId = NamespaceId.deserializeAligned(registration_type_condition);\n\n\t\tconst nameSize = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst name = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, nameSize);\n\t\tview.shiftRight(nameSize);\n\n\t\tinstance._duration = duration;\n\t\tinstance._parentId = parentId;\n\t\tinstance._id = id;\n\t\tinstance._registrationType = registrationType;\n\t\tinstance._name = name;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tif (NamespaceRegistrationType.ROOT === this.registrationType)\n\t\t\tbuffer.write(this._duration.serialize());\n\n\t\tif (NamespaceRegistrationType.CHILD === this.registrationType)\n\t\t\tbuffer.write(this._parentId.serialize());\n\n\t\tbuffer.write(this._id.serialize());\n\t\tbuffer.write(this._registrationType.serialize());\n\t\tbuffer.write(converter.intToBytes(this._name.length, 1, false)); // bound: name_size\n\t\tbuffer.write(this._name);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tif (NamespaceRegistrationType.ROOT === this.registrationType)\n\t\t\tresult += `duration: ${this._duration.toString()}, `;\n\n\t\tif (NamespaceRegistrationType.CHILD === this.registrationType)\n\t\t\tresult += `parentId: ${this._parentId.toString()}, `;\n\n\t\tresult += `id: ${this._id.toString()}, `;\n\t\tresult += `registrationType: ${this._registrationType.toString()}, `;\n\t\tresult += `name: hex(${converter.uint8ToHex(this._name)}), `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tif (NamespaceRegistrationType.ROOT === this.registrationType)\n\t\t\tresult.duration = this._duration.toJson();\n\n\t\tif (NamespaceRegistrationType.CHILD === this.registrationType)\n\t\t\tresult.parentId = this._parentId.toJson();\n\n\t\tresult.id = this._id.toJson();\n\t\tresult.registrationType = this._registrationType.toJson();\n\t\tresult.name = converter.uint8ToHex(this._name);\n\t\treturn result;\n\t}\n}\n\nexport class AccountRestrictionFlags {\n\tstatic ADDRESS = new AccountRestrictionFlags(1);\n\n\tstatic MOSAIC_ID = new AccountRestrictionFlags(2);\n\n\tstatic TRANSACTION_TYPE = new AccountRestrictionFlags(4);\n\n\tstatic OUTGOING = new AccountRestrictionFlags(16384);\n\n\tstatic BLOCK = new AccountRestrictionFlags(32768);\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n\n\thas(flag) {\n\t\treturn 0 !== (this.value & flag);\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 2;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new AccountRestrictionFlags(converter.bytesToIntUnaligned(byteArray, 2, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new AccountRestrictionFlags(converter.bytesToInt(byteArray, 2, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 2, false);\n\t}\n\n\ttoString() {\n\t\tconst values = [\n\t\t\t1, 2, 4, 16384, 32768\n\t\t];\n\t\tconst keys = [\n\t\t\t'ADDRESS', 'MOSAIC_ID', 'TRANSACTION_TYPE', 'OUTGOING', 'BLOCK'\n\t\t];\n\n\t\tif (0 === this.value) {\n\t\t\tconst index = values.indexOf(this.value);\n\t\t\treturn `AccountRestrictionFlags.${keys[index]}`;\n\t\t}\n\n\t\tconst positions = values.map(flag => (this.value & flag)).filter(n => n).map(n => values.indexOf(n));\n\t\treturn positions.map(n => `AccountRestrictionFlags.${keys[n]}`).join('|');\n\t}\n\n\ttoJson() {\n\t\treturn this.value;\n\t}\n}\n\nexport class AccountAddressRestrictionTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.ACCOUNT_ADDRESS_RESTRICTION;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\trestrictionFlags: 'enum:AccountRestrictionFlags',\n\t\trestrictionAdditions: 'array[UnresolvedAddress]',\n\t\trestrictionDeletions: 'array[UnresolvedAddress]'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = AccountAddressRestrictionTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = AccountAddressRestrictionTransactionV1.TRANSACTION_TYPE;\n\t\tthis._restrictionFlags = AccountRestrictionFlags.ADDRESS;\n\t\tthis._restrictionAdditions = [];\n\t\tthis._restrictionDeletions = [];\n\t\tthis._accountRestrictionTransactionBodyReserved_1 = 0; // reserved field\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget restrictionFlags() {\n\t\treturn this._restrictionFlags;\n\t}\n\n\tset restrictionFlags(value) {\n\t\tthis._restrictionFlags = value;\n\t}\n\n\tget restrictionAdditions() {\n\t\treturn this._restrictionAdditions;\n\t}\n\n\tset restrictionAdditions(value) {\n\t\tthis._restrictionAdditions = value;\n\t}\n\n\tget restrictionDeletions() {\n\t\treturn this._restrictionDeletions;\n\t}\n\n\tset restrictionDeletions(value) {\n\t\tthis._restrictionDeletions = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.restrictionFlags.size;\n\t\tsize += 1;\n\t\tsize += 1;\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.restrictionAdditions);\n\t\tsize += arrayHelpers.size(this.restrictionDeletions);\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new AccountAddressRestrictionTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst restrictionFlags = AccountRestrictionFlags.deserializeAligned(view.buffer);\n\t\tview.shiftRight(restrictionFlags.size);\n\t\tconst restrictionAdditionsCount = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst restrictionDeletionsCount = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst accountRestrictionTransactionBodyReserved_1 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== accountRestrictionTransactionBodyReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${accountRestrictionTransactionBodyReserved_1})`);\n\t\tconst restrictionAdditions = arrayHelpers.readArrayCount(view.buffer, UnresolvedAddress, restrictionAdditionsCount);\n\t\tview.shiftRight(arrayHelpers.size(restrictionAdditions));\n\t\tconst restrictionDeletions = arrayHelpers.readArrayCount(view.buffer, UnresolvedAddress, restrictionDeletionsCount);\n\t\tview.shiftRight(arrayHelpers.size(restrictionDeletions));\n\n\t\tinstance._restrictionFlags = restrictionFlags;\n\t\tinstance._restrictionAdditions = restrictionAdditions;\n\t\tinstance._restrictionDeletions = restrictionDeletions;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._restrictionFlags.serialize());\n\t\tbuffer.write(converter.intToBytes(this._restrictionAdditions.length, 1, false)); // bound: restriction_additions_count\n\t\tbuffer.write(converter.intToBytes(this._restrictionDeletions.length, 1, false)); // bound: restriction_deletions_count\n\t\tbuffer.write(converter.intToBytes(this._accountRestrictionTransactionBodyReserved_1, 4, false));\n\t\tarrayHelpers.writeArray(buffer, this._restrictionAdditions);\n\t\tarrayHelpers.writeArray(buffer, this._restrictionDeletions);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `restrictionFlags: ${this._restrictionFlags.toString()}, `;\n\t\tresult += `restrictionAdditions: [${this._restrictionAdditions.map(e => e.toString()).join(',')}], `;\n\t\tresult += `restrictionDeletions: [${this._restrictionDeletions.map(e => e.toString()).join(',')}], `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.restrictionFlags = this._restrictionFlags.toJson();\n\t\tresult.restrictionAdditions = this._restrictionAdditions.map(e => e.toJson());\n\t\tresult.restrictionDeletions = this._restrictionDeletions.map(e => e.toJson());\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedAccountAddressRestrictionTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.ACCOUNT_ADDRESS_RESTRICTION;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\trestrictionFlags: 'enum:AccountRestrictionFlags',\n\t\trestrictionAdditions: 'array[UnresolvedAddress]',\n\t\trestrictionDeletions: 'array[UnresolvedAddress]'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedAccountAddressRestrictionTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedAccountAddressRestrictionTransactionV1.TRANSACTION_TYPE;\n\t\tthis._restrictionFlags = AccountRestrictionFlags.ADDRESS;\n\t\tthis._restrictionAdditions = [];\n\t\tthis._restrictionDeletions = [];\n\t\tthis._accountRestrictionTransactionBodyReserved_1 = 0; // reserved field\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget restrictionFlags() {\n\t\treturn this._restrictionFlags;\n\t}\n\n\tset restrictionFlags(value) {\n\t\tthis._restrictionFlags = value;\n\t}\n\n\tget restrictionAdditions() {\n\t\treturn this._restrictionAdditions;\n\t}\n\n\tset restrictionAdditions(value) {\n\t\tthis._restrictionAdditions = value;\n\t}\n\n\tget restrictionDeletions() {\n\t\treturn this._restrictionDeletions;\n\t}\n\n\tset restrictionDeletions(value) {\n\t\tthis._restrictionDeletions = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.restrictionFlags.size;\n\t\tsize += 1;\n\t\tsize += 1;\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.restrictionAdditions);\n\t\tsize += arrayHelpers.size(this.restrictionDeletions);\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedAccountAddressRestrictionTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst restrictionFlags = AccountRestrictionFlags.deserializeAligned(view.buffer);\n\t\tview.shiftRight(restrictionFlags.size);\n\t\tconst restrictionAdditionsCount = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst restrictionDeletionsCount = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst accountRestrictionTransactionBodyReserved_1 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== accountRestrictionTransactionBodyReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${accountRestrictionTransactionBodyReserved_1})`);\n\t\tconst restrictionAdditions = arrayHelpers.readArrayCount(view.buffer, UnresolvedAddress, restrictionAdditionsCount);\n\t\tview.shiftRight(arrayHelpers.size(restrictionAdditions));\n\t\tconst restrictionDeletions = arrayHelpers.readArrayCount(view.buffer, UnresolvedAddress, restrictionDeletionsCount);\n\t\tview.shiftRight(arrayHelpers.size(restrictionDeletions));\n\n\t\tinstance._restrictionFlags = restrictionFlags;\n\t\tinstance._restrictionAdditions = restrictionAdditions;\n\t\tinstance._restrictionDeletions = restrictionDeletions;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._restrictionFlags.serialize());\n\t\tbuffer.write(converter.intToBytes(this._restrictionAdditions.length, 1, false)); // bound: restriction_additions_count\n\t\tbuffer.write(converter.intToBytes(this._restrictionDeletions.length, 1, false)); // bound: restriction_deletions_count\n\t\tbuffer.write(converter.intToBytes(this._accountRestrictionTransactionBodyReserved_1, 4, false));\n\t\tarrayHelpers.writeArray(buffer, this._restrictionAdditions);\n\t\tarrayHelpers.writeArray(buffer, this._restrictionDeletions);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `restrictionFlags: ${this._restrictionFlags.toString()}, `;\n\t\tresult += `restrictionAdditions: [${this._restrictionAdditions.map(e => e.toString()).join(',')}], `;\n\t\tresult += `restrictionDeletions: [${this._restrictionDeletions.map(e => e.toString()).join(',')}], `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.restrictionFlags = this._restrictionFlags.toJson();\n\t\tresult.restrictionAdditions = this._restrictionAdditions.map(e => e.toJson());\n\t\tresult.restrictionDeletions = this._restrictionDeletions.map(e => e.toJson());\n\t\treturn result;\n\t}\n}\n\nexport class AccountMosaicRestrictionTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.ACCOUNT_MOSAIC_RESTRICTION;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\trestrictionFlags: 'enum:AccountRestrictionFlags',\n\t\trestrictionAdditions: 'array[UnresolvedMosaicId]',\n\t\trestrictionDeletions: 'array[UnresolvedMosaicId]'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = AccountMosaicRestrictionTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = AccountMosaicRestrictionTransactionV1.TRANSACTION_TYPE;\n\t\tthis._restrictionFlags = AccountRestrictionFlags.ADDRESS;\n\t\tthis._restrictionAdditions = [];\n\t\tthis._restrictionDeletions = [];\n\t\tthis._accountRestrictionTransactionBodyReserved_1 = 0; // reserved field\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget restrictionFlags() {\n\t\treturn this._restrictionFlags;\n\t}\n\n\tset restrictionFlags(value) {\n\t\tthis._restrictionFlags = value;\n\t}\n\n\tget restrictionAdditions() {\n\t\treturn this._restrictionAdditions;\n\t}\n\n\tset restrictionAdditions(value) {\n\t\tthis._restrictionAdditions = value;\n\t}\n\n\tget restrictionDeletions() {\n\t\treturn this._restrictionDeletions;\n\t}\n\n\tset restrictionDeletions(value) {\n\t\tthis._restrictionDeletions = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.restrictionFlags.size;\n\t\tsize += 1;\n\t\tsize += 1;\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.restrictionAdditions);\n\t\tsize += arrayHelpers.size(this.restrictionDeletions);\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new AccountMosaicRestrictionTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst restrictionFlags = AccountRestrictionFlags.deserializeAligned(view.buffer);\n\t\tview.shiftRight(restrictionFlags.size);\n\t\tconst restrictionAdditionsCount = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst restrictionDeletionsCount = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst accountRestrictionTransactionBodyReserved_1 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== accountRestrictionTransactionBodyReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${accountRestrictionTransactionBodyReserved_1})`);\n\t\tconst restrictionAdditions = arrayHelpers.readArrayCount(view.buffer, UnresolvedMosaicId, restrictionAdditionsCount);\n\t\tview.shiftRight(arrayHelpers.size(restrictionAdditions));\n\t\tconst restrictionDeletions = arrayHelpers.readArrayCount(view.buffer, UnresolvedMosaicId, restrictionDeletionsCount);\n\t\tview.shiftRight(arrayHelpers.size(restrictionDeletions));\n\n\t\tinstance._restrictionFlags = restrictionFlags;\n\t\tinstance._restrictionAdditions = restrictionAdditions;\n\t\tinstance._restrictionDeletions = restrictionDeletions;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._restrictionFlags.serialize());\n\t\tbuffer.write(converter.intToBytes(this._restrictionAdditions.length, 1, false)); // bound: restriction_additions_count\n\t\tbuffer.write(converter.intToBytes(this._restrictionDeletions.length, 1, false)); // bound: restriction_deletions_count\n\t\tbuffer.write(converter.intToBytes(this._accountRestrictionTransactionBodyReserved_1, 4, false));\n\t\tarrayHelpers.writeArray(buffer, this._restrictionAdditions);\n\t\tarrayHelpers.writeArray(buffer, this._restrictionDeletions);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `restrictionFlags: ${this._restrictionFlags.toString()}, `;\n\t\tresult += `restrictionAdditions: [${this._restrictionAdditions.map(e => e.toString()).join(',')}], `;\n\t\tresult += `restrictionDeletions: [${this._restrictionDeletions.map(e => e.toString()).join(',')}], `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.restrictionFlags = this._restrictionFlags.toJson();\n\t\tresult.restrictionAdditions = this._restrictionAdditions.map(e => e.toJson());\n\t\tresult.restrictionDeletions = this._restrictionDeletions.map(e => e.toJson());\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedAccountMosaicRestrictionTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.ACCOUNT_MOSAIC_RESTRICTION;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\trestrictionFlags: 'enum:AccountRestrictionFlags',\n\t\trestrictionAdditions: 'array[UnresolvedMosaicId]',\n\t\trestrictionDeletions: 'array[UnresolvedMosaicId]'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedAccountMosaicRestrictionTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedAccountMosaicRestrictionTransactionV1.TRANSACTION_TYPE;\n\t\tthis._restrictionFlags = AccountRestrictionFlags.ADDRESS;\n\t\tthis._restrictionAdditions = [];\n\t\tthis._restrictionDeletions = [];\n\t\tthis._accountRestrictionTransactionBodyReserved_1 = 0; // reserved field\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget restrictionFlags() {\n\t\treturn this._restrictionFlags;\n\t}\n\n\tset restrictionFlags(value) {\n\t\tthis._restrictionFlags = value;\n\t}\n\n\tget restrictionAdditions() {\n\t\treturn this._restrictionAdditions;\n\t}\n\n\tset restrictionAdditions(value) {\n\t\tthis._restrictionAdditions = value;\n\t}\n\n\tget restrictionDeletions() {\n\t\treturn this._restrictionDeletions;\n\t}\n\n\tset restrictionDeletions(value) {\n\t\tthis._restrictionDeletions = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.restrictionFlags.size;\n\t\tsize += 1;\n\t\tsize += 1;\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.restrictionAdditions);\n\t\tsize += arrayHelpers.size(this.restrictionDeletions);\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedAccountMosaicRestrictionTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst restrictionFlags = AccountRestrictionFlags.deserializeAligned(view.buffer);\n\t\tview.shiftRight(restrictionFlags.size);\n\t\tconst restrictionAdditionsCount = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst restrictionDeletionsCount = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst accountRestrictionTransactionBodyReserved_1 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== accountRestrictionTransactionBodyReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${accountRestrictionTransactionBodyReserved_1})`);\n\t\tconst restrictionAdditions = arrayHelpers.readArrayCount(view.buffer, UnresolvedMosaicId, restrictionAdditionsCount);\n\t\tview.shiftRight(arrayHelpers.size(restrictionAdditions));\n\t\tconst restrictionDeletions = arrayHelpers.readArrayCount(view.buffer, UnresolvedMosaicId, restrictionDeletionsCount);\n\t\tview.shiftRight(arrayHelpers.size(restrictionDeletions));\n\n\t\tinstance._restrictionFlags = restrictionFlags;\n\t\tinstance._restrictionAdditions = restrictionAdditions;\n\t\tinstance._restrictionDeletions = restrictionDeletions;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._restrictionFlags.serialize());\n\t\tbuffer.write(converter.intToBytes(this._restrictionAdditions.length, 1, false)); // bound: restriction_additions_count\n\t\tbuffer.write(converter.intToBytes(this._restrictionDeletions.length, 1, false)); // bound: restriction_deletions_count\n\t\tbuffer.write(converter.intToBytes(this._accountRestrictionTransactionBodyReserved_1, 4, false));\n\t\tarrayHelpers.writeArray(buffer, this._restrictionAdditions);\n\t\tarrayHelpers.writeArray(buffer, this._restrictionDeletions);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `restrictionFlags: ${this._restrictionFlags.toString()}, `;\n\t\tresult += `restrictionAdditions: [${this._restrictionAdditions.map(e => e.toString()).join(',')}], `;\n\t\tresult += `restrictionDeletions: [${this._restrictionDeletions.map(e => e.toString()).join(',')}], `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.restrictionFlags = this._restrictionFlags.toJson();\n\t\tresult.restrictionAdditions = this._restrictionAdditions.map(e => e.toJson());\n\t\tresult.restrictionDeletions = this._restrictionDeletions.map(e => e.toJson());\n\t\treturn result;\n\t}\n}\n\nexport class AccountOperationRestrictionTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.ACCOUNT_OPERATION_RESTRICTION;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\trestrictionFlags: 'enum:AccountRestrictionFlags',\n\t\trestrictionAdditions: 'array[TransactionType]',\n\t\trestrictionDeletions: 'array[TransactionType]'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = AccountOperationRestrictionTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = AccountOperationRestrictionTransactionV1.TRANSACTION_TYPE;\n\t\tthis._restrictionFlags = AccountRestrictionFlags.ADDRESS;\n\t\tthis._restrictionAdditions = [];\n\t\tthis._restrictionDeletions = [];\n\t\tthis._accountRestrictionTransactionBodyReserved_1 = 0; // reserved field\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget restrictionFlags() {\n\t\treturn this._restrictionFlags;\n\t}\n\n\tset restrictionFlags(value) {\n\t\tthis._restrictionFlags = value;\n\t}\n\n\tget restrictionAdditions() {\n\t\treturn this._restrictionAdditions;\n\t}\n\n\tset restrictionAdditions(value) {\n\t\tthis._restrictionAdditions = value;\n\t}\n\n\tget restrictionDeletions() {\n\t\treturn this._restrictionDeletions;\n\t}\n\n\tset restrictionDeletions(value) {\n\t\tthis._restrictionDeletions = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.restrictionFlags.size;\n\t\tsize += 1;\n\t\tsize += 1;\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.restrictionAdditions);\n\t\tsize += arrayHelpers.size(this.restrictionDeletions);\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new AccountOperationRestrictionTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst restrictionFlags = AccountRestrictionFlags.deserializeAligned(view.buffer);\n\t\tview.shiftRight(restrictionFlags.size);\n\t\tconst restrictionAdditionsCount = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst restrictionDeletionsCount = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst accountRestrictionTransactionBodyReserved_1 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== accountRestrictionTransactionBodyReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${accountRestrictionTransactionBodyReserved_1})`);\n\t\tconst restrictionAdditions = arrayHelpers.readArrayCount(view.buffer, TransactionType, restrictionAdditionsCount);\n\t\tview.shiftRight(arrayHelpers.size(restrictionAdditions));\n\t\tconst restrictionDeletions = arrayHelpers.readArrayCount(view.buffer, TransactionType, restrictionDeletionsCount);\n\t\tview.shiftRight(arrayHelpers.size(restrictionDeletions));\n\n\t\tinstance._restrictionFlags = restrictionFlags;\n\t\tinstance._restrictionAdditions = restrictionAdditions;\n\t\tinstance._restrictionDeletions = restrictionDeletions;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._restrictionFlags.serialize());\n\t\tbuffer.write(converter.intToBytes(this._restrictionAdditions.length, 1, false)); // bound: restriction_additions_count\n\t\tbuffer.write(converter.intToBytes(this._restrictionDeletions.length, 1, false)); // bound: restriction_deletions_count\n\t\tbuffer.write(converter.intToBytes(this._accountRestrictionTransactionBodyReserved_1, 4, false));\n\t\tarrayHelpers.writeArray(buffer, this._restrictionAdditions);\n\t\tarrayHelpers.writeArray(buffer, this._restrictionDeletions);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `restrictionFlags: ${this._restrictionFlags.toString()}, `;\n\t\tresult += `restrictionAdditions: [${this._restrictionAdditions.map(e => e.toString()).join(',')}], `;\n\t\tresult += `restrictionDeletions: [${this._restrictionDeletions.map(e => e.toString()).join(',')}], `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.restrictionFlags = this._restrictionFlags.toJson();\n\t\tresult.restrictionAdditions = this._restrictionAdditions.map(e => e.toJson());\n\t\tresult.restrictionDeletions = this._restrictionDeletions.map(e => e.toJson());\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedAccountOperationRestrictionTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.ACCOUNT_OPERATION_RESTRICTION;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\trestrictionFlags: 'enum:AccountRestrictionFlags',\n\t\trestrictionAdditions: 'array[TransactionType]',\n\t\trestrictionDeletions: 'array[TransactionType]'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedAccountOperationRestrictionTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedAccountOperationRestrictionTransactionV1.TRANSACTION_TYPE;\n\t\tthis._restrictionFlags = AccountRestrictionFlags.ADDRESS;\n\t\tthis._restrictionAdditions = [];\n\t\tthis._restrictionDeletions = [];\n\t\tthis._accountRestrictionTransactionBodyReserved_1 = 0; // reserved field\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget restrictionFlags() {\n\t\treturn this._restrictionFlags;\n\t}\n\n\tset restrictionFlags(value) {\n\t\tthis._restrictionFlags = value;\n\t}\n\n\tget restrictionAdditions() {\n\t\treturn this._restrictionAdditions;\n\t}\n\n\tset restrictionAdditions(value) {\n\t\tthis._restrictionAdditions = value;\n\t}\n\n\tget restrictionDeletions() {\n\t\treturn this._restrictionDeletions;\n\t}\n\n\tset restrictionDeletions(value) {\n\t\tthis._restrictionDeletions = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.restrictionFlags.size;\n\t\tsize += 1;\n\t\tsize += 1;\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.restrictionAdditions);\n\t\tsize += arrayHelpers.size(this.restrictionDeletions);\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedAccountOperationRestrictionTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst restrictionFlags = AccountRestrictionFlags.deserializeAligned(view.buffer);\n\t\tview.shiftRight(restrictionFlags.size);\n\t\tconst restrictionAdditionsCount = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst restrictionDeletionsCount = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst accountRestrictionTransactionBodyReserved_1 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== accountRestrictionTransactionBodyReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${accountRestrictionTransactionBodyReserved_1})`);\n\t\tconst restrictionAdditions = arrayHelpers.readArrayCount(view.buffer, TransactionType, restrictionAdditionsCount);\n\t\tview.shiftRight(arrayHelpers.size(restrictionAdditions));\n\t\tconst restrictionDeletions = arrayHelpers.readArrayCount(view.buffer, TransactionType, restrictionDeletionsCount);\n\t\tview.shiftRight(arrayHelpers.size(restrictionDeletions));\n\n\t\tinstance._restrictionFlags = restrictionFlags;\n\t\tinstance._restrictionAdditions = restrictionAdditions;\n\t\tinstance._restrictionDeletions = restrictionDeletions;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._restrictionFlags.serialize());\n\t\tbuffer.write(converter.intToBytes(this._restrictionAdditions.length, 1, false)); // bound: restriction_additions_count\n\t\tbuffer.write(converter.intToBytes(this._restrictionDeletions.length, 1, false)); // bound: restriction_deletions_count\n\t\tbuffer.write(converter.intToBytes(this._accountRestrictionTransactionBodyReserved_1, 4, false));\n\t\tarrayHelpers.writeArray(buffer, this._restrictionAdditions);\n\t\tarrayHelpers.writeArray(buffer, this._restrictionDeletions);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `restrictionFlags: ${this._restrictionFlags.toString()}, `;\n\t\tresult += `restrictionAdditions: [${this._restrictionAdditions.map(e => e.toString()).join(',')}], `;\n\t\tresult += `restrictionDeletions: [${this._restrictionDeletions.map(e => e.toString()).join(',')}], `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.restrictionFlags = this._restrictionFlags.toJson();\n\t\tresult.restrictionAdditions = this._restrictionAdditions.map(e => e.toJson());\n\t\tresult.restrictionDeletions = this._restrictionDeletions.map(e => e.toJson());\n\t\treturn result;\n\t}\n}\n\nexport class MosaicAddressRestrictionTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.MOSAIC_ADDRESS_RESTRICTION;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\tmosaicId: 'pod:UnresolvedMosaicId',\n\t\ttargetAddress: 'pod:UnresolvedAddress'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = MosaicAddressRestrictionTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = MosaicAddressRestrictionTransactionV1.TRANSACTION_TYPE;\n\t\tthis._mosaicId = new UnresolvedMosaicId();\n\t\tthis._restrictionKey = 0n;\n\t\tthis._previousRestrictionValue = 0n;\n\t\tthis._newRestrictionValue = 0n;\n\t\tthis._targetAddress = new UnresolvedAddress();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget mosaicId() {\n\t\treturn this._mosaicId;\n\t}\n\n\tset mosaicId(value) {\n\t\tthis._mosaicId = value;\n\t}\n\n\tget restrictionKey() {\n\t\treturn this._restrictionKey;\n\t}\n\n\tset restrictionKey(value) {\n\t\tthis._restrictionKey = value;\n\t}\n\n\tget previousRestrictionValue() {\n\t\treturn this._previousRestrictionValue;\n\t}\n\n\tset previousRestrictionValue(value) {\n\t\tthis._previousRestrictionValue = value;\n\t}\n\n\tget newRestrictionValue() {\n\t\treturn this._newRestrictionValue;\n\t}\n\n\tset newRestrictionValue(value) {\n\t\tthis._newRestrictionValue = value;\n\t}\n\n\tget targetAddress() {\n\t\treturn this._targetAddress;\n\t}\n\n\tset targetAddress(value) {\n\t\tthis._targetAddress = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.mosaicId.size;\n\t\tsize += 8;\n\t\tsize += 8;\n\t\tsize += 8;\n\t\tsize += this.targetAddress.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new MosaicAddressRestrictionTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst mosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(mosaicId.size);\n\t\tconst restrictionKey = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst previousRestrictionValue = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst newRestrictionValue = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst targetAddress = UnresolvedAddress.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\n\t\tinstance._mosaicId = mosaicId;\n\t\tinstance._restrictionKey = restrictionKey;\n\t\tinstance._previousRestrictionValue = previousRestrictionValue;\n\t\tinstance._newRestrictionValue = newRestrictionValue;\n\t\tinstance._targetAddress = targetAddress;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._mosaicId.serialize());\n\t\tbuffer.write(converter.intToBytes(this._restrictionKey, 8, false));\n\t\tbuffer.write(converter.intToBytes(this._previousRestrictionValue, 8, false));\n\t\tbuffer.write(converter.intToBytes(this._newRestrictionValue, 8, false));\n\t\tbuffer.write(this._targetAddress.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `mosaicId: ${this._mosaicId.toString()}, `;\n\t\tresult += `restrictionKey: ${'0x'.concat(this._restrictionKey.toString(16))}, `;\n\t\tresult += `previousRestrictionValue: ${'0x'.concat(this._previousRestrictionValue.toString(16))}, `;\n\t\tresult += `newRestrictionValue: ${'0x'.concat(this._newRestrictionValue.toString(16))}, `;\n\t\tresult += `targetAddress: ${this._targetAddress.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.mosaicId = this._mosaicId.toJson();\n\t\tresult.restrictionKey = this._restrictionKey.toString();\n\t\tresult.previousRestrictionValue = this._previousRestrictionValue.toString();\n\t\tresult.newRestrictionValue = this._newRestrictionValue.toString();\n\t\tresult.targetAddress = this._targetAddress.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedMosaicAddressRestrictionTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.MOSAIC_ADDRESS_RESTRICTION;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\tmosaicId: 'pod:UnresolvedMosaicId',\n\t\ttargetAddress: 'pod:UnresolvedAddress'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedMosaicAddressRestrictionTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedMosaicAddressRestrictionTransactionV1.TRANSACTION_TYPE;\n\t\tthis._mosaicId = new UnresolvedMosaicId();\n\t\tthis._restrictionKey = 0n;\n\t\tthis._previousRestrictionValue = 0n;\n\t\tthis._newRestrictionValue = 0n;\n\t\tthis._targetAddress = new UnresolvedAddress();\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget mosaicId() {\n\t\treturn this._mosaicId;\n\t}\n\n\tset mosaicId(value) {\n\t\tthis._mosaicId = value;\n\t}\n\n\tget restrictionKey() {\n\t\treturn this._restrictionKey;\n\t}\n\n\tset restrictionKey(value) {\n\t\tthis._restrictionKey = value;\n\t}\n\n\tget previousRestrictionValue() {\n\t\treturn this._previousRestrictionValue;\n\t}\n\n\tset previousRestrictionValue(value) {\n\t\tthis._previousRestrictionValue = value;\n\t}\n\n\tget newRestrictionValue() {\n\t\treturn this._newRestrictionValue;\n\t}\n\n\tset newRestrictionValue(value) {\n\t\tthis._newRestrictionValue = value;\n\t}\n\n\tget targetAddress() {\n\t\treturn this._targetAddress;\n\t}\n\n\tset targetAddress(value) {\n\t\tthis._targetAddress = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.mosaicId.size;\n\t\tsize += 8;\n\t\tsize += 8;\n\t\tsize += 8;\n\t\tsize += this.targetAddress.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedMosaicAddressRestrictionTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst mosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(mosaicId.size);\n\t\tconst restrictionKey = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst previousRestrictionValue = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst newRestrictionValue = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst targetAddress = UnresolvedAddress.deserialize(view.buffer);\n\t\tview.shiftRight(targetAddress.size);\n\n\t\tinstance._mosaicId = mosaicId;\n\t\tinstance._restrictionKey = restrictionKey;\n\t\tinstance._previousRestrictionValue = previousRestrictionValue;\n\t\tinstance._newRestrictionValue = newRestrictionValue;\n\t\tinstance._targetAddress = targetAddress;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._mosaicId.serialize());\n\t\tbuffer.write(converter.intToBytes(this._restrictionKey, 8, false));\n\t\tbuffer.write(converter.intToBytes(this._previousRestrictionValue, 8, false));\n\t\tbuffer.write(converter.intToBytes(this._newRestrictionValue, 8, false));\n\t\tbuffer.write(this._targetAddress.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `mosaicId: ${this._mosaicId.toString()}, `;\n\t\tresult += `restrictionKey: ${'0x'.concat(this._restrictionKey.toString(16))}, `;\n\t\tresult += `previousRestrictionValue: ${'0x'.concat(this._previousRestrictionValue.toString(16))}, `;\n\t\tresult += `newRestrictionValue: ${'0x'.concat(this._newRestrictionValue.toString(16))}, `;\n\t\tresult += `targetAddress: ${this._targetAddress.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.mosaicId = this._mosaicId.toJson();\n\t\tresult.restrictionKey = this._restrictionKey.toString();\n\t\tresult.previousRestrictionValue = this._previousRestrictionValue.toString();\n\t\tresult.newRestrictionValue = this._newRestrictionValue.toString();\n\t\tresult.targetAddress = this._targetAddress.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class MosaicRestrictionKey extends BaseValue {\n\tstatic SIZE = 8;\n\n\tconstructor(mosaicRestrictionKey = 0n) {\n\t\tsuper(MosaicRestrictionKey.SIZE, mosaicRestrictionKey);\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new MosaicRestrictionKey(converter.bytesToBigIntUnaligned(byteArray, 8, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn new MosaicRestrictionKey(converter.bytesToBigInt(byteArray, 8, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 8, false);\n\t}\n}\n\nexport class MosaicRestrictionType {\n\tstatic NONE = new MosaicRestrictionType(0);\n\n\tstatic EQ = new MosaicRestrictionType(1);\n\n\tstatic NE = new MosaicRestrictionType(2);\n\n\tstatic LT = new MosaicRestrictionType(3);\n\n\tstatic LE = new MosaicRestrictionType(4);\n\n\tstatic GT = new MosaicRestrictionType(5);\n\n\tstatic GE = new MosaicRestrictionType(6);\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n\n\tstatic valueToKey(value) {\n\t\tconst values = [\n\t\t\t0, 1, 2, 3, 4, 5, 6\n\t\t];\n\t\tconst keys = [\n\t\t\t'NONE', 'EQ', 'NE', 'LT', 'LE', 'GT', 'GE'\n\t\t];\n\n\t\tconst index = values.indexOf(value);\n\t\tif (-1 === index)\n\t\t\tthrow RangeError(`invalid enum value ${value}`);\n\n\t\treturn keys[index];\n\t}\n\n\tstatic fromValue(value) {\n\t\treturn MosaicRestrictionType[this.valueToKey(value)];\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\treturn 1;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToIntUnaligned(byteArray, 1, false));\n\t}\n\n\tstatic deserializeAligned(payload) {\n\t\tconst byteArray = payload;\n\t\treturn this.fromValue(converter.bytesToInt(byteArray, 1, false));\n\t}\n\n\tserialize() {\n\t\treturn converter.intToBytes(this.value, 1, false);\n\t}\n\n\ttoString() {\n\t\treturn `MosaicRestrictionType.${MosaicRestrictionType.valueToKey(this.value)}`;\n\t}\n\n\ttoJson() {\n\t\treturn this.value;\n\t}\n}\n\nexport class MosaicGlobalRestrictionTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.MOSAIC_GLOBAL_RESTRICTION;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\tmosaicId: 'pod:UnresolvedMosaicId',\n\t\treferenceMosaicId: 'pod:UnresolvedMosaicId',\n\t\tpreviousRestrictionType: 'enum:MosaicRestrictionType',\n\t\tnewRestrictionType: 'enum:MosaicRestrictionType'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = MosaicGlobalRestrictionTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = MosaicGlobalRestrictionTransactionV1.TRANSACTION_TYPE;\n\t\tthis._mosaicId = new UnresolvedMosaicId();\n\t\tthis._referenceMosaicId = new UnresolvedMosaicId();\n\t\tthis._restrictionKey = 0n;\n\t\tthis._previousRestrictionValue = 0n;\n\t\tthis._newRestrictionValue = 0n;\n\t\tthis._previousRestrictionType = MosaicRestrictionType.NONE;\n\t\tthis._newRestrictionType = MosaicRestrictionType.NONE;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget mosaicId() {\n\t\treturn this._mosaicId;\n\t}\n\n\tset mosaicId(value) {\n\t\tthis._mosaicId = value;\n\t}\n\n\tget referenceMosaicId() {\n\t\treturn this._referenceMosaicId;\n\t}\n\n\tset referenceMosaicId(value) {\n\t\tthis._referenceMosaicId = value;\n\t}\n\n\tget restrictionKey() {\n\t\treturn this._restrictionKey;\n\t}\n\n\tset restrictionKey(value) {\n\t\tthis._restrictionKey = value;\n\t}\n\n\tget previousRestrictionValue() {\n\t\treturn this._previousRestrictionValue;\n\t}\n\n\tset previousRestrictionValue(value) {\n\t\tthis._previousRestrictionValue = value;\n\t}\n\n\tget newRestrictionValue() {\n\t\treturn this._newRestrictionValue;\n\t}\n\n\tset newRestrictionValue(value) {\n\t\tthis._newRestrictionValue = value;\n\t}\n\n\tget previousRestrictionType() {\n\t\treturn this._previousRestrictionType;\n\t}\n\n\tset previousRestrictionType(value) {\n\t\tthis._previousRestrictionType = value;\n\t}\n\n\tget newRestrictionType() {\n\t\treturn this._newRestrictionType;\n\t}\n\n\tset newRestrictionType(value) {\n\t\tthis._newRestrictionType = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.mosaicId.size;\n\t\tsize += this.referenceMosaicId.size;\n\t\tsize += 8;\n\t\tsize += 8;\n\t\tsize += 8;\n\t\tsize += this.previousRestrictionType.size;\n\t\tsize += this.newRestrictionType.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new MosaicGlobalRestrictionTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst mosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(mosaicId.size);\n\t\tconst referenceMosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(referenceMosaicId.size);\n\t\tconst restrictionKey = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst previousRestrictionValue = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst newRestrictionValue = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst previousRestrictionType = MosaicRestrictionType.deserializeAligned(view.buffer);\n\t\tview.shiftRight(previousRestrictionType.size);\n\t\tconst newRestrictionType = MosaicRestrictionType.deserializeAligned(view.buffer);\n\t\tview.shiftRight(newRestrictionType.size);\n\n\t\tinstance._mosaicId = mosaicId;\n\t\tinstance._referenceMosaicId = referenceMosaicId;\n\t\tinstance._restrictionKey = restrictionKey;\n\t\tinstance._previousRestrictionValue = previousRestrictionValue;\n\t\tinstance._newRestrictionValue = newRestrictionValue;\n\t\tinstance._previousRestrictionType = previousRestrictionType;\n\t\tinstance._newRestrictionType = newRestrictionType;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._mosaicId.serialize());\n\t\tbuffer.write(this._referenceMosaicId.serialize());\n\t\tbuffer.write(converter.intToBytes(this._restrictionKey, 8, false));\n\t\tbuffer.write(converter.intToBytes(this._previousRestrictionValue, 8, false));\n\t\tbuffer.write(converter.intToBytes(this._newRestrictionValue, 8, false));\n\t\tbuffer.write(this._previousRestrictionType.serialize());\n\t\tbuffer.write(this._newRestrictionType.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `mosaicId: ${this._mosaicId.toString()}, `;\n\t\tresult += `referenceMosaicId: ${this._referenceMosaicId.toString()}, `;\n\t\tresult += `restrictionKey: ${'0x'.concat(this._restrictionKey.toString(16))}, `;\n\t\tresult += `previousRestrictionValue: ${'0x'.concat(this._previousRestrictionValue.toString(16))}, `;\n\t\tresult += `newRestrictionValue: ${'0x'.concat(this._newRestrictionValue.toString(16))}, `;\n\t\tresult += `previousRestrictionType: ${this._previousRestrictionType.toString()}, `;\n\t\tresult += `newRestrictionType: ${this._newRestrictionType.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.mosaicId = this._mosaicId.toJson();\n\t\tresult.referenceMosaicId = this._referenceMosaicId.toJson();\n\t\tresult.restrictionKey = this._restrictionKey.toString();\n\t\tresult.previousRestrictionValue = this._previousRestrictionValue.toString();\n\t\tresult.newRestrictionValue = this._newRestrictionValue.toString();\n\t\tresult.previousRestrictionType = this._previousRestrictionType.toJson();\n\t\tresult.newRestrictionType = this._newRestrictionType.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedMosaicGlobalRestrictionTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.MOSAIC_GLOBAL_RESTRICTION;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\tmosaicId: 'pod:UnresolvedMosaicId',\n\t\treferenceMosaicId: 'pod:UnresolvedMosaicId',\n\t\tpreviousRestrictionType: 'enum:MosaicRestrictionType',\n\t\tnewRestrictionType: 'enum:MosaicRestrictionType'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedMosaicGlobalRestrictionTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedMosaicGlobalRestrictionTransactionV1.TRANSACTION_TYPE;\n\t\tthis._mosaicId = new UnresolvedMosaicId();\n\t\tthis._referenceMosaicId = new UnresolvedMosaicId();\n\t\tthis._restrictionKey = 0n;\n\t\tthis._previousRestrictionValue = 0n;\n\t\tthis._newRestrictionValue = 0n;\n\t\tthis._previousRestrictionType = MosaicRestrictionType.NONE;\n\t\tthis._newRestrictionType = MosaicRestrictionType.NONE;\n\t}\n\n\tsort() { // eslint-disable-line class-methods-use-this\n\t}\n\n\tget mosaicId() {\n\t\treturn this._mosaicId;\n\t}\n\n\tset mosaicId(value) {\n\t\tthis._mosaicId = value;\n\t}\n\n\tget referenceMosaicId() {\n\t\treturn this._referenceMosaicId;\n\t}\n\n\tset referenceMosaicId(value) {\n\t\tthis._referenceMosaicId = value;\n\t}\n\n\tget restrictionKey() {\n\t\treturn this._restrictionKey;\n\t}\n\n\tset restrictionKey(value) {\n\t\tthis._restrictionKey = value;\n\t}\n\n\tget previousRestrictionValue() {\n\t\treturn this._previousRestrictionValue;\n\t}\n\n\tset previousRestrictionValue(value) {\n\t\tthis._previousRestrictionValue = value;\n\t}\n\n\tget newRestrictionValue() {\n\t\treturn this._newRestrictionValue;\n\t}\n\n\tset newRestrictionValue(value) {\n\t\tthis._newRestrictionValue = value;\n\t}\n\n\tget previousRestrictionType() {\n\t\treturn this._previousRestrictionType;\n\t}\n\n\tset previousRestrictionType(value) {\n\t\tthis._previousRestrictionType = value;\n\t}\n\n\tget newRestrictionType() {\n\t\treturn this._newRestrictionType;\n\t}\n\n\tset newRestrictionType(value) {\n\t\tthis._newRestrictionType = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.mosaicId.size;\n\t\tsize += this.referenceMosaicId.size;\n\t\tsize += 8;\n\t\tsize += 8;\n\t\tsize += 8;\n\t\tsize += this.previousRestrictionType.size;\n\t\tsize += this.newRestrictionType.size;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedMosaicGlobalRestrictionTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst mosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(mosaicId.size);\n\t\tconst referenceMosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);\n\t\tview.shiftRight(referenceMosaicId.size);\n\t\tconst restrictionKey = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst previousRestrictionValue = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst newRestrictionValue = converter.bytesToBigInt(view.buffer, 8, false);\n\t\tview.shiftRight(8);\n\t\tconst previousRestrictionType = MosaicRestrictionType.deserializeAligned(view.buffer);\n\t\tview.shiftRight(previousRestrictionType.size);\n\t\tconst newRestrictionType = MosaicRestrictionType.deserializeAligned(view.buffer);\n\t\tview.shiftRight(newRestrictionType.size);\n\n\t\tinstance._mosaicId = mosaicId;\n\t\tinstance._referenceMosaicId = referenceMosaicId;\n\t\tinstance._restrictionKey = restrictionKey;\n\t\tinstance._previousRestrictionValue = previousRestrictionValue;\n\t\tinstance._newRestrictionValue = newRestrictionValue;\n\t\tinstance._previousRestrictionType = previousRestrictionType;\n\t\tinstance._newRestrictionType = newRestrictionType;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._mosaicId.serialize());\n\t\tbuffer.write(this._referenceMosaicId.serialize());\n\t\tbuffer.write(converter.intToBytes(this._restrictionKey, 8, false));\n\t\tbuffer.write(converter.intToBytes(this._previousRestrictionValue, 8, false));\n\t\tbuffer.write(converter.intToBytes(this._newRestrictionValue, 8, false));\n\t\tbuffer.write(this._previousRestrictionType.serialize());\n\t\tbuffer.write(this._newRestrictionType.serialize());\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `mosaicId: ${this._mosaicId.toString()}, `;\n\t\tresult += `referenceMosaicId: ${this._referenceMosaicId.toString()}, `;\n\t\tresult += `restrictionKey: ${'0x'.concat(this._restrictionKey.toString(16))}, `;\n\t\tresult += `previousRestrictionValue: ${'0x'.concat(this._previousRestrictionValue.toString(16))}, `;\n\t\tresult += `newRestrictionValue: ${'0x'.concat(this._newRestrictionValue.toString(16))}, `;\n\t\tresult += `previousRestrictionType: ${this._previousRestrictionType.toString()}, `;\n\t\tresult += `newRestrictionType: ${this._newRestrictionType.toString()}, `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.mosaicId = this._mosaicId.toJson();\n\t\tresult.referenceMosaicId = this._referenceMosaicId.toJson();\n\t\tresult.restrictionKey = this._restrictionKey.toString();\n\t\tresult.previousRestrictionValue = this._previousRestrictionValue.toString();\n\t\tresult.newRestrictionValue = this._newRestrictionValue.toString();\n\t\tresult.previousRestrictionType = this._previousRestrictionType.toJson();\n\t\tresult.newRestrictionType = this._newRestrictionType.toJson();\n\t\treturn result;\n\t}\n}\n\nexport class TransferTransactionV1 extends Transaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.TRANSFER;\n\n\tstatic TYPE_HINTS = {\n\t\t...Transaction.TYPE_HINTS,\n\t\trecipientAddress: 'pod:UnresolvedAddress',\n\t\tmosaics: 'array[UnresolvedMosaic]',\n\t\tmessage: 'bytes_array'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = TransferTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = TransferTransactionV1.TRANSACTION_TYPE;\n\t\tthis._recipientAddress = new UnresolvedAddress();\n\t\tthis._mosaics = [];\n\t\tthis._message = new Uint8Array();\n\t\tthis._transferTransactionBodyReserved_1 = 0; // reserved field\n\t\tthis._transferTransactionBodyReserved_2 = 0; // reserved field\n\t}\n\n\tsort() {\n\t\tthis._mosaics = this._mosaics.sort((lhs, rhs) => arrayHelpers.deepCompare(\n\t\t\t(lhs.mosaicId.comparer ? lhs.mosaicId.comparer() : lhs.mosaicId.value),\n\t\t\t(rhs.mosaicId.comparer ? rhs.mosaicId.comparer() : rhs.mosaicId.value)\n\t\t));\n\t}\n\n\tget recipientAddress() {\n\t\treturn this._recipientAddress;\n\t}\n\n\tset recipientAddress(value) {\n\t\tthis._recipientAddress = value;\n\t}\n\n\tget mosaics() {\n\t\treturn this._mosaics;\n\t}\n\n\tset mosaics(value) {\n\t\tthis._mosaics = value;\n\t}\n\n\tget message() {\n\t\treturn this._message;\n\t}\n\n\tset message(value) {\n\t\tthis._message = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.recipientAddress.size;\n\t\tsize += 2;\n\t\tsize += 1;\n\t\tsize += 1;\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.mosaics);\n\t\tsize += this._message.length;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new TransferTransactionV1();\n\n\t\tTransaction._deserialize(view, instance);\n\t\tconst recipientAddress = UnresolvedAddress.deserialize(view.buffer);\n\t\tview.shiftRight(recipientAddress.size);\n\t\tconst messageSize = converter.bytesToInt(view.buffer, 2, false);\n\t\tview.shiftRight(2);\n\t\tconst mosaicsCount = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst transferTransactionBodyReserved_1 = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tif (0 !== transferTransactionBodyReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${transferTransactionBodyReserved_1})`);\n\t\tconst transferTransactionBodyReserved_2 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== transferTransactionBodyReserved_2)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${transferTransactionBodyReserved_2})`);\n\t\tconst mosaics = arrayHelpers.readArrayCount(view.buffer, UnresolvedMosaic, mosaicsCount, e => ((e.mosaicId.comparer ? e.mosaicId.comparer() : e.mosaicId.value)));\n\t\tview.shiftRight(arrayHelpers.size(mosaics));\n\t\tconst message = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, messageSize);\n\t\tview.shiftRight(messageSize);\n\n\t\tinstance._recipientAddress = recipientAddress;\n\t\tinstance._mosaics = mosaics;\n\t\tinstance._message = message;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._recipientAddress.serialize());\n\t\tbuffer.write(converter.intToBytes(this._message.length, 2, false)); // bound: message_size\n\t\tbuffer.write(converter.intToBytes(this._mosaics.length, 1, false)); // bound: mosaics_count\n\t\tbuffer.write(converter.intToBytes(this._transferTransactionBodyReserved_1, 1, false));\n\t\tbuffer.write(converter.intToBytes(this._transferTransactionBodyReserved_2, 4, false));\n\t\tarrayHelpers.writeArray(buffer, this._mosaics, e => ((e.mosaicId.comparer ? e.mosaicId.comparer() : e.mosaicId.value)));\n\t\tbuffer.write(this._message);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `recipientAddress: ${this._recipientAddress.toString()}, `;\n\t\tresult += `mosaics: [${this._mosaics.map(e => e.toString()).join(',')}], `;\n\t\tresult += `message: hex(${converter.uint8ToHex(this._message)}), `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.recipientAddress = this._recipientAddress.toJson();\n\t\tresult.mosaics = this._mosaics.map(e => e.toJson());\n\t\tresult.message = converter.uint8ToHex(this._message);\n\t\treturn result;\n\t}\n}\n\nexport class EmbeddedTransferTransactionV1 extends EmbeddedTransaction {\n\tstatic TRANSACTION_VERSION = 1;\n\n\tstatic TRANSACTION_TYPE = TransactionType.TRANSFER;\n\n\tstatic TYPE_HINTS = {\n\t\t...EmbeddedTransaction.TYPE_HINTS,\n\t\trecipientAddress: 'pod:UnresolvedAddress',\n\t\tmosaics: 'array[UnresolvedMosaic]',\n\t\tmessage: 'bytes_array'\n\t};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._version = EmbeddedTransferTransactionV1.TRANSACTION_VERSION;\n\t\tthis._type = EmbeddedTransferTransactionV1.TRANSACTION_TYPE;\n\t\tthis._recipientAddress = new UnresolvedAddress();\n\t\tthis._mosaics = [];\n\t\tthis._message = new Uint8Array();\n\t\tthis._transferTransactionBodyReserved_1 = 0; // reserved field\n\t\tthis._transferTransactionBodyReserved_2 = 0; // reserved field\n\t}\n\n\tsort() {\n\t\tthis._mosaics = this._mosaics.sort((lhs, rhs) => arrayHelpers.deepCompare(\n\t\t\t(lhs.mosaicId.comparer ? lhs.mosaicId.comparer() : lhs.mosaicId.value),\n\t\t\t(rhs.mosaicId.comparer ? rhs.mosaicId.comparer() : rhs.mosaicId.value)\n\t\t));\n\t}\n\n\tget recipientAddress() {\n\t\treturn this._recipientAddress;\n\t}\n\n\tset recipientAddress(value) {\n\t\tthis._recipientAddress = value;\n\t}\n\n\tget mosaics() {\n\t\treturn this._mosaics;\n\t}\n\n\tset mosaics(value) {\n\t\tthis._mosaics = value;\n\t}\n\n\tget message() {\n\t\treturn this._message;\n\t}\n\n\tset message(value) {\n\t\tthis._message = value;\n\t}\n\n\tget size() { // eslint-disable-line class-methods-use-this\n\t\tlet size = 0;\n\t\tsize += super.size;\n\t\tsize += this.recipientAddress.size;\n\t\tsize += 2;\n\t\tsize += 1;\n\t\tsize += 1;\n\t\tsize += 4;\n\t\tsize += arrayHelpers.size(this.mosaics);\n\t\tsize += this._message.length;\n\t\treturn size;\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst view = new BufferView(payload);\n\t\tconst instance = new EmbeddedTransferTransactionV1();\n\n\t\tEmbeddedTransaction._deserialize(view, instance);\n\t\tconst recipientAddress = UnresolvedAddress.deserialize(view.buffer);\n\t\tview.shiftRight(recipientAddress.size);\n\t\tconst messageSize = converter.bytesToInt(view.buffer, 2, false);\n\t\tview.shiftRight(2);\n\t\tconst mosaicsCount = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tconst transferTransactionBodyReserved_1 = converter.bytesToInt(view.buffer, 1, false);\n\t\tview.shiftRight(1);\n\t\tif (0 !== transferTransactionBodyReserved_1)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${transferTransactionBodyReserved_1})`);\n\t\tconst transferTransactionBodyReserved_2 = converter.bytesToInt(view.buffer, 4, false);\n\t\tview.shiftRight(4);\n\t\tif (0 !== transferTransactionBodyReserved_2)\n\t\t\tthrow RangeError(`Invalid value of reserved field (${transferTransactionBodyReserved_2})`);\n\t\tconst mosaics = arrayHelpers.readArrayCount(view.buffer, UnresolvedMosaic, mosaicsCount, e => ((e.mosaicId.comparer ? e.mosaicId.comparer() : e.mosaicId.value)));\n\t\tview.shiftRight(arrayHelpers.size(mosaics));\n\t\tconst message = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, messageSize);\n\t\tview.shiftRight(messageSize);\n\n\t\tinstance._recipientAddress = recipientAddress;\n\t\tinstance._mosaics = mosaics;\n\t\tinstance._message = message;\n\t\treturn instance;\n\t}\n\n\tserialize() {\n\t\tconst buffer = new Writer(this.size);\n\t\tsuper._serialize(buffer);\n\t\tbuffer.write(this._recipientAddress.serialize());\n\t\tbuffer.write(converter.intToBytes(this._message.length, 2, false)); // bound: message_size\n\t\tbuffer.write(converter.intToBytes(this._mosaics.length, 1, false)); // bound: mosaics_count\n\t\tbuffer.write(converter.intToBytes(this._transferTransactionBodyReserved_1, 1, false));\n\t\tbuffer.write(converter.intToBytes(this._transferTransactionBodyReserved_2, 4, false));\n\t\tarrayHelpers.writeArray(buffer, this._mosaics, e => ((e.mosaicId.comparer ? e.mosaicId.comparer() : e.mosaicId.value)));\n\t\tbuffer.write(this._message);\n\t\treturn buffer.storage;\n\t}\n\n\ttoString() {\n\t\tlet result = '(';\n\t\tresult += super.toString();\n\t\tresult += `recipientAddress: ${this._recipientAddress.toString()}, `;\n\t\tresult += `mosaics: [${this._mosaics.map(e => e.toString()).join(',')}], `;\n\t\tresult += `message: hex(${converter.uint8ToHex(this._message)}), `;\n\t\tresult += ')';\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {object} JSON-safe representation of this object.\n\t */\n\ttoJson() {\n\t\tconst result = {};\n\t\tObject.assign(result, super.toJson());\n\t\tresult.recipientAddress = this._recipientAddress.toJson();\n\t\tresult.mosaics = this._mosaics.map(e => e.toJson());\n\t\tresult.message = converter.uint8ToHex(this._message);\n\t\treturn result;\n\t}\n}\n\nexport class TransactionFactory {\n\tstatic toKey(values) {\n\t\tif (1 === values.length)\n\t\t\treturn values[0];\n\n\t\t// assume each key is at most 32bits\n\t\treturn values.map(n => BigInt(n)).reduce((accumulator, value) => (accumulator << 32n) + value);\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst parent = new Transaction();\n\t\tTransaction._deserialize(new BufferView(payload), parent);\n\n\t\tconst view = new BufferView(payload);\n\t\tconst mapping = new Map();\n\t\tmapping.set(TransactionFactory.toKey([AccountKeyLinkTransactionV1.TRANSACTION_TYPE.value, AccountKeyLinkTransactionV1.TRANSACTION_VERSION]), AccountKeyLinkTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([NodeKeyLinkTransactionV1.TRANSACTION_TYPE.value, NodeKeyLinkTransactionV1.TRANSACTION_VERSION]), NodeKeyLinkTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([AggregateCompleteTransactionV1.TRANSACTION_TYPE.value, AggregateCompleteTransactionV1.TRANSACTION_VERSION]), AggregateCompleteTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([AggregateCompleteTransactionV2.TRANSACTION_TYPE.value, AggregateCompleteTransactionV2.TRANSACTION_VERSION]), AggregateCompleteTransactionV2);\n\t\tmapping.set(TransactionFactory.toKey([AggregateBondedTransactionV1.TRANSACTION_TYPE.value, AggregateBondedTransactionV1.TRANSACTION_VERSION]), AggregateBondedTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([AggregateBondedTransactionV2.TRANSACTION_TYPE.value, AggregateBondedTransactionV2.TRANSACTION_VERSION]), AggregateBondedTransactionV2);\n\t\tmapping.set(TransactionFactory.toKey([VotingKeyLinkTransactionV1.TRANSACTION_TYPE.value, VotingKeyLinkTransactionV1.TRANSACTION_VERSION]), VotingKeyLinkTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([VrfKeyLinkTransactionV1.TRANSACTION_TYPE.value, VrfKeyLinkTransactionV1.TRANSACTION_VERSION]), VrfKeyLinkTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([HashLockTransactionV1.TRANSACTION_TYPE.value, HashLockTransactionV1.TRANSACTION_VERSION]), HashLockTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([SecretLockTransactionV1.TRANSACTION_TYPE.value, SecretLockTransactionV1.TRANSACTION_VERSION]), SecretLockTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([SecretProofTransactionV1.TRANSACTION_TYPE.value, SecretProofTransactionV1.TRANSACTION_VERSION]), SecretProofTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([AccountMetadataTransactionV1.TRANSACTION_TYPE.value, AccountMetadataTransactionV1.TRANSACTION_VERSION]), AccountMetadataTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([MosaicMetadataTransactionV1.TRANSACTION_TYPE.value, MosaicMetadataTransactionV1.TRANSACTION_VERSION]), MosaicMetadataTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([NamespaceMetadataTransactionV1.TRANSACTION_TYPE.value, NamespaceMetadataTransactionV1.TRANSACTION_VERSION]), NamespaceMetadataTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([MosaicDefinitionTransactionV1.TRANSACTION_TYPE.value, MosaicDefinitionTransactionV1.TRANSACTION_VERSION]), MosaicDefinitionTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([MosaicSupplyChangeTransactionV1.TRANSACTION_TYPE.value, MosaicSupplyChangeTransactionV1.TRANSACTION_VERSION]), MosaicSupplyChangeTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([MosaicSupplyRevocationTransactionV1.TRANSACTION_TYPE.value, MosaicSupplyRevocationTransactionV1.TRANSACTION_VERSION]), MosaicSupplyRevocationTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([MultisigAccountModificationTransactionV1.TRANSACTION_TYPE.value, MultisigAccountModificationTransactionV1.TRANSACTION_VERSION]), MultisigAccountModificationTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([AddressAliasTransactionV1.TRANSACTION_TYPE.value, AddressAliasTransactionV1.TRANSACTION_VERSION]), AddressAliasTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([MosaicAliasTransactionV1.TRANSACTION_TYPE.value, MosaicAliasTransactionV1.TRANSACTION_VERSION]), MosaicAliasTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([NamespaceRegistrationTransactionV1.TRANSACTION_TYPE.value, NamespaceRegistrationTransactionV1.TRANSACTION_VERSION]), NamespaceRegistrationTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([AccountAddressRestrictionTransactionV1.TRANSACTION_TYPE.value, AccountAddressRestrictionTransactionV1.TRANSACTION_VERSION]), AccountAddressRestrictionTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([AccountMosaicRestrictionTransactionV1.TRANSACTION_TYPE.value, AccountMosaicRestrictionTransactionV1.TRANSACTION_VERSION]), AccountMosaicRestrictionTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([AccountOperationRestrictionTransactionV1.TRANSACTION_TYPE.value, AccountOperationRestrictionTransactionV1.TRANSACTION_VERSION]), AccountOperationRestrictionTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([MosaicAddressRestrictionTransactionV1.TRANSACTION_TYPE.value, MosaicAddressRestrictionTransactionV1.TRANSACTION_VERSION]), MosaicAddressRestrictionTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([MosaicGlobalRestrictionTransactionV1.TRANSACTION_TYPE.value, MosaicGlobalRestrictionTransactionV1.TRANSACTION_VERSION]), MosaicGlobalRestrictionTransactionV1);\n\t\tmapping.set(TransactionFactory.toKey([TransferTransactionV1.TRANSACTION_TYPE.value, TransferTransactionV1.TRANSACTION_VERSION]), TransferTransactionV1);\n\t\tconst discriminator = TransactionFactory.toKey([parent.type.value, parent.version]);\n\t\tconst factory_class = mapping.get(discriminator);\n\t\treturn factory_class.deserialize(view.buffer);\n\t}\n\n\tstatic createByName(entityName) {\n\t\tconst mapping = {\n\t\t\taccount_key_link_transaction_v1: AccountKeyLinkTransactionV1,\n\t\t\tnode_key_link_transaction_v1: NodeKeyLinkTransactionV1,\n\t\t\taggregate_complete_transaction_v1: AggregateCompleteTransactionV1,\n\t\t\taggregate_complete_transaction_v2: AggregateCompleteTransactionV2,\n\t\t\taggregate_bonded_transaction_v1: AggregateBondedTransactionV1,\n\t\t\taggregate_bonded_transaction_v2: AggregateBondedTransactionV2,\n\t\t\tvoting_key_link_transaction_v1: VotingKeyLinkTransactionV1,\n\t\t\tvrf_key_link_transaction_v1: VrfKeyLinkTransactionV1,\n\t\t\thash_lock_transaction_v1: HashLockTransactionV1,\n\t\t\tsecret_lock_transaction_v1: SecretLockTransactionV1,\n\t\t\tsecret_proof_transaction_v1: SecretProofTransactionV1,\n\t\t\taccount_metadata_transaction_v1: AccountMetadataTransactionV1,\n\t\t\tmosaic_metadata_transaction_v1: MosaicMetadataTransactionV1,\n\t\t\tnamespace_metadata_transaction_v1: NamespaceMetadataTransactionV1,\n\t\t\tmosaic_definition_transaction_v1: MosaicDefinitionTransactionV1,\n\t\t\tmosaic_supply_change_transaction_v1: MosaicSupplyChangeTransactionV1,\n\t\t\tmosaic_supply_revocation_transaction_v1: MosaicSupplyRevocationTransactionV1,\n\t\t\tmultisig_account_modification_transaction_v1: MultisigAccountModificationTransactionV1,\n\t\t\taddress_alias_transaction_v1: AddressAliasTransactionV1,\n\t\t\tmosaic_alias_transaction_v1: MosaicAliasTransactionV1,\n\t\t\tnamespace_registration_transaction_v1: NamespaceRegistrationTransactionV1,\n\t\t\taccount_address_restriction_transaction_v1: AccountAddressRestrictionTransactionV1,\n\t\t\taccount_mosaic_restriction_transaction_v1: AccountMosaicRestrictionTransactionV1,\n\t\t\taccount_operation_restriction_transaction_v1: AccountOperationRestrictionTransactionV1,\n\t\t\tmosaic_address_restriction_transaction_v1: MosaicAddressRestrictionTransactionV1,\n\t\t\tmosaic_global_restriction_transaction_v1: MosaicGlobalRestrictionTransactionV1,\n\t\t\ttransfer_transaction_v1: TransferTransactionV1\n\t\t};\n\n\t\tif (!Object.prototype.hasOwnProperty.call(mapping, entityName))\n\t\t\tthrow RangeError(`unknown Transaction type ${entityName}`);\n\n\t\treturn new mapping[entityName]();\n\t}\n}\n\nexport class EmbeddedTransactionFactory {\n\tstatic toKey(values) {\n\t\tif (1 === values.length)\n\t\t\treturn values[0];\n\n\t\t// assume each key is at most 32bits\n\t\treturn values.map(n => BigInt(n)).reduce((accumulator, value) => (accumulator << 32n) + value);\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst parent = new EmbeddedTransaction();\n\t\tEmbeddedTransaction._deserialize(new BufferView(payload), parent);\n\n\t\tconst view = new BufferView(payload);\n\t\tconst mapping = new Map();\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedAccountKeyLinkTransactionV1.TRANSACTION_TYPE.value, EmbeddedAccountKeyLinkTransactionV1.TRANSACTION_VERSION]), EmbeddedAccountKeyLinkTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedNodeKeyLinkTransactionV1.TRANSACTION_TYPE.value, EmbeddedNodeKeyLinkTransactionV1.TRANSACTION_VERSION]), EmbeddedNodeKeyLinkTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedVotingKeyLinkTransactionV1.TRANSACTION_TYPE.value, EmbeddedVotingKeyLinkTransactionV1.TRANSACTION_VERSION]), EmbeddedVotingKeyLinkTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedVrfKeyLinkTransactionV1.TRANSACTION_TYPE.value, EmbeddedVrfKeyLinkTransactionV1.TRANSACTION_VERSION]), EmbeddedVrfKeyLinkTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedHashLockTransactionV1.TRANSACTION_TYPE.value, EmbeddedHashLockTransactionV1.TRANSACTION_VERSION]), EmbeddedHashLockTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedSecretLockTransactionV1.TRANSACTION_TYPE.value, EmbeddedSecretLockTransactionV1.TRANSACTION_VERSION]), EmbeddedSecretLockTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedSecretProofTransactionV1.TRANSACTION_TYPE.value, EmbeddedSecretProofTransactionV1.TRANSACTION_VERSION]), EmbeddedSecretProofTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedAccountMetadataTransactionV1.TRANSACTION_TYPE.value, EmbeddedAccountMetadataTransactionV1.TRANSACTION_VERSION]), EmbeddedAccountMetadataTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedMosaicMetadataTransactionV1.TRANSACTION_TYPE.value, EmbeddedMosaicMetadataTransactionV1.TRANSACTION_VERSION]), EmbeddedMosaicMetadataTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedNamespaceMetadataTransactionV1.TRANSACTION_TYPE.value, EmbeddedNamespaceMetadataTransactionV1.TRANSACTION_VERSION]), EmbeddedNamespaceMetadataTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedMosaicDefinitionTransactionV1.TRANSACTION_TYPE.value, EmbeddedMosaicDefinitionTransactionV1.TRANSACTION_VERSION]), EmbeddedMosaicDefinitionTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedMosaicSupplyChangeTransactionV1.TRANSACTION_TYPE.value, EmbeddedMosaicSupplyChangeTransactionV1.TRANSACTION_VERSION]), EmbeddedMosaicSupplyChangeTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedMosaicSupplyRevocationTransactionV1.TRANSACTION_TYPE.value, EmbeddedMosaicSupplyRevocationTransactionV1.TRANSACTION_VERSION]), EmbeddedMosaicSupplyRevocationTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedMultisigAccountModificationTransactionV1.TRANSACTION_TYPE.value, EmbeddedMultisigAccountModificationTransactionV1.TRANSACTION_VERSION]), EmbeddedMultisigAccountModificationTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedAddressAliasTransactionV1.TRANSACTION_TYPE.value, EmbeddedAddressAliasTransactionV1.TRANSACTION_VERSION]), EmbeddedAddressAliasTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedMosaicAliasTransactionV1.TRANSACTION_TYPE.value, EmbeddedMosaicAliasTransactionV1.TRANSACTION_VERSION]), EmbeddedMosaicAliasTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedNamespaceRegistrationTransactionV1.TRANSACTION_TYPE.value, EmbeddedNamespaceRegistrationTransactionV1.TRANSACTION_VERSION]), EmbeddedNamespaceRegistrationTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedAccountAddressRestrictionTransactionV1.TRANSACTION_TYPE.value, EmbeddedAccountAddressRestrictionTransactionV1.TRANSACTION_VERSION]), EmbeddedAccountAddressRestrictionTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedAccountMosaicRestrictionTransactionV1.TRANSACTION_TYPE.value, EmbeddedAccountMosaicRestrictionTransactionV1.TRANSACTION_VERSION]), EmbeddedAccountMosaicRestrictionTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedAccountOperationRestrictionTransactionV1.TRANSACTION_TYPE.value, EmbeddedAccountOperationRestrictionTransactionV1.TRANSACTION_VERSION]), EmbeddedAccountOperationRestrictionTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedMosaicAddressRestrictionTransactionV1.TRANSACTION_TYPE.value, EmbeddedMosaicAddressRestrictionTransactionV1.TRANSACTION_VERSION]), EmbeddedMosaicAddressRestrictionTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedMosaicGlobalRestrictionTransactionV1.TRANSACTION_TYPE.value, EmbeddedMosaicGlobalRestrictionTransactionV1.TRANSACTION_VERSION]), EmbeddedMosaicGlobalRestrictionTransactionV1);\n\t\tmapping.set(EmbeddedTransactionFactory.toKey([EmbeddedTransferTransactionV1.TRANSACTION_TYPE.value, EmbeddedTransferTransactionV1.TRANSACTION_VERSION]), EmbeddedTransferTransactionV1);\n\t\tconst discriminator = EmbeddedTransactionFactory.toKey([parent.type.value, parent.version]);\n\t\tconst factory_class = mapping.get(discriminator);\n\t\treturn factory_class.deserialize(view.buffer);\n\t}\n\n\tstatic createByName(entityName) {\n\t\tconst mapping = {\n\t\t\taccount_key_link_transaction_v1: EmbeddedAccountKeyLinkTransactionV1,\n\t\t\tnode_key_link_transaction_v1: EmbeddedNodeKeyLinkTransactionV1,\n\t\t\tvoting_key_link_transaction_v1: EmbeddedVotingKeyLinkTransactionV1,\n\t\t\tvrf_key_link_transaction_v1: EmbeddedVrfKeyLinkTransactionV1,\n\t\t\thash_lock_transaction_v1: EmbeddedHashLockTransactionV1,\n\t\t\tsecret_lock_transaction_v1: EmbeddedSecretLockTransactionV1,\n\t\t\tsecret_proof_transaction_v1: EmbeddedSecretProofTransactionV1,\n\t\t\taccount_metadata_transaction_v1: EmbeddedAccountMetadataTransactionV1,\n\t\t\tmosaic_metadata_transaction_v1: EmbeddedMosaicMetadataTransactionV1,\n\t\t\tnamespace_metadata_transaction_v1: EmbeddedNamespaceMetadataTransactionV1,\n\t\t\tmosaic_definition_transaction_v1: EmbeddedMosaicDefinitionTransactionV1,\n\t\t\tmosaic_supply_change_transaction_v1: EmbeddedMosaicSupplyChangeTransactionV1,\n\t\t\tmosaic_supply_revocation_transaction_v1: EmbeddedMosaicSupplyRevocationTransactionV1,\n\t\t\tmultisig_account_modification_transaction_v1: EmbeddedMultisigAccountModificationTransactionV1,\n\t\t\taddress_alias_transaction_v1: EmbeddedAddressAliasTransactionV1,\n\t\t\tmosaic_alias_transaction_v1: EmbeddedMosaicAliasTransactionV1,\n\t\t\tnamespace_registration_transaction_v1: EmbeddedNamespaceRegistrationTransactionV1,\n\t\t\taccount_address_restriction_transaction_v1: EmbeddedAccountAddressRestrictionTransactionV1,\n\t\t\taccount_mosaic_restriction_transaction_v1: EmbeddedAccountMosaicRestrictionTransactionV1,\n\t\t\taccount_operation_restriction_transaction_v1: EmbeddedAccountOperationRestrictionTransactionV1,\n\t\t\tmosaic_address_restriction_transaction_v1: EmbeddedMosaicAddressRestrictionTransactionV1,\n\t\t\tmosaic_global_restriction_transaction_v1: EmbeddedMosaicGlobalRestrictionTransactionV1,\n\t\t\ttransfer_transaction_v1: EmbeddedTransferTransactionV1\n\t\t};\n\n\t\tif (!Object.prototype.hasOwnProperty.call(mapping, entityName))\n\t\t\tthrow RangeError(`unknown EmbeddedTransaction type ${entityName}`);\n\n\t\treturn new mapping[entityName]();\n\t}\n}\n\nexport class BlockFactory {\n\tstatic toKey(values) {\n\t\tif (1 === values.length)\n\t\t\treturn values[0];\n\n\t\t// assume each key is at most 32bits\n\t\treturn values.map(n => BigInt(n)).reduce((accumulator, value) => (accumulator << 32n) + value);\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst parent = new Block();\n\t\tBlock._deserialize(new BufferView(payload), parent);\n\n\t\tconst view = new BufferView(payload);\n\t\tconst mapping = new Map();\n\t\tmapping.set(BlockFactory.toKey([NemesisBlockV1.BLOCK_TYPE.value]), NemesisBlockV1);\n\t\tmapping.set(BlockFactory.toKey([NormalBlockV1.BLOCK_TYPE.value]), NormalBlockV1);\n\t\tmapping.set(BlockFactory.toKey([ImportanceBlockV1.BLOCK_TYPE.value]), ImportanceBlockV1);\n\t\tconst discriminator = BlockFactory.toKey([parent.type.value]);\n\t\tconst factory_class = mapping.get(discriminator);\n\t\treturn factory_class.deserialize(view.buffer);\n\t}\n\n\tstatic createByName(entityName) {\n\t\tconst mapping = {\n\t\t\tnemesis_block_v1: NemesisBlockV1,\n\t\t\tnormal_block_v1: NormalBlockV1,\n\t\t\timportance_block_v1: ImportanceBlockV1\n\t\t};\n\n\t\tif (!Object.prototype.hasOwnProperty.call(mapping, entityName))\n\t\t\tthrow RangeError(`unknown Block type ${entityName}`);\n\n\t\treturn new mapping[entityName]();\n\t}\n}\n\nexport class ReceiptFactory {\n\tstatic toKey(values) {\n\t\tif (1 === values.length)\n\t\t\treturn values[0];\n\n\t\t// assume each key is at most 32bits\n\t\treturn values.map(n => BigInt(n)).reduce((accumulator, value) => (accumulator << 32n) + value);\n\t}\n\n\tstatic deserialize(payload) {\n\t\tconst parent = new Receipt();\n\t\tReceipt._deserialize(new BufferView(payload), parent);\n\n\t\tconst view = new BufferView(payload);\n\t\tconst mapping = new Map();\n\t\tmapping.set(ReceiptFactory.toKey([HarvestFeeReceipt.RECEIPT_TYPE.value]), HarvestFeeReceipt);\n\t\tmapping.set(ReceiptFactory.toKey([InflationReceipt.RECEIPT_TYPE.value]), InflationReceipt);\n\t\tmapping.set(ReceiptFactory.toKey([LockHashCreatedFeeReceipt.RECEIPT_TYPE.value]), LockHashCreatedFeeReceipt);\n\t\tmapping.set(ReceiptFactory.toKey([LockHashCompletedFeeReceipt.RECEIPT_TYPE.value]), LockHashCompletedFeeReceipt);\n\t\tmapping.set(ReceiptFactory.toKey([LockHashExpiredFeeReceipt.RECEIPT_TYPE.value]), LockHashExpiredFeeReceipt);\n\t\tmapping.set(ReceiptFactory.toKey([LockSecretCreatedFeeReceipt.RECEIPT_TYPE.value]), LockSecretCreatedFeeReceipt);\n\t\tmapping.set(ReceiptFactory.toKey([LockSecretCompletedFeeReceipt.RECEIPT_TYPE.value]), LockSecretCompletedFeeReceipt);\n\t\tmapping.set(ReceiptFactory.toKey([LockSecretExpiredFeeReceipt.RECEIPT_TYPE.value]), LockSecretExpiredFeeReceipt);\n\t\tmapping.set(ReceiptFactory.toKey([MosaicExpiredReceipt.RECEIPT_TYPE.value]), MosaicExpiredReceipt);\n\t\tmapping.set(ReceiptFactory.toKey([MosaicRentalFeeReceipt.RECEIPT_TYPE.value]), MosaicRentalFeeReceipt);\n\t\tmapping.set(ReceiptFactory.toKey([NamespaceExpiredReceipt.RECEIPT_TYPE.value]), NamespaceExpiredReceipt);\n\t\tmapping.set(ReceiptFactory.toKey([NamespaceDeletedReceipt.RECEIPT_TYPE.value]), NamespaceDeletedReceipt);\n\t\tmapping.set(ReceiptFactory.toKey([NamespaceRentalFeeReceipt.RECEIPT_TYPE.value]), NamespaceRentalFeeReceipt);\n\t\tconst discriminator = ReceiptFactory.toKey([parent.type.value]);\n\t\tconst factory_class = mapping.get(discriminator);\n\t\treturn factory_class.deserialize(view.buffer);\n\t}\n\n\tstatic createByName(entityName) {\n\t\tconst mapping = {\n\t\t\tharvest_fee_receipt: HarvestFeeReceipt,\n\t\t\tinflation_receipt: InflationReceipt,\n\t\t\tlock_hash_created_fee_receipt: LockHashCreatedFeeReceipt,\n\t\t\tlock_hash_completed_fee_receipt: LockHashCompletedFeeReceipt,\n\t\t\tlock_hash_expired_fee_receipt: LockHashExpiredFeeReceipt,\n\t\t\tlock_secret_created_fee_receipt: LockSecretCreatedFeeReceipt,\n\t\t\tlock_secret_completed_fee_receipt: LockSecretCompletedFeeReceipt,\n\t\t\tlock_secret_expired_fee_receipt: LockSecretExpiredFeeReceipt,\n\t\t\tmosaic_expired_receipt: MosaicExpiredReceipt,\n\t\t\tmosaic_rental_fee_receipt: MosaicRentalFeeReceipt,\n\t\t\tnamespace_expired_receipt: NamespaceExpiredReceipt,\n\t\t\tnamespace_deleted_receipt: NamespaceDeletedReceipt,\n\t\t\tnamespace_rental_fee_receipt: NamespaceRentalFeeReceipt\n\t\t};\n\n\t\tif (!Object.prototype.hasOwnProperty.call(mapping, entityName))\n\t\t\tthrow RangeError(`unknown Receipt type ${entityName}`);\n\n\t\treturn new mapping[entityName]();\n\t}\n}\n","/* eslint-disable max-len */\n\nimport { Address } from './Network.js';\nimport * as models from './models.js';\nimport { Hash256, PublicKey } from '../CryptoTypes.js';\n\n/**\n * Type safe descriptor used to generate a descriptor map for MosaicDescriptor.\n *\n * A quantity of a certain mosaic.\n */\nexport class MosaicDescriptor {\n\t/**\n\t * Creates a descriptor for Mosaic.\n\t * @param {models.MosaicId} mosaicId Mosaic identifier.\n\t * @param {models.Amount} amount Mosaic amount.\n\t */\n\tconstructor(mosaicId, amount) {\n\t\tthis.rawDescriptor = {\n\t\t\tmosaicId,\n\t\t\tamount\n\t\t};\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for UnresolvedMosaicDescriptor.\n *\n * A quantity of a certain mosaic, specified either through a MosaicId or an alias.\n */\nexport class UnresolvedMosaicDescriptor {\n\t/**\n\t * Creates a descriptor for UnresolvedMosaic.\n\t * @param {models.UnresolvedMosaicId} mosaicId Unresolved mosaic identifier.\n\t * @param {models.Amount} amount Mosaic amount.\n\t */\n\tconstructor(mosaicId, amount) {\n\t\tthis.rawDescriptor = {\n\t\t\tmosaicId,\n\t\t\tamount\n\t\t};\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for AccountKeyLinkTransactionV1Descriptor.\n *\n * This transaction is required for all accounts wanting to activate remote or delegated harvesting (V1, latest).\n * Announce an AccountKeyLinkTransaction to delegate the account importance score to a proxy account.\n */\nexport class AccountKeyLinkTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for AccountKeyLinkTransactionV1.\n\t * @param {PublicKey} linkedPublicKey Linked public key.\n\t * @param {models.LinkAction} linkAction Account link action.\n\t */\n\tconstructor(linkedPublicKey, linkAction) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'account_key_link_transaction_v1',\n\t\t\tlinkedPublicKey,\n\t\t\tlinkAction\n\t\t};\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for NodeKeyLinkTransactionV1Descriptor.\n *\n * This transaction is required for all accounts willing to activate delegated harvesting (V1, latest).\n * Announce a NodeKeyLinkTransaction to link an account with a public key used by TLS to create sessions.\n */\nexport class NodeKeyLinkTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for NodeKeyLinkTransactionV1.\n\t * @param {PublicKey} linkedPublicKey Linked public key.\n\t * @param {models.LinkAction} linkAction Account link action.\n\t */\n\tconstructor(linkedPublicKey, linkAction) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'node_key_link_transaction_v1',\n\t\t\tlinkedPublicKey,\n\t\t\tlinkAction\n\t\t};\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for CosignatureDescriptor.\n *\n * Cosignature attached to an AggregateCompleteTransaction or AggregateBondedTransaction.\n */\nexport class CosignatureDescriptor {\n\t/**\n\t * Creates a descriptor for Cosignature.\n\t * @param {bigint} version Version.\n\t * @param {PublicKey} signerPublicKey Cosigner public key.\n\t * @param {models.Signature} signature Transaction signature.\n\t */\n\tconstructor(version, signerPublicKey, signature) {\n\t\tthis.rawDescriptor = {\n\t\t\tversion,\n\t\t\tsignerPublicKey,\n\t\t\tsignature\n\t\t};\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for DetachedCosignatureDescriptor.\n *\n * Cosignature detached from an AggregateCompleteTransaction or AggregateBondedTransaction.\n */\nexport class DetachedCosignatureDescriptor {\n\t/**\n\t * Creates a descriptor for DetachedCosignature.\n\t * @param {bigint} version Version.\n\t * @param {PublicKey} signerPublicKey Cosigner public key.\n\t * @param {models.Signature} signature Transaction signature.\n\t * @param {Hash256} parentHash Hash of the AggregateBondedTransaction that is signed by this cosignature.\n\t */\n\tconstructor(version, signerPublicKey, signature, parentHash) {\n\t\tthis.rawDescriptor = {\n\t\t\tversion,\n\t\t\tsignerPublicKey,\n\t\t\tsignature,\n\t\t\tparentHash\n\t\t};\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for AggregateCompleteTransactionV1Descriptor.\n *\n * Send transactions in batches to different accounts (V1, deprecated).\n * Use this transaction when all required signatures are available when the transaction is created.\n */\nexport class AggregateCompleteTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for AggregateCompleteTransactionV1.\n\t * @param {Hash256} transactionsHash Hash of the aggregate's transaction.\n\t * @param {models.EmbeddedTransaction[]|undefined} transactions Embedded transaction data.\n\tTransactions are variable-sized and the total payload size is in bytes.\n\tEmbedded transactions cannot be aggregates.\n\t * @param {models.Cosignature[]|undefined} cosignatures Cosignatures data.\n\tFills up remaining body space after transactions.\n\t */\n\tconstructor(transactionsHash, transactions = undefined, cosignatures = undefined) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'aggregate_complete_transaction_v1',\n\t\t\ttransactionsHash\n\t\t};\n\n\t\tif (transactions)\n\t\t\tthis.rawDescriptor.transactions = transactions;\n\n\t\tif (cosignatures)\n\t\t\tthis.rawDescriptor.cosignatures = cosignatures;\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for AggregateCompleteTransactionV2Descriptor.\n *\n * Send transactions in batches to different accounts (V2, latest).\n * Use this transaction when all required signatures are available when the transaction is created.\n */\nexport class AggregateCompleteTransactionV2Descriptor {\n\t/**\n\t * Creates a descriptor for AggregateCompleteTransactionV2.\n\t * @param {Hash256} transactionsHash Hash of the aggregate's transaction.\n\t * @param {models.EmbeddedTransaction[]|undefined} transactions Embedded transaction data.\n\tTransactions are variable-sized and the total payload size is in bytes.\n\tEmbedded transactions cannot be aggregates.\n\t * @param {models.Cosignature[]|undefined} cosignatures Cosignatures data.\n\tFills up remaining body space after transactions.\n\t */\n\tconstructor(transactionsHash, transactions = undefined, cosignatures = undefined) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'aggregate_complete_transaction_v2',\n\t\t\ttransactionsHash\n\t\t};\n\n\t\tif (transactions)\n\t\t\tthis.rawDescriptor.transactions = transactions;\n\n\t\tif (cosignatures)\n\t\t\tthis.rawDescriptor.cosignatures = cosignatures;\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for AggregateBondedTransactionV1Descriptor.\n *\n * Propose an arrangement of transactions between different accounts (V1, deprecated).\n * Use this transaction when not all required signatures are available when the transaction is created.\n * Missing signatures must be provided using a Cosignature or DetachedCosignature.\n * To prevent spam attacks, before trying to announce this transaction a HashLockTransaction must be successfully announced and confirmed.\n */\nexport class AggregateBondedTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for AggregateBondedTransactionV1.\n\t * @param {Hash256} transactionsHash Hash of the aggregate's transaction.\n\t * @param {models.EmbeddedTransaction[]|undefined} transactions Embedded transaction data.\n\tTransactions are variable-sized and the total payload size is in bytes.\n\tEmbedded transactions cannot be aggregates.\n\t * @param {models.Cosignature[]|undefined} cosignatures Cosignatures data.\n\tFills up remaining body space after transactions.\n\t */\n\tconstructor(transactionsHash, transactions = undefined, cosignatures = undefined) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'aggregate_bonded_transaction_v1',\n\t\t\ttransactionsHash\n\t\t};\n\n\t\tif (transactions)\n\t\t\tthis.rawDescriptor.transactions = transactions;\n\n\t\tif (cosignatures)\n\t\t\tthis.rawDescriptor.cosignatures = cosignatures;\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for AggregateBondedTransactionV2Descriptor.\n *\n * Propose an arrangement of transactions between different accounts (V2, latest).\n * Use this transaction when not all required signatures are available when the transaction is created.\n * Missing signatures must be provided using a Cosignature or DetachedCosignature.\n * To prevent spam attacks, before trying to announce this transaction a HashLockTransaction must be successfully announced and confirmed.\n */\nexport class AggregateBondedTransactionV2Descriptor {\n\t/**\n\t * Creates a descriptor for AggregateBondedTransactionV2.\n\t * @param {Hash256} transactionsHash Hash of the aggregate's transaction.\n\t * @param {models.EmbeddedTransaction[]|undefined} transactions Embedded transaction data.\n\tTransactions are variable-sized and the total payload size is in bytes.\n\tEmbedded transactions cannot be aggregates.\n\t * @param {models.Cosignature[]|undefined} cosignatures Cosignatures data.\n\tFills up remaining body space after transactions.\n\t */\n\tconstructor(transactionsHash, transactions = undefined, cosignatures = undefined) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'aggregate_bonded_transaction_v2',\n\t\t\ttransactionsHash\n\t\t};\n\n\t\tif (transactions)\n\t\t\tthis.rawDescriptor.transactions = transactions;\n\n\t\tif (cosignatures)\n\t\t\tthis.rawDescriptor.cosignatures = cosignatures;\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for VotingKeyLinkTransactionV1Descriptor.\n *\n * Link an account with a public key required for finalization voting (V1, latest).\n * This transaction is required for node operators wanting to vote for [finalization](/concepts/block.html#finalization).\n * Announce a VotingKeyLinkTransaction to associate a voting key with an account during a fixed period. An account can be linked to up to **3** different voting keys at the same time.\n * The recommended production setting is to always have at least **2** linked keys with different ``endPoint`` values to ensure a key is registered after the first one expires.\n * See more details in [the manual node setup guide](/guides/network/running-a-symbol-node-manually.html#manual-voting-key-renewal).\n */\nexport class VotingKeyLinkTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for VotingKeyLinkTransactionV1.\n\t * @param {PublicKey} linkedPublicKey Linked voting public key.\n\t * @param {models.FinalizationEpoch} startEpoch Starting finalization epoch.\n\t * @param {models.FinalizationEpoch} endEpoch Ending finalization epoch.\n\t * @param {models.LinkAction} linkAction Account link action.\n\t */\n\tconstructor(linkedPublicKey, startEpoch, endEpoch, linkAction) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'voting_key_link_transaction_v1',\n\t\t\tlinkedPublicKey,\n\t\t\tstartEpoch,\n\t\t\tendEpoch,\n\t\t\tlinkAction\n\t\t};\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for VrfKeyLinkTransactionV1Descriptor.\n *\n * Link an account with a VRF public key required for harvesting (V1, latest).\n * Announce a VrfKeyLinkTransaction to link an account with a VRF public key. The linked key is used to randomize block production and leader/participant selection.\n * This transaction is required for all accounts wishing to [harvest](/concepts/harvesting.html).\n */\nexport class VrfKeyLinkTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for VrfKeyLinkTransactionV1.\n\t * @param {PublicKey} linkedPublicKey Linked VRF public key.\n\t * @param {models.LinkAction} linkAction Account link action.\n\t */\n\tconstructor(linkedPublicKey, linkAction) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'vrf_key_link_transaction_v1',\n\t\t\tlinkedPublicKey,\n\t\t\tlinkAction\n\t\t};\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for HashLockTransactionV1Descriptor.\n *\n * Lock a deposit needed to announce an AggregateBondedTransaction (V1, latest).\n * An AggregateBondedTransaction consumes network resources as it is stored in every node's partial cache while it waits to be fully signed. To avoid spam attacks a HashLockTransaction must be announced and confirmed before an AggregateBondedTransaction can be announced. The HashLockTransaction locks a certain amount of funds (**10** XYM by default) until the aggregate is signed.\n * Upon completion of the aggregate, the locked funds become available again to the account that signed the HashLockTransaction.\n * If the lock expires before the aggregate is signed by all cosignatories (**48h by default), the locked funds become a reward collected by the block harvester at the height where the lock expires.\n * \\note It is not necessary to sign the aggregate and its HashLockTransaction with the same account. For example, if Bob wants to announce an aggregate and does not have enough funds to announce a HashLockTransaction, he can ask Alice to announce the lock transaction for him by sharing the signed AggregateTransaction hash.\n */\nexport class HashLockTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for HashLockTransactionV1.\n\t * @param {UnresolvedMosaicDescriptor} mosaic Locked mosaic.\n\t * @param {models.BlockDuration} duration Number of blocks for which a lock should be valid.\n\tThe default maximum is 48h (See the `maxHashLockDuration` network property).\n\t * @param {Hash256} hash Hash of the AggregateBondedTransaction to be confirmed before unlocking the mosaics.\n\t */\n\tconstructor(mosaic, duration, hash) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'hash_lock_transaction_v1',\n\t\t\tmosaic: mosaic.toMap(),\n\t\t\tduration,\n\t\t\thash\n\t\t};\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for SecretLockTransactionV1Descriptor.\n *\n * Start a token swap between different chains (V1, latest).\n * Use a SecretLockTransaction to transfer mosaics between two accounts. The mosaics sent remain locked until a valid SecretProofTransaction unlocks them.\n * The default expiration date is **365 days** after announcement (See the `maxSecretLockDuration` network property). If the lock expires before a valid SecretProofTransaction is announced the locked amount goes back to the initiator of the SecretLockTransaction.\n */\nexport class SecretLockTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for SecretLockTransactionV1.\n\t * @param {Address} recipientAddress Address that receives the funds once successfully unlocked by a SecretProofTransaction.\n\t * @param {Hash256} secret Hashed proof.\n\t * @param {UnresolvedMosaicDescriptor} mosaic Locked mosaics.\n\t * @param {models.BlockDuration} duration Number of blocks to wait for the SecretProofTransaction.\n\t * @param {models.LockHashAlgorithm} hashAlgorithm Algorithm used to hash the proof.\n\t */\n\tconstructor(recipientAddress, secret, mosaic, duration, hashAlgorithm) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'secret_lock_transaction_v1',\n\t\t\trecipientAddress,\n\t\t\tsecret,\n\t\t\tmosaic: mosaic.toMap(),\n\t\t\tduration,\n\t\t\thashAlgorithm\n\t\t};\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for SecretProofTransactionV1Descriptor.\n *\n * Conclude a token swap between different chains (V1, latest).\n * Use a SecretProofTransaction to unlock the funds locked by a SecretLockTransaction.\n * The transaction must prove knowing the *proof* that unlocks the mosaics.\n */\nexport class SecretProofTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for SecretProofTransactionV1.\n\t * @param {Address} recipientAddress Address that receives the funds once unlocked.\n\t * @param {Hash256} secret Hashed proof.\n\t * @param {models.LockHashAlgorithm} hashAlgorithm Algorithm used to hash the proof.\n\t * @param {Uint8Array|string|undefined} proof Original random set of bytes that were hashed.\n\t */\n\tconstructor(recipientAddress, secret, hashAlgorithm, proof = undefined) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'secret_proof_transaction_v1',\n\t\t\trecipientAddress,\n\t\t\tsecret,\n\t\t\thashAlgorithm\n\t\t};\n\n\t\tif (proof)\n\t\t\tthis.rawDescriptor.proof = proof;\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for AccountMetadataTransactionV1Descriptor.\n *\n * Associate a key-value state ([metadata](/concepts/metadata.html)) to an **account** (V1, latest).\n * \\note This transaction must **always** be wrapped in an AggregateTransaction so that a cosignature from `target_address` can be provided. Without this cosignature the transaction is invalid.\n * Compare to MosaicMetadataTransaction and NamespaceMetadataTransaction.\n */\nexport class AccountMetadataTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for AccountMetadataTransactionV1.\n\t * @param {Address} targetAddress Account whose metadata should be modified.\n\t * @param {bigint} scopedMetadataKey Metadata key scoped to source, target and type.\n\t * @param {number} valueSizeDelta Change in value size in bytes, compared to previous size.\n\t * @param {Uint8Array|string|undefined} value Difference between existing value and new value. \\note When there is no existing value, this array is directly used and `value_size_delta`==`value_size`. \\note When there is an existing value, the new value is the byte-wise XOR of the previous value and this array.\n\t */\n\tconstructor(targetAddress, scopedMetadataKey, valueSizeDelta, value = undefined) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'account_metadata_transaction_v1',\n\t\t\ttargetAddress,\n\t\t\tscopedMetadataKey,\n\t\t\tvalueSizeDelta\n\t\t};\n\n\t\tif (value)\n\t\t\tthis.rawDescriptor.value = value;\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for MosaicMetadataTransactionV1Descriptor.\n *\n * Associate a key-value state ([metadata](/concepts/metadata.html)) to a **mosaic** (V1, latest).\n * Compare to AccountMetadataTransaction and NamespaceMetadataTransaction.\n */\nexport class MosaicMetadataTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for MosaicMetadataTransactionV1.\n\t * @param {Address} targetAddress Account owning the mosaic whose metadata should be modified.\n\t * @param {bigint} scopedMetadataKey Metadata key scoped to source, target and type.\n\t * @param {models.UnresolvedMosaicId} targetMosaicId Mosaic whose metadata should be modified.\n\t * @param {number} valueSizeDelta Change in value size in bytes, compared to previous size.\n\t * @param {Uint8Array|string|undefined} value Difference between existing value and new value. \\note When there is no existing value, this array is directly used and `value_size_delta`==`value_size`. \\note When there is an existing value, the new value is the byte-wise XOR of the previous value and this array.\n\t */\n\tconstructor(targetAddress, scopedMetadataKey, targetMosaicId, valueSizeDelta, value = undefined) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'mosaic_metadata_transaction_v1',\n\t\t\ttargetAddress,\n\t\t\tscopedMetadataKey,\n\t\t\ttargetMosaicId,\n\t\t\tvalueSizeDelta\n\t\t};\n\n\t\tif (value)\n\t\t\tthis.rawDescriptor.value = value;\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for NamespaceMetadataTransactionV1Descriptor.\n *\n * Associate a key-value state ([metadata](/concepts/metadata.html)) to a **namespace** (V1, latest).\n * Compare to AccountMetadataTransaction and MosaicMetadataTransaction.\n */\nexport class NamespaceMetadataTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for NamespaceMetadataTransactionV1.\n\t * @param {Address} targetAddress Account owning the namespace whose metadata should be modified.\n\t * @param {bigint} scopedMetadataKey Metadata key scoped to source, target and type.\n\t * @param {models.NamespaceId} targetNamespaceId Namespace whose metadata should be modified.\n\t * @param {number} valueSizeDelta Change in value size in bytes, compared to previous size.\n\t * @param {Uint8Array|string|undefined} value Difference between existing value and new value. \\note When there is no existing value, this array is directly used and `value_size_delta`==`value_size`. \\note When there is an existing value, the new value is the byte-wise XOR of the previous value and this array.\n\t */\n\tconstructor(targetAddress, scopedMetadataKey, targetNamespaceId, valueSizeDelta, value = undefined) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'namespace_metadata_transaction_v1',\n\t\t\ttargetAddress,\n\t\t\tscopedMetadataKey,\n\t\t\ttargetNamespaceId,\n\t\t\tvalueSizeDelta\n\t\t};\n\n\t\tif (value)\n\t\t\tthis.rawDescriptor.value = value;\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for MosaicDefinitionTransactionV1Descriptor.\n *\n * Create a new  [mosaic](/concepts/mosaic.html) (V1, latest).\n */\nexport class MosaicDefinitionTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for MosaicDefinitionTransactionV1.\n\t * @param {models.MosaicId} id Unique mosaic identifier obtained from the generator account's public key and the `nonce`.\n\tThe SDK's can take care of generating this ID for you.\n\t * @param {models.BlockDuration} duration Mosaic duration expressed in blocks. If set to 0, the mosaic never expires.\n\t * @param {models.MosaicNonce} nonce Random nonce used to generate the mosaic id.\n\t * @param {models.MosaicFlags} flags Mosaic flags.\n\t * @param {number} divisibility Mosaic divisibility.\n\t */\n\tconstructor(id, duration, nonce, flags, divisibility) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'mosaic_definition_transaction_v1',\n\t\t\tid,\n\t\t\tduration,\n\t\t\tnonce,\n\t\t\tflags,\n\t\t\tdivisibility\n\t\t};\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for MosaicSupplyChangeTransactionV1Descriptor.\n *\n * Change the total supply of a mosaic (V1, latest).\n */\nexport class MosaicSupplyChangeTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for MosaicSupplyChangeTransactionV1.\n\t * @param {models.UnresolvedMosaicId} mosaicId Affected mosaic identifier.\n\t * @param {models.Amount} delta Change amount. It cannot be negative, use the `action` field to indicate if this amount should be **added** or **subtracted** from the current supply.\n\t * @param {models.MosaicSupplyChangeAction} action Supply change action.\n\t */\n\tconstructor(mosaicId, delta, action) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'mosaic_supply_change_transaction_v1',\n\t\t\tmosaicId,\n\t\t\tdelta,\n\t\t\taction\n\t\t};\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for MosaicSupplyRevocationTransactionV1Descriptor.\n *\n * Revoke mosaic (V1, latest).\n */\nexport class MosaicSupplyRevocationTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for MosaicSupplyRevocationTransactionV1.\n\t * @param {Address} sourceAddress Address from which tokens should be revoked.\n\t * @param {UnresolvedMosaicDescriptor} mosaic Revoked mosaic and amount.\n\t */\n\tconstructor(sourceAddress, mosaic) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'mosaic_supply_revocation_transaction_v1',\n\t\t\tsourceAddress,\n\t\t\tmosaic: mosaic.toMap()\n\t\t};\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for MultisigAccountModificationTransactionV1Descriptor.\n *\n * Create or modify a [multi-signature](/concepts/multisig-account.html) account (V1, latest).\n * This transaction allows you to: - Transform a regular account into a multisig account. - Change the configurable properties of a multisig account. - Add or delete cosignatories from a multisig account (removing all cosignatories turns a multisig account into a regular account again).\n */\nexport class MultisigAccountModificationTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for MultisigAccountModificationTransactionV1.\n\t * @param {number} minRemovalDelta Relative change to the **minimum** number of cosignatures required when **removing a cosignatory**.\n\tE.g., when moving from 0 to 2 cosignatures this number would be **2**. When moving from 4 to 3 cosignatures, the number would be **-1**.\n\t * @param {number} minApprovalDelta Relative change to the **minimum** number of cosignatures required when **approving a transaction**.\n\tE.g., when moving from 0 to 2 cosignatures this number would be **2**. When moving from 4 to 3 cosignatures, the number would be **-1**.\n\t * @param {Address[]|undefined} addressAdditions Cosignatory address additions.\n\tAll accounts in this list will be able to cosign transactions on behalf of the multisig account. The number of required cosignatures depends on the configured minimum approval and minimum removal values.\n\t * @param {Address[]|undefined} addressDeletions Cosignatory address deletions.\n\tAll accounts in this list will stop being able to cosign transactions on behalf of the multisig account. A transaction containing **any** address in this array requires a number of cosignatures at least equal to the minimum removal value.\n\t */\n\tconstructor(minRemovalDelta, minApprovalDelta, addressAdditions = undefined, addressDeletions = undefined) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'multisig_account_modification_transaction_v1',\n\t\t\tminRemovalDelta,\n\t\t\tminApprovalDelta\n\t\t};\n\n\t\tif (addressAdditions)\n\t\t\tthis.rawDescriptor.addressAdditions = addressAdditions;\n\n\t\tif (addressDeletions)\n\t\t\tthis.rawDescriptor.addressDeletions = addressDeletions;\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for AddressAliasTransactionV1Descriptor.\n *\n * Attach or detach a [namespace](/concepts/namespace.html) (alias) to an account address (V1, latest).\n * A namespace can be assigned to any account present in the network (this is, an account which has received at least one transaction).\n */\nexport class AddressAliasTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for AddressAliasTransactionV1.\n\t * @param {models.NamespaceId} namespaceId Identifier of the namespace that will become (or stop being) an alias for the address.\n\t * @param {Address} address Aliased address.\n\t * @param {models.AliasAction} aliasAction Alias action.\n\t */\n\tconstructor(namespaceId, address, aliasAction) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'address_alias_transaction_v1',\n\t\t\tnamespaceId,\n\t\t\taddress,\n\t\t\taliasAction\n\t\t};\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for MosaicAliasTransactionV1Descriptor.\n *\n * Attach or detach a [namespace](/concepts/namespace.html) to a Mosaic.(V1, latest)\n * Setting an alias to a mosaic is only possible if the account announcing this transaction has also created the namespace and the mosaic involved.\n */\nexport class MosaicAliasTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for MosaicAliasTransactionV1.\n\t * @param {models.NamespaceId} namespaceId Identifier of the namespace that will become (or stop being) an alias for the Mosaic.\n\t * @param {models.MosaicId} mosaicId Aliased mosaic identifier.\n\t * @param {models.AliasAction} aliasAction Alias action.\n\t */\n\tconstructor(namespaceId, mosaicId, aliasAction) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'mosaic_alias_transaction_v1',\n\t\t\tnamespaceId,\n\t\t\tmosaicId,\n\t\t\taliasAction\n\t\t};\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for NamespaceRegistrationTransactionV1Descriptor.\n *\n * Register (or renew a registration for) a [namespace](/concepts/namespace.html) (V1, latest).\n * Namespaces help keep assets organized.\n */\nexport class NamespaceRegistrationTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for NamespaceRegistrationTransactionV1.\n\t * @param {models.NamespaceId} id Namespace identifier.\n\t * @param {models.NamespaceRegistrationType} registrationType Namespace registration type.\n\t * @param {models.BlockDuration|undefined} duration Number of confirmed blocks you would like to rent the namespace for. Required for root namespaces.\n\t * @param {models.NamespaceId|undefined} parentId Parent namespace identifier. Required for sub-namespaces.\n\t * @param {Uint8Array|string|undefined} name Namespace name.\n\t */\n\tconstructor(id, registrationType, duration = undefined, parentId = undefined, name = undefined) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'namespace_registration_transaction_v1',\n\t\t\tid,\n\t\t\tregistrationType\n\t\t};\n\n\t\tif (duration)\n\t\t\tthis.rawDescriptor.duration = duration;\n\n\t\tif (parentId)\n\t\t\tthis.rawDescriptor.parentId = parentId;\n\n\t\tif (name)\n\t\t\tthis.rawDescriptor.name = name;\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for AccountAddressRestrictionTransactionV1Descriptor.\n *\n * Allow or block incoming and outgoing transactions for a given a set of addresses (V1, latest).\n */\nexport class AccountAddressRestrictionTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for AccountAddressRestrictionTransactionV1.\n\t * @param {models.AccountRestrictionFlags} restrictionFlags Type of restriction being applied to the listed addresses.\n\t * @param {Address[]|undefined} restrictionAdditions Array of account addresses being added to the restricted list.\n\t * @param {Address[]|undefined} restrictionDeletions Array of account addresses being removed from the restricted list.\n\t */\n\tconstructor(restrictionFlags, restrictionAdditions = undefined, restrictionDeletions = undefined) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'account_address_restriction_transaction_v1',\n\t\t\trestrictionFlags\n\t\t};\n\n\t\tif (restrictionAdditions)\n\t\t\tthis.rawDescriptor.restrictionAdditions = restrictionAdditions;\n\n\t\tif (restrictionDeletions)\n\t\t\tthis.rawDescriptor.restrictionDeletions = restrictionDeletions;\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for AccountMosaicRestrictionTransactionV1Descriptor.\n *\n * Allow or block incoming transactions containing a given set of mosaics (V1, latest).\n */\nexport class AccountMosaicRestrictionTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for AccountMosaicRestrictionTransactionV1.\n\t * @param {models.AccountRestrictionFlags} restrictionFlags Type of restriction being applied to the listed mosaics.\n\t * @param {models.UnresolvedMosaicId[]|undefined} restrictionAdditions Array of mosaics being added to the restricted list.\n\t * @param {models.UnresolvedMosaicId[]|undefined} restrictionDeletions Array of mosaics being removed from the restricted list.\n\t */\n\tconstructor(restrictionFlags, restrictionAdditions = undefined, restrictionDeletions = undefined) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'account_mosaic_restriction_transaction_v1',\n\t\t\trestrictionFlags\n\t\t};\n\n\t\tif (restrictionAdditions)\n\t\t\tthis.rawDescriptor.restrictionAdditions = restrictionAdditions;\n\n\t\tif (restrictionDeletions)\n\t\t\tthis.rawDescriptor.restrictionDeletions = restrictionDeletions;\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for AccountOperationRestrictionTransactionV1Descriptor.\n *\n * Allow or block outgoing transactions depending on their transaction type (V1, latest).\n */\nexport class AccountOperationRestrictionTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for AccountOperationRestrictionTransactionV1.\n\t * @param {models.AccountRestrictionFlags} restrictionFlags Type of restriction being applied to the listed transaction types.\n\t * @param {models.TransactionType[]|undefined} restrictionAdditions Array of transaction types being added to the restricted list.\n\t * @param {models.TransactionType[]|undefined} restrictionDeletions Array of transaction types being rtemoved from the restricted list.\n\t */\n\tconstructor(restrictionFlags, restrictionAdditions = undefined, restrictionDeletions = undefined) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'account_operation_restriction_transaction_v1',\n\t\t\trestrictionFlags\n\t\t};\n\n\t\tif (restrictionAdditions)\n\t\t\tthis.rawDescriptor.restrictionAdditions = restrictionAdditions;\n\n\t\tif (restrictionDeletions)\n\t\t\tthis.rawDescriptor.restrictionDeletions = restrictionDeletions;\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for MosaicAddressRestrictionTransactionV1Descriptor.\n *\n * Set address specific rules to transfer a restrictable mosaic (V1, latest).\n */\nexport class MosaicAddressRestrictionTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for MosaicAddressRestrictionTransactionV1.\n\t * @param {models.UnresolvedMosaicId} mosaicId Identifier of the mosaic to which the restriction applies.\n\t * @param {bigint} restrictionKey Restriction key.\n\t * @param {bigint} previousRestrictionValue Previous restriction value. Set `previousRestrictionValue` to `FFFFFFFFFFFFFFFF` if the target address does not have a previous restriction value for this mosaic id and restriction key.\n\t * @param {bigint} newRestrictionValue New restriction value.\n\t * @param {Address} targetAddress Address being restricted.\n\t */\n\tconstructor(mosaicId, restrictionKey, previousRestrictionValue, newRestrictionValue, targetAddress) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'mosaic_address_restriction_transaction_v1',\n\t\t\tmosaicId,\n\t\t\trestrictionKey,\n\t\t\tpreviousRestrictionValue,\n\t\t\tnewRestrictionValue,\n\t\t\ttargetAddress\n\t\t};\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for MosaicGlobalRestrictionTransactionV1Descriptor.\n *\n * Set global rules to transfer a restrictable mosaic (V1, latest).\n */\nexport class MosaicGlobalRestrictionTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for MosaicGlobalRestrictionTransactionV1.\n\t * @param {models.UnresolvedMosaicId} mosaicId Identifier of the mosaic being restricted. The mosaic creator must be the signer of the transaction.\n\t * @param {models.UnresolvedMosaicId} referenceMosaicId Identifier of the mosaic providing the restriction key. The mosaic global restriction for the mosaic identifier depends on global restrictions set on the reference mosaic. Set `reference_mosaic_id` to **0** if the mosaic giving the restriction equals the `mosaic_id`.\n\t * @param {bigint} restrictionKey Restriction key relative to the reference mosaic identifier.\n\t * @param {bigint} previousRestrictionValue Previous restriction value.\n\t * @param {bigint} newRestrictionValue New restriction value.\n\t * @param {models.MosaicRestrictionType} previousRestrictionType Previous restriction type.\n\t * @param {models.MosaicRestrictionType} newRestrictionType New restriction type.\n\t */\n\tconstructor(\n\t\tmosaicId,\n\t\treferenceMosaicId,\n\t\trestrictionKey,\n\t\tpreviousRestrictionValue,\n\t\tnewRestrictionValue,\n\t\tpreviousRestrictionType,\n\t\tnewRestrictionType\n\t) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'mosaic_global_restriction_transaction_v1',\n\t\t\tmosaicId,\n\t\t\treferenceMosaicId,\n\t\t\trestrictionKey,\n\t\t\tpreviousRestrictionValue,\n\t\t\tnewRestrictionValue,\n\t\t\tpreviousRestrictionType,\n\t\t\tnewRestrictionType\n\t\t};\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n\n/**\n * Type safe descriptor used to generate a descriptor map for TransferTransactionV1Descriptor.\n *\n * Send mosaics and messages between two accounts (V1, latest).\n */\nexport class TransferTransactionV1Descriptor {\n\t/**\n\t * Creates a descriptor for TransferTransactionV1.\n\t * @param {Address} recipientAddress recipient address\n\t * @param {UnresolvedMosaicDescriptor[]|undefined} mosaics attached mosaics\n\t * @param {Uint8Array|string|undefined} message attached message\n\t */\n\tconstructor(recipientAddress, mosaics = undefined, message = undefined) {\n\t\tthis.rawDescriptor = {\n\t\t\ttype: 'transfer_transaction_v1',\n\t\t\trecipientAddress\n\t\t};\n\n\t\tif (mosaics)\n\t\t\tthis.rawDescriptor.mosaics = mosaics.map(descriptor => descriptor.toMap());\n\n\t\tif (message)\n\t\t\tthis.rawDescriptor.message = message;\n\t}\n\n\t/**\n\t * Builds a representation of this descriptor that can be passed to a factory function.\n\t * @returns {object} Descriptor that can be passed to a factory function.\n\t */\n\ttoMap() {\n\t\treturn this.rawDescriptor;\n\t}\n}\n","import charMapping from './charMapping.js';\n\nconst ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';\nconst DECODED_BLOCK_SIZE = 5;\nconst ENCODED_BLOCK_SIZE = 8;\n\n// region encode\n\nconst encodeBlock = (input, inputOffset, output, outputOffset) => {\n\toutput[outputOffset + 0] = ALPHABET[input[inputOffset + 0] >> 3];\n\toutput[outputOffset + 1] = ALPHABET[((input[inputOffset + 0] & 0x07) << 2) | (input[inputOffset + 1] >> 6)];\n\toutput[outputOffset + 2] = ALPHABET[(input[inputOffset + 1] & 0x3E) >> 1];\n\toutput[outputOffset + 3] = ALPHABET[((input[inputOffset + 1] & 0x01) << 4) | (input[inputOffset + 2] >> 4)];\n\toutput[outputOffset + 4] = ALPHABET[((input[inputOffset + 2] & 0x0F) << 1) | (input[inputOffset + 3] >> 7)];\n\toutput[outputOffset + 5] = ALPHABET[(input[inputOffset + 3] & 0x7F) >> 2];\n\toutput[outputOffset + 6] = ALPHABET[((input[inputOffset + 3] & 0x03) << 3) | (input[inputOffset + 4] >> 5)];\n\toutput[outputOffset + 7] = ALPHABET[input[inputOffset + 4] & 0x1F];\n};\n\n// endregion\n\n// region decode\n\nconst Char_To_Decoded_Char_Map = (() => {\n\tconst builder = charMapping.createBuilder();\n\tbuilder.addRange('A', 'Z', 0);\n\tbuilder.addRange('2', '7', 26);\n\treturn builder.map;\n})();\n\nconst decodeChar = c => {\n\tconst decodedChar = Char_To_Decoded_Char_Map[c];\n\tif (undefined !== decodedChar)\n\t\treturn decodedChar;\n\n\tthrow Error(`illegal base32 character ${c}`);\n};\n\nconst decodeBlock = (input, inputOffset, output, outputOffset) => {\n\tconst bytes = new Uint8Array(ENCODED_BLOCK_SIZE);\n\tfor (let i = 0; i < ENCODED_BLOCK_SIZE; ++i)\n\t\tbytes[i] = decodeChar(input[inputOffset + i]);\n\n\toutput[outputOffset + 0] = (bytes[0] << 3) | (bytes[1] >> 2);\n\toutput[outputOffset + 1] = ((bytes[1] & 0x03) << 6) | (bytes[2] << 1) | (bytes[3] >> 4);\n\toutput[outputOffset + 2] = ((bytes[3] & 0x0F) << 4) | (bytes[4] >> 1);\n\toutput[outputOffset + 3] = ((bytes[4] & 0x01) << 7) | (bytes[5] << 2) | (bytes[6] >> 3);\n\toutput[outputOffset + 4] = ((bytes[6] & 0x07) << 5) | bytes[7];\n};\n\n// endregion\n\n/**\n * Base32 encodes a binary buffer.\n * @param {Uint8Array} data Binary data to encode.\n * @returns {string} Base32 encoded string corresponding to the input data.\n */\nconst encode = data => {\n\tif (0 !== data.length % DECODED_BLOCK_SIZE)\n\t\tthrow Error(`decoded size must be multiple of ${DECODED_BLOCK_SIZE}`);\n\n\tconst output = new Array(data.length / DECODED_BLOCK_SIZE * ENCODED_BLOCK_SIZE);\n\tfor (let i = 0; i < data.length / DECODED_BLOCK_SIZE; ++i)\n\t\tencodeBlock(data, i * DECODED_BLOCK_SIZE, output, i * ENCODED_BLOCK_SIZE);\n\n\treturn output.join('');\n};\n\n/**\n * Base32 decodes a base32 encoded string.\n * @param {string} encoded Base32 encoded string to decode.\n * @returns {Uint8Array} Binary data corresponding to the input string.\n */\nconst decode = encoded => {\n\tif (0 !== encoded.length % ENCODED_BLOCK_SIZE)\n\t\tthrow Error(`encoded size must be multiple of ${ENCODED_BLOCK_SIZE}`);\n\n\tconst output = new Uint8Array(encoded.length / ENCODED_BLOCK_SIZE * DECODED_BLOCK_SIZE);\n\tfor (let i = 0; i < encoded.length / ENCODED_BLOCK_SIZE; ++i)\n\t\tdecodeBlock(encoded, i * ENCODED_BLOCK_SIZE, output, i * DECODED_BLOCK_SIZE);\n\n\treturn output;\n};\n\nexport default { encode, decode };\n"],"names":[],"sourceRoot":""}