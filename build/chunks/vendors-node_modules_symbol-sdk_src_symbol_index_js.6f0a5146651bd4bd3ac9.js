"use strict";
(self["webpackChunkGUI"] = self["webpackChunkGUI"] || []).push([["vendors-node_modules_symbol-sdk_src_symbol_index_js"],{

/***/ "./node_modules/@noble/hashes/esm/_assert.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_assert.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abytes: () => (/* binding */ abytes),
/* harmony export */   aexists: () => (/* binding */ aexists),
/* harmony export */   ahash: () => (/* binding */ ahash),
/* harmony export */   anumber: () => (/* binding */ anumber),
/* harmony export */   aoutput: () => (/* binding */ aoutput),
/* harmony export */   bytes: () => (/* binding */ abytes),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   number: () => (/* binding */ anumber)
/* harmony export */ });
function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error('positive integer expected, got ' + n);
}
// copied from utils
function isBytes(a) {
    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
}
function abytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}

const assert = {
    number: anumber,
    bytes: abytes,
    hash: ahash,
    exists: aexists,
    output: aoutput,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);
//# sourceMappingURL=_assert.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/_md.js":
/*!***********************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_md.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Chi: () => (/* binding */ Chi),
/* harmony export */   HashMD: () => (/* binding */ HashMD),
/* harmony export */   Maj: () => (/* binding */ Maj)
/* harmony export */ });
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ "./node_modules/@noble/hashes/esm/_assert.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/esm/utils.js");


/**
 * Polyfill for Safari 14
 */
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
/**
 * Choice: a ? b : c
 */
const Chi = (a, b, c) => (a & b) ^ (~a & c);
/**
 * Majority function, true if any two inputs is true
 */
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */
class HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);
    }
    update(data) {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);
        const { view, buffer, blockLen } = this;
        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aoutput)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}
//# sourceMappingURL=_md.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/_u64.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_u64.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   add3H: () => (/* binding */ add3H),
/* harmony export */   add3L: () => (/* binding */ add3L),
/* harmony export */   add4H: () => (/* binding */ add4H),
/* harmony export */   add4L: () => (/* binding */ add4L),
/* harmony export */   add5H: () => (/* binding */ add5H),
/* harmony export */   add5L: () => (/* binding */ add5L),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   fromBig: () => (/* binding */ fromBig),
/* harmony export */   rotlBH: () => (/* binding */ rotlBH),
/* harmony export */   rotlBL: () => (/* binding */ rotlBL),
/* harmony export */   rotlSH: () => (/* binding */ rotlSH),
/* harmony export */   rotlSL: () => (/* binding */ rotlSL),
/* harmony export */   rotr32H: () => (/* binding */ rotr32H),
/* harmony export */   rotr32L: () => (/* binding */ rotr32L),
/* harmony export */   rotrBH: () => (/* binding */ rotrBH),
/* harmony export */   rotrBL: () => (/* binding */ rotrBL),
/* harmony export */   rotrSH: () => (/* binding */ rotrSH),
/* harmony export */   rotrSL: () => (/* binding */ rotrSL),
/* harmony export */   shrSH: () => (/* binding */ shrSH),
/* harmony export */   shrSL: () => (/* binding */ shrSL),
/* harmony export */   split: () => (/* binding */ split),
/* harmony export */   toBig: () => (/* binding */ toBig)
/* harmony export */ });
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
// BigUint64Array is too slow as per 2024, so we implement it using Uint32Array.
// TODO: re-check https://issues.chromium.org/issues/42212588
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
const rotr32L = (h, _l) => h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
// prettier-ignore

// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);
//# sourceMappingURL=_u64.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/crypto.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/crypto.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   crypto: () => (/* binding */ crypto)
/* harmony export */ });
const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;
//# sourceMappingURL=crypto.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/hkdf.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/hkdf.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   expand: () => (/* binding */ expand),
/* harmony export */   extract: () => (/* binding */ extract),
/* harmony export */   hkdf: () => (/* binding */ hkdf)
/* harmony export */ });
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ "./node_modules/@noble/hashes/esm/_assert.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/esm/utils.js");
/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hmac.js */ "./node_modules/@noble/hashes/esm/hmac.js");



// HKDF (RFC 5869)
// https://soatok.blog/2021/11/17/understanding-hkdf/
/**
 * HKDF-Extract(IKM, salt) -> PRK
 * Arguments position differs from spec (IKM is first one, since it is not optional)
 * @param hash
 * @param ikm
 * @param salt
 * @returns
 */
function extract(hash, ikm, salt) {
    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.ahash)(hash);
    // NOTE: some libraries treat zero-length array as 'not provided';
    // we don't, since we have undefined as 'not provided'
    // https://github.com/RustCrypto/KDFs/issues/15
    if (salt === undefined)
        salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros
    return (0,_hmac_js__WEBPACK_IMPORTED_MODULE_1__.hmac)(hash, (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.toBytes)(salt), (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.toBytes)(ikm));
}
// HKDF-Expand(PRK, info, L) -> OKM
const HKDF_COUNTER = /* @__PURE__ */ new Uint8Array([0]);
const EMPTY_BUFFER = /* @__PURE__ */ new Uint8Array();
/**
 * HKDF-expand from the spec.
 * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)
 * @param info - optional context and application specific information (can be a zero-length string)
 * @param length - length of output keying material in octets
 */
function expand(hash, prk, info, length = 32) {
    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.ahash)(hash);
    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(length);
    if (length > 255 * hash.outputLen)
        throw new Error('Length should be <= 255*HashLen');
    const blocks = Math.ceil(length / hash.outputLen);
    if (info === undefined)
        info = EMPTY_BUFFER;
    // first L(ength) octets of T
    const okm = new Uint8Array(blocks * hash.outputLen);
    // Re-use HMAC instance between blocks
    const HMAC = _hmac_js__WEBPACK_IMPORTED_MODULE_1__.hmac.create(hash, prk);
    const HMACTmp = HMAC._cloneInto();
    const T = new Uint8Array(HMAC.outputLen);
    for (let counter = 0; counter < blocks; counter++) {
        HKDF_COUNTER[0] = counter + 1;
        // T(0) = empty string (zero length)
        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)
        HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)
            .update(info)
            .update(HKDF_COUNTER)
            .digestInto(T);
        okm.set(T, hash.outputLen * counter);
        HMAC._cloneInto(HMACTmp);
    }
    HMAC.destroy();
    HMACTmp.destroy();
    T.fill(0);
    HKDF_COUNTER.fill(0);
    return okm.slice(0, length);
}
/**
 * HKDF (RFC 5869): extract + expand in one step.
 * @param hash - hash function that would be used (e.g. sha256)
 * @param ikm - input keying material, the initial key
 * @param salt - optional salt value (a non-secret random value)
 * @param info - optional context and application specific information
 * @param length - length of output keying material in octets
 */
const hkdf = (hash, ikm, salt, info, length) => expand(hash, extract(hash, ikm, salt), info, length);
//# sourceMappingURL=hkdf.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/hmac.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/hmac.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HMAC: () => (/* binding */ HMAC),
/* harmony export */   hmac: () => (/* binding */ hmac)
/* harmony export */ });
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ "./node_modules/@noble/hashes/esm/_assert.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/esm/utils.js");


// HMAC (RFC 2104)
class HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.ahash)(hash);
        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function')
            throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        pad.fill(0);
    }
    update(buf) {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 * @example
 * import { hmac } from '@noble/hashes/hmac';
 * import { sha256 } from '@noble/hashes/sha2';
 * const mac1 = hmac(sha256, 'key', 'message');
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
hmac.create = (hash, key) => new HMAC(hash, key);
//# sourceMappingURL=hmac.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/sha256.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha256.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SHA256: () => (/* binding */ SHA256),
/* harmony export */   sha224: () => (/* binding */ sha224),
/* harmony export */   sha256: () => (/* binding */ sha256)
/* harmony export */ });
/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ "./node_modules/@noble/hashes/esm/_md.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/esm/utils.js");


// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per late 2024.
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state:
// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
// prettier-ignore
const SHA256_IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);
            const T1 = (H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);
            const T2 = (sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
    constructor() {
        super();
        this.A = 0xc1059ed8 | 0;
        this.B = 0x367cd507 | 0;
        this.C = 0x3070dd17 | 0;
        this.D = 0xf70e5939 | 0;
        this.E = 0xffc00b31 | 0;
        this.F = 0x68581511 | 0;
        this.G = 0x64f98fa7 | 0;
        this.H = 0xbefa4fa4 | 0;
        this.outputLen = 28;
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
const sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());
/**
 * SHA2-224 hash function
 */
const sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());
//# sourceMappingURL=sha256.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/sha3.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha3.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Keccak: () => (/* binding */ Keccak),
/* harmony export */   keccakP: () => (/* binding */ keccakP),
/* harmony export */   keccak_224: () => (/* binding */ keccak_224),
/* harmony export */   keccak_256: () => (/* binding */ keccak_256),
/* harmony export */   keccak_384: () => (/* binding */ keccak_384),
/* harmony export */   keccak_512: () => (/* binding */ keccak_512),
/* harmony export */   sha3_224: () => (/* binding */ sha3_224),
/* harmony export */   sha3_256: () => (/* binding */ sha3_256),
/* harmony export */   sha3_384: () => (/* binding */ sha3_384),
/* harmony export */   sha3_512: () => (/* binding */ sha3_512),
/* harmony export */   shake128: () => (/* binding */ shake128),
/* harmony export */   shake256: () => (/* binding */ shake256)
/* harmony export */ });
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_assert.js */ "./node_modules/@noble/hashes/esm/_assert.js");
/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ "./node_modules/@noble/hashes/esm/_u64.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/esm/utils.js");



// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s));
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta θ
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
class Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.anumber)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);
    }
    keccak() {
        if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLE)
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.byteSwap32)(this.state32);
        keccakP(this.state32, this.rounds);
        if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLE)
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.byteSwap32)(this.state32);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.aexists)(this);
        const { blockLen, state } = this;
        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.aexists)(this, false);
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.abytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.anumber)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.aoutput)(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
const gen = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);
const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);
const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);
const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);
const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);
const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);
const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);
//# sourceMappingURL=sha3.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/sha512.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha512.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SHA384: () => (/* binding */ SHA384),
/* harmony export */   SHA512: () => (/* binding */ SHA512),
/* harmony export */   SHA512_224: () => (/* binding */ SHA512_224),
/* harmony export */   SHA512_256: () => (/* binding */ SHA512_256),
/* harmony export */   sha384: () => (/* binding */ sha384),
/* harmony export */   sha512: () => (/* binding */ sha512),
/* harmony export */   sha512_224: () => (/* binding */ sha512_224),
/* harmony export */   sha512_256: () => (/* binding */ sha512_256)
/* harmony export */ });
/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_md.js */ "./node_modules/@noble/hashes/esm/_md.js");
/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ "./node_modules/@noble/hashes/esm/_u64.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/esm/utils.js");



// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
// prettier-ignore
const [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].split([
    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
].map(n => BigInt(n))))();
// Temporary buffer, not used to store anything between runs
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends _md_js__WEBPACK_IMPORTED_MODULE_1__.HashMD {
    constructor() {
        super(128, 64, 16, false);
        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
        // Also looks cleaner and easier to verify with spec.
        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x6a09e667 | 0;
        this.Al = 0xf3bcc908 | 0;
        this.Bh = 0xbb67ae85 | 0;
        this.Bl = 0x84caa73b | 0;
        this.Ch = 0x3c6ef372 | 0;
        this.Cl = 0xfe94f82b | 0;
        this.Dh = 0xa54ff53a | 0;
        this.Dl = 0x5f1d36f1 | 0;
        this.Eh = 0x510e527f | 0;
        this.El = 0xade682d1 | 0;
        this.Fh = 0x9b05688c | 0;
        this.Fl = 0x2b3e6c1f | 0;
        this.Gh = 0x1f83d9ab | 0;
        this.Gl = 0xfb41bd6b | 0;
        this.Hh = 0x5be0cd19 | 0;
        this.Hl = 0x137e2179 | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].shrSH(W15h, W15l, 7);
            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].shrSH(W2h, W2l, 6);
            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for (let i = 0; i < 80; i++) {
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrBH(Eh, El, 41);
            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = (Eh & Fh) ^ (~Eh & Gh);
            const CHIl = (El & Fl) ^ (~El & Gl);
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].rotrBL(Ah, Al, 39);
            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__["default"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
    }
    destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
class SHA512_224 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x8c3d37c8 | 0;
        this.Al = 0x19544da2 | 0;
        this.Bh = 0x73e19966 | 0;
        this.Bl = 0x89dcd4d6 | 0;
        this.Ch = 0x1dfab7ae | 0;
        this.Cl = 0x32ff9c82 | 0;
        this.Dh = 0x679dd514 | 0;
        this.Dl = 0x582f9fcf | 0;
        this.Eh = 0x0f6d2b69 | 0;
        this.El = 0x7bd44da8 | 0;
        this.Fh = 0x77e36f73 | 0;
        this.Fl = 0x04c48942 | 0;
        this.Gh = 0x3f9d85a8 | 0;
        this.Gl = 0x6a1d36c8 | 0;
        this.Hh = 0x1112e6ad | 0;
        this.Hl = 0x91d692a1 | 0;
        this.outputLen = 28;
    }
}
class SHA512_256 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x22312194 | 0;
        this.Al = 0xfc2bf72c | 0;
        this.Bh = 0x9f555fa3 | 0;
        this.Bl = 0xc84c64c2 | 0;
        this.Ch = 0x2393b86b | 0;
        this.Cl = 0x6f53b151 | 0;
        this.Dh = 0x96387719 | 0;
        this.Dl = 0x5940eabd | 0;
        this.Eh = 0x96283ee2 | 0;
        this.El = 0xa88effe3 | 0;
        this.Fh = 0xbe5e1e25 | 0;
        this.Fl = 0x53863992 | 0;
        this.Gh = 0x2b0199fc | 0;
        this.Gl = 0x2c85b8aa | 0;
        this.Hh = 0x0eb72ddc | 0;
        this.Hl = 0x81c52ca2 | 0;
        this.outputLen = 32;
    }
}
class SHA384 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0xcbbb9d5d | 0;
        this.Al = 0xc1059ed8 | 0;
        this.Bh = 0x629a292a | 0;
        this.Bl = 0x367cd507 | 0;
        this.Ch = 0x9159015a | 0;
        this.Cl = 0x3070dd17 | 0;
        this.Dh = 0x152fecd8 | 0;
        this.Dl = 0xf70e5939 | 0;
        this.Eh = 0x67332667 | 0;
        this.El = 0xffc00b31 | 0;
        this.Fh = 0x8eb44a87 | 0;
        this.Fl = 0x68581511 | 0;
        this.Gh = 0xdb0c2e0d | 0;
        this.Gl = 0x64f98fa7 | 0;
        this.Hh = 0x47b5481d | 0;
        this.Hl = 0xbefa4fa4 | 0;
        this.outputLen = 48;
    }
}
const sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512());
const sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_224());
const sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_256());
const sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA384());
//# sourceMappingURL=sha512.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Hash: () => (/* binding */ Hash),
/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),
/* harmony export */   byteSwap: () => (/* binding */ byteSwap),
/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),
/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),
/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),
/* harmony export */   checkOpts: () => (/* binding */ checkOpts),
/* harmony export */   concatBytes: () => (/* binding */ concatBytes),
/* harmony export */   createView: () => (/* binding */ createView),
/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),
/* harmony export */   isBytes: () => (/* binding */ isBytes),
/* harmony export */   isLE: () => (/* binding */ isLE),
/* harmony export */   nextTick: () => (/* binding */ nextTick),
/* harmony export */   randomBytes: () => (/* binding */ randomBytes),
/* harmony export */   rotl: () => (/* binding */ rotl),
/* harmony export */   rotr: () => (/* binding */ rotr),
/* harmony export */   toBytes: () => (/* binding */ toBytes),
/* harmony export */   u32: () => (/* binding */ u32),
/* harmony export */   u8: () => (/* binding */ u8),
/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),
/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),
/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),
/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)
/* harmony export */ });
/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/crypto */ "./node_modules/@noble/hashes/esm/crypto.js");
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ "./node_modules/@noble/hashes/esm/_assert.js");
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.


// export { isBytes } from './_assert.js';
// We can't reuse isBytes from _assert, because somehow this causes huge perf issues
function isBytes(a) {
    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
}
// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
// The rotate left (circular left shift) operation for uint32
const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);
const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();
// The byte swap operation for uint32
const byteSwap = (word) => ((word << 24) & 0xff000000) |
    ((word << 8) & 0xff0000) |
    ((word >>> 8) & 0xff00) |
    ((word >>> 24) & 0xff);
// Conditionally byte swap if on a big-endian platform
const byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);
// In place byte swap for Uint32Array
function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
    }
}
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(bytes);
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await nextTick();
        ts += diff;
    }
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error('utf8ToBytes expected string, got ' + typeof str);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(data);
    return data;
}
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')
        throw new Error('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */
function randomBytes(bytesLength = 32) {
    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === 'function') {
        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.randomBytes === 'function') {
        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.randomBytes(bytesLength);
    }
    throw new Error('crypto.getRandomValues must be defined');
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/symbol-crypto-wasm-web/symbol_crypto_wasm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/symbol-crypto-wasm-web/symbol_crypto_wasm.js ***!
  \*******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HashMode: () => (/* reexport safe */ _symbol_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.HashMode),
/* harmony export */   __wbg_buffer_cf65c07de34b9a08: () => (/* reexport safe */ _symbol_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_buffer_cf65c07de34b9a08),
/* harmony export */   __wbg_error_f851667af71bcfc6: () => (/* reexport safe */ _symbol_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_error_f851667af71bcfc6),
/* harmony export */   __wbg_length_27a2afe8ab42b09f: () => (/* reexport safe */ _symbol_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_length_27a2afe8ab42b09f),
/* harmony export */   __wbg_new_537b7341ce90bb31: () => (/* reexport safe */ _symbol_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_new_537b7341ce90bb31),
/* harmony export */   __wbg_new_abda76e883ba8a5f: () => (/* reexport safe */ _symbol_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_new_abda76e883ba8a5f),
/* harmony export */   __wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5: () => (/* reexport safe */ _symbol_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5),
/* harmony export */   __wbg_set_17499e8aa4003ebd: () => (/* reexport safe */ _symbol_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_17499e8aa4003ebd),
/* harmony export */   __wbg_set_wasm: () => (/* reexport safe */ _symbol_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm),
/* harmony export */   __wbg_slice_0ab69c1e013c6cae: () => (/* reexport safe */ _symbol_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_slice_0ab69c1e013c6cae),
/* harmony export */   __wbg_stack_658279fe44541cf6: () => (/* reexport safe */ _symbol_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_stack_658279fe44541cf6),
/* harmony export */   __wbindgen_memory: () => (/* reexport safe */ _symbol_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_memory),
/* harmony export */   __wbindgen_object_drop_ref: () => (/* reexport safe */ _symbol_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_object_drop_ref),
/* harmony export */   __wbindgen_throw: () => (/* reexport safe */ _symbol_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_throw),
/* harmony export */   crypto_private_sign: () => (/* reexport safe */ _symbol_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.crypto_private_sign),
/* harmony export */   crypto_private_verify: () => (/* reexport safe */ _symbol_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.crypto_private_verify),
/* harmony export */   crypto_sign_keypair: () => (/* reexport safe */ _symbol_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.crypto_sign_keypair)
/* harmony export */ });
/* harmony import */ var _symbol_crypto_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbol_crypto_wasm_bg.wasm */ "./node_modules/symbol-crypto-wasm-web/symbol_crypto_wasm_bg.wasm");
/* harmony import */ var _symbol_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbol_crypto_wasm_bg.js */ "./node_modules/symbol-crypto-wasm-web/symbol_crypto_wasm_bg.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_symbol_crypto_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_1__]);
_symbol_crypto_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


(0,_symbol_crypto_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm)(_symbol_crypto_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_1__);


__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/symbol-crypto-wasm-web/symbol_crypto_wasm_bg.js":
/*!**********************************************************************!*\
  !*** ./node_modules/symbol-crypto-wasm-web/symbol_crypto_wasm_bg.js ***!
  \**********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HashMode: () => (/* binding */ HashMode),
/* harmony export */   __wbg_buffer_cf65c07de34b9a08: () => (/* binding */ __wbg_buffer_cf65c07de34b9a08),
/* harmony export */   __wbg_error_f851667af71bcfc6: () => (/* binding */ __wbg_error_f851667af71bcfc6),
/* harmony export */   __wbg_length_27a2afe8ab42b09f: () => (/* binding */ __wbg_length_27a2afe8ab42b09f),
/* harmony export */   __wbg_new_537b7341ce90bb31: () => (/* binding */ __wbg_new_537b7341ce90bb31),
/* harmony export */   __wbg_new_abda76e883ba8a5f: () => (/* binding */ __wbg_new_abda76e883ba8a5f),
/* harmony export */   __wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5: () => (/* binding */ __wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5),
/* harmony export */   __wbg_set_17499e8aa4003ebd: () => (/* binding */ __wbg_set_17499e8aa4003ebd),
/* harmony export */   __wbg_set_wasm: () => (/* binding */ __wbg_set_wasm),
/* harmony export */   __wbg_slice_0ab69c1e013c6cae: () => (/* binding */ __wbg_slice_0ab69c1e013c6cae),
/* harmony export */   __wbg_stack_658279fe44541cf6: () => (/* binding */ __wbg_stack_658279fe44541cf6),
/* harmony export */   __wbindgen_memory: () => (/* binding */ __wbindgen_memory),
/* harmony export */   __wbindgen_object_drop_ref: () => (/* binding */ __wbindgen_object_drop_ref),
/* harmony export */   __wbindgen_throw: () => (/* binding */ __wbindgen_throw),
/* harmony export */   crypto_private_sign: () => (/* binding */ crypto_private_sign),
/* harmony export */   crypto_private_verify: () => (/* binding */ crypto_private_verify),
/* harmony export */   crypto_sign_keypair: () => (/* binding */ crypto_sign_keypair)
/* harmony export */ });
/* module decorator */ module = __webpack_require__.hmd(module);
let wasm;
function __wbg_set_wasm(val) {
    wasm = val;
}


const heap = new Array(128).fill(undefined);

heap.push(undefined, null, true, false);

function getObject(idx) { return heap[idx]; }

let heap_next = heap.length;

function dropObject(idx) {
    if (idx < 132) return;
    heap[idx] = heap_next;
    heap_next = idx;
}

function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}

const lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;

let cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });

cachedTextDecoder.decode();

let cachedUint8Memory0 = null;

function getUint8Memory0() {
    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8Memory0;
}

function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}

function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];

    if (typeof(heap_next) !== 'number') throw new Error('corrupt heap');

    heap[idx] = obj;
    return idx;
}

function _assertNum(n) {
    if (typeof(n) !== 'number') throw new Error('expected a number argument');
}

let stack_pointer = 128;

function addBorrowedObject(obj) {
    if (stack_pointer == 1) throw new Error('out of js stack');
    heap[--stack_pointer] = obj;
    return stack_pointer;
}
/**
* Generates public key given secret key.
* @param {number} hash_mode
* @param {Uint8Array} sk_boxed
* @param {Uint8Array} pk_boxed
*/
function crypto_sign_keypair(hash_mode, sk_boxed, pk_boxed) {
    try {
        _assertNum(hash_mode);
        wasm.crypto_sign_keypair(hash_mode, addBorrowedObject(sk_boxed), addBorrowedObject(pk_boxed));
    } finally {
        heap[stack_pointer++] = undefined;
        heap[stack_pointer++] = undefined;
    }
}

/**
* Signs message.
* @param {number} hash_mode
* @param {Uint8Array} sk_boxed
* @param {Uint8Array} message_boxed
* @param {Uint8Array} signature_boxed
*/
function crypto_private_sign(hash_mode, sk_boxed, message_boxed, signature_boxed) {
    try {
        _assertNum(hash_mode);
        wasm.crypto_private_sign(hash_mode, addBorrowedObject(sk_boxed), addBorrowedObject(message_boxed), addBorrowedObject(signature_boxed));
    } finally {
        heap[stack_pointer++] = undefined;
        heap[stack_pointer++] = undefined;
        heap[stack_pointer++] = undefined;
    }
}

/**
* Verifies signature.
* @param {number} hash_mode
* @param {Uint8Array} pk_boxed
* @param {Uint8Array} message_boxed
* @param {Uint8Array} signature_boxed
* @returns {boolean}
*/
function crypto_private_verify(hash_mode, pk_boxed, message_boxed, signature_boxed) {
    try {
        _assertNum(hash_mode);
        const ret = wasm.crypto_private_verify(hash_mode, addBorrowedObject(pk_boxed), addBorrowedObject(message_boxed), addBorrowedObject(signature_boxed));
        return ret !== 0;
    } finally {
        heap[stack_pointer++] = undefined;
        heap[stack_pointer++] = undefined;
        heap[stack_pointer++] = undefined;
    }
}

function logError(f, args) {
    try {
        return f.apply(this, args);
    } catch (e) {
        let error = (function () {
            try {
                return e instanceof Error ? `${e.message}\n\nStack:\n${e.stack}` : e.toString();
            } catch(_) {
                return "<failed to stringify thrown value>";
            }
        }());
        console.error("wasm-bindgen: imported JS function that was not marked as `catch` threw an error:", error);
        throw e;
    }
}

let WASM_VECTOR_LEN = 0;

const lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;

let cachedTextEncoder = new lTextEncoder('utf-8');

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (typeof(arg) !== 'string') throw new Error('expected a string argument');

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len);

    const mem = getUint8Memory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);
        if (ret.read !== arg.length) throw new Error('failed to pass whole string');
        offset += ret.written;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

let cachedInt32Memory0 = null;

function getInt32Memory0() {
    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachedInt32Memory0;
}
/**
* Supported hash modes.
*/
const HashMode = Object.freeze({
/**
* Keccak hash.
*/
Keccak:0,"0":"Keccak",
/**
* SHA2 hash.
*/
Sha2_512:1,"1":"Sha2_512", });

function __wbindgen_object_drop_ref(arg0) {
    takeObject(arg0);
};

function __wbg_error_f851667af71bcfc6() { return logError(function (arg0, arg1) {
    try {
        console.error(getStringFromWasm0(arg0, arg1));
    } finally {
        wasm.__wbindgen_free(arg0, arg1);
    }
}, arguments) };

function __wbg_new_abda76e883ba8a5f() { return logError(function () {
    const ret = new Error();
    return addHeapObject(ret);
}, arguments) };

function __wbg_stack_658279fe44541cf6() { return logError(function (arg0, arg1) {
    const ret = getObject(arg1).stack;
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
}, arguments) };

function __wbg_new_537b7341ce90bb31() { return logError(function (arg0) {
    const ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
}, arguments) };

function __wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5() { return logError(function (arg0, arg1, arg2) {
    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
}, arguments) };

function __wbg_slice_0ab69c1e013c6cae() { return logError(function (arg0, arg1, arg2) {
    const ret = getObject(arg0).slice(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
}, arguments) };

function __wbg_length_27a2afe8ab42b09f() { return logError(function (arg0) {
    const ret = getObject(arg0).length;
    _assertNum(ret);
    return ret;
}, arguments) };

function __wbg_set_17499e8aa4003ebd() { return logError(function (arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
}, arguments) };

function __wbg_buffer_cf65c07de34b9a08() { return logError(function (arg0) {
    const ret = getObject(arg0).buffer;
    return addHeapObject(ret);
}, arguments) };

function __wbindgen_throw(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
};

function __wbindgen_memory() {
    const ret = wasm.memory;
    return addHeapObject(ret);
};



/***/ }),

/***/ "./node_modules/symbol-crypto-wasm-web/symbol_crypto_wasm_bg.wasm":
/*!************************************************************************!*\
  !*** ./node_modules/symbol-crypto-wasm-web/symbol_crypto_wasm_bg.wasm ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* harmony import */ var WEBPACK_IMPORTED_MODULE_0 = __webpack_require__(/*! ./symbol_crypto_wasm_bg.js */ "./node_modules/symbol-crypto-wasm-web/symbol_crypto_wasm_bg.js");
module.exports = __webpack_require__.v(exports, module.id, "68b84360c5b15550d8b7", {
	"./symbol_crypto_wasm_bg.js": {
		"__wbindgen_object_drop_ref": WEBPACK_IMPORTED_MODULE_0.__wbindgen_object_drop_ref,
		"__wbg_error_f851667af71bcfc6": WEBPACK_IMPORTED_MODULE_0.__wbg_error_f851667af71bcfc6,
		"__wbg_new_abda76e883ba8a5f": WEBPACK_IMPORTED_MODULE_0.__wbg_new_abda76e883ba8a5f,
		"__wbg_stack_658279fe44541cf6": WEBPACK_IMPORTED_MODULE_0.__wbg_stack_658279fe44541cf6,
		"__wbg_new_537b7341ce90bb31": WEBPACK_IMPORTED_MODULE_0.__wbg_new_537b7341ce90bb31,
		"__wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5": WEBPACK_IMPORTED_MODULE_0.__wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5,
		"__wbg_slice_0ab69c1e013c6cae": WEBPACK_IMPORTED_MODULE_0.__wbg_slice_0ab69c1e013c6cae,
		"__wbg_length_27a2afe8ab42b09f": WEBPACK_IMPORTED_MODULE_0.__wbg_length_27a2afe8ab42b09f,
		"__wbg_set_17499e8aa4003ebd": WEBPACK_IMPORTED_MODULE_0.__wbg_set_17499e8aa4003ebd,
		"__wbg_buffer_cf65c07de34b9a08": WEBPACK_IMPORTED_MODULE_0.__wbg_buffer_cf65c07de34b9a08,
		"__wbindgen_throw": WEBPACK_IMPORTED_MODULE_0.__wbindgen_throw,
		"__wbindgen_memory": WEBPACK_IMPORTED_MODULE_0.__wbindgen_memory
	}
});

/***/ }),

/***/ "./node_modules/symbol-sdk/src/Cipher.js":
/*!***********************************************!*\
  !*** ./node_modules/symbol-sdk/src/Cipher.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AesCbcCipher: () => (/* binding */ AesCbcCipher),
/* harmony export */   AesGcmCipher: () => (/* binding */ AesGcmCipher)
/* harmony export */ });
/* harmony import */ var _ByteArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ByteArray.js */ "./node_modules/symbol-sdk/src/ByteArray.js");
/* harmony import */ var _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CryptoTypes.js */ "./node_modules/symbol-sdk/src/CryptoTypes.js");
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto */ "./node_modules/crypto-browserify/index.js");
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

/* eslint-disable no-unused-vars */

/* eslint-enable no-unused-vars */


// ReactNative Buffer polyfill only allows Buffers to be passed to Buffer.concat
// in order to support ReactNative, all Uint8Arrays must be wrapped in Buffer when calling crypto cipher APIs
const toBufferView = input => {
	const typedByteArray = input instanceof _ByteArray_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? input.bytes : input;
	return Buffer.from(typedByteArray.buffer, typedByteArray.byteOffset, typedByteArray.length);
};

const concatArrays = (lhs, rhs) => {
	const result = new Uint8Array(lhs.length + rhs.length);
	result.set(lhs);
	result.set(rhs, lhs.length);
	return result;
};

// region AesCbcCipher

/**
 * Performs AES CBC encryption and decryption with a given key.
 */
class AesCbcCipher {
	/**
	 * Creates a cipher around an aes shared key.
	 * @param {SharedKey256} aesKey AES shared key.
	 */
	constructor(aesKey) {
		/**
		 * @private
		 */
		this._key = aesKey;
	}

	/**
	 * Encrypts clear text.
	 * @param {Uint8Array} clearText Clear text to encrypt.
	 * @param {Uint8Array} iv IV bytes.
	 * @returns {Uint8Array} Cipher text.
	 */
	encrypt(clearText, iv) {
		const cipher = crypto__WEBPACK_IMPORTED_MODULE_2__.createCipheriv('aes-256-cbc', toBufferView(this._key), toBufferView(iv));

		const cipherText = cipher.update(toBufferView(clearText));
		const padding = cipher.final();

		return concatArrays(cipherText, padding);
	}

	/**
	 * Decrypts cipher text.
	 * @param {Uint8Array} cipherText Cipher text to decrypt.
	 * @param {Uint8Array} iv IV bytes.
	 * @returns {Uint8Array} Clear text.
	 */
	decrypt(cipherText, iv) {
		const decipher = crypto__WEBPACK_IMPORTED_MODULE_2__.createDecipheriv('aes-256-cbc', toBufferView(this._key), toBufferView(iv));

		const clearText = decipher.update(toBufferView(cipherText));
		const padding = decipher.final();

		return concatArrays(clearText, padding);
	}
}

// endregion

// region AesGcmCipher

/**
 * Performs AES GCM encryption and decryption with a given key.
 */
class AesGcmCipher {
	/**
	 * Byte size of GCM tag.
	 * @type {number}
	 */
	static TAG_SIZE = 16;

	/**
	 * Creates a cipher around an aes shared key.
	 * @param {SharedKey256} aesKey AES shared key.
	 */
	constructor(aesKey) {
		/**
		 * @private
		 */
		this._key = aesKey;
	}

	/**
	 * Encrypts clear text and appends tag to encrypted payload.
	 * @param {Uint8Array} clearText Clear text to encrypt.
	 * @param {Uint8Array} iv IV bytes.
	 * @returns {Uint8Array} Cipher text with appended tag.
	 */
	encrypt(clearText, iv) {
		const cipher = crypto__WEBPACK_IMPORTED_MODULE_2__.createCipheriv('aes-256-gcm', toBufferView(this._key), toBufferView(iv));

		const cipherText = cipher.update(toBufferView(clearText));
		cipher.final(); // no padding for GCM

		const tag = cipher.getAuthTag();

		return concatArrays(cipherText, tag);
	}

	/**
	 * Decrypts cipher text with appended tag.
	 * @param {Uint8Array} cipherText Cipher text with appended tag to decrypt.
	 * @param {Uint8Array} iv IV bytes.
	 * @returns {Uint8Array} Clear text.
	 */
	decrypt(cipherText, iv) {
		const decipher = crypto__WEBPACK_IMPORTED_MODULE_2__.createDecipheriv('aes-256-gcm', toBufferView(this._key), toBufferView(iv));

		const tagStartOffset = cipherText.length - AesGcmCipher.TAG_SIZE;
		decipher.setAuthTag(Buffer.from(cipherText.buffer, tagStartOffset));

		const clearText = decipher.update(Buffer.from(cipherText.buffer, 0, tagStartOffset));
		decipher.final(); // no padding for GCM
		return clearText;
	}
}

// endregion


/***/ }),

/***/ "./node_modules/symbol-sdk/src/RuleBasedTransactionFactory.js":
/*!********************************************************************!*\
  !*** ./node_modules/symbol-sdk/src/RuleBasedTransactionFactory.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RuleBasedTransactionFactory)
/* harmony export */ });
/* harmony import */ var _BaseValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseValue.js */ "./node_modules/symbol-sdk/src/BaseValue.js");
/* harmony import */ var _ByteArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ByteArray.js */ "./node_modules/symbol-sdk/src/ByteArray.js");
/* harmony import */ var _TransactionDescriptorProcessor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TransactionDescriptorProcessor.js */ "./node_modules/symbol-sdk/src/TransactionDescriptorProcessor.js");




const buildEnumStringToValueMap = EnumClass => new Map(Object.getOwnPropertyNames(EnumClass)
	.filter(name => name.toUpperCase() === name)
	.map(name => [name.toLowerCase(), EnumClass[name]]));

const nameToEnumValue = (mapping, enumType, enumValueName) => {
	if (!mapping.has(enumValueName))
		throw RangeError(`unknown value ${enumValueName} for type ${enumType}`);

	return mapping.get(enumValueName);
};

const buildTypeHintsMap = structValue => {
	/** @type {{[key: string]: string}} */
	const typeHints = {};
	const rawTypeHints = structValue.constructor.TYPE_HINTS || {};
	Object.getOwnPropertyNames(rawTypeHints).forEach(key => {
		const hint = rawTypeHints[key];
		let ruleName;
		if (0 === hint.indexOf('array['))
			ruleName = hint;
		else if (0 === hint.indexOf('enum:'))
			ruleName = hint.substring('enum:'.length);
		else if (0 === hint.indexOf('pod:'))
			ruleName = hint.substring('pod:'.length);
		else if (0 === hint.indexOf('struct:'))
			ruleName = hint;

		if (ruleName)
			typeHints[key] = ruleName;
	});

	return typeHints;
};

const typeConverterFactory = (module, customTypeConverter, value) => {
	if (customTypeConverter && customTypeConverter(value))
		return customTypeConverter(value);

	if (value instanceof _ByteArray_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
		/** @type {object} */
		const ByteArrayClass = value.constructor;

		if (ByteArrayClass.NAME in module)
			return new module[ByteArrayClass.NAME](value.bytes);

		return new ByteArrayClass(value.bytes);
	}

	return value;
};

const autoEncodeStrings = entity => {
	Object.getOwnPropertyNames(entity).forEach(key => {
		const value = entity[key];
		if ('string' === typeof (value))
			entity[key] = new TextEncoder().encode(value);
	});
};

/**
 * Rule based transaction factory.
 * This class is not intended to be used directly.
 */
class RuleBasedTransactionFactory {
	/**
	 * Creates a rule based transaction factory for use with catbuffer generated code.
	 * @param {object} module Catbuffer generated module.
	 * @param {Function|undefined} typeConverter Type converter.
	 * @param {Map<string, Function>|undefined} typeRuleOverrides Type rule overrides.
	 */
	constructor(module, typeConverter = undefined, typeRuleOverrides = undefined) {
		/**
		 * @private
		 */
		this._module = module;

		/**
		 * Tries to coerce a value to a more appropriate type.
		 * @param {object} value Original value.
		 * @returns {object} Type converted value.
		 * @private
		 */
		this._typeConverter = value => typeConverterFactory(this._module, typeConverter, value);

		/**
		 * @private
		 */
		this._typeRuleOverrides = typeRuleOverrides || new Map();

		/**
		 * Map of rule names to transform functions.
		 * @type {Map<string, Function>}
		 */
		this.rules = new Map();
	}

	/**
	 * Looks up a class in the wrapped module.
	 * @param {string} name Class name.
	 * @returns {Constructable} Class type.
	 * @private
	 */
	_getModuleClass(name) {
		return this._module[name];
	}

	/**
	 * Creates wrapper for SDK POD types.
	 * @param {string} name Class name.
	 * @param {Constructable} PodClass Class type.
	 */
	addPodParser(name, PodClass) {
		if (this._typeRuleOverrides.has(PodClass)) {
			this.rules.set(name, this._typeRuleOverrides.get(PodClass));
			return;
		}

		this.rules.set(name, value => (value instanceof PodClass ? value : new PodClass(value)));
	}

	/**
	 * Creates flag type parser.
	 * @param {string} name Class name.
	 */
	addFlagsParser(name) {
		const FlagsClass = this._getModuleClass(name);
		const stringToEnum = buildEnumStringToValueMap(FlagsClass);

		this.rules.set(name, flags => {
			if ('string' === typeof (flags)) {
				const enumArray = flags.split(' ').map(flagName => nameToEnumValue(stringToEnum, name, flagName));
				return new FlagsClass(enumArray.map(flag => flag.value).reduce((x, y) => x | y));
			}

			if ('number' === typeof (flags) && Number.isInteger(flags))
				return new FlagsClass(flags);

			return flags;
		});
	}

	/**
	 * Creates enum type parser.
	 * @param {string} name Class name.
	 */
	addEnumParser(name) {
		const EnumClass = this._getModuleClass(name);
		const stringToEnum = buildEnumStringToValueMap(EnumClass);

		this.rules.set(name, enumValue => {
			if ('string' === typeof (enumValue))
				return nameToEnumValue(stringToEnum, name, enumValue);

			if ('number' === typeof (enumValue) && Number.isInteger(enumValue))
				return new EnumClass(enumValue);

			return enumValue;
		});
	}

	/**
	 * Creates struct parser (to allow nested parsing).
	 * @param {string} name Class name.
	 */
	addStructParser(name) {
		const StructClass = this._getModuleClass(name);

		this.rules.set(`struct:${name}`, structDescriptor => {
			const structProcessor = this._createProcessor(structDescriptor);
			const structValue = new StructClass();

			const allTypeHints = buildTypeHintsMap(structValue);
			structProcessor.setTypeHints(allTypeHints);

			structProcessor.copyTo(structValue);
			return structValue;
		});
	}

	/**
	 * Creates array type parser, based on some existing element type parser.
	 * @param {string} name Class name.
	 */
	addArrayParser(name) {
		const elementRule = this.rules.get(name);
		if (!elementRule)
			throw Error(`cannot create array type parser because element rule "${name}" is unknown`);

		const elementName = name.replace(/^struct:/, '');
		this.rules.set(`array[${elementName}]`, values => values.map(value => elementRule(value)));
	}

	/**
	 * Autodetects rules using reflection.
	 */
	autodetect() {
		Object.getOwnPropertyNames(this._module).forEach(key => {
			const cls = this._module[key];
			if (Object.prototype.isPrototypeOf.call(_BaseValue_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype, cls.prototype))
				this.addPodParser(key, cls);
		});
	}

	/**
	 * Creates an entity from a descriptor using a factory.
	 * @param {Function} factory Factory function.
	 * @param {object} descriptor Entity descriptor.
	 * @returns {object} Newly created entity.
	 */
	createFromFactory(factory, descriptor) {
		const processor = this._createProcessor(descriptor);
		const entityType = processor.lookupValue('type');
		const entity = factory(entityType);

		const allTypeHints = buildTypeHintsMap(entity);
		processor.setTypeHints(allTypeHints);
		processor.copyTo(entity, ['type']);

		autoEncodeStrings(entity);
		return entity;
	}

	/**
	 * Creates a transaction descriptor processor around a descriptor.
	 * @param {object} descriptor Transaction descriptor.
	 * @returns {TransactionDescriptorProcessor} Transaction descriptor processor.
	 * @private
	 */
	_createProcessor(descriptor) {
		return new _TransactionDescriptorProcessor_js__WEBPACK_IMPORTED_MODULE_2__["default"](descriptor, this.rules, this._typeConverter);
	}
}

// region type declarations

/**
 * Constructable class type.
 * @class
 * @typedef {new(...args: any[]) => object} Constructable
 */

// endregion


/***/ }),

/***/ "./node_modules/symbol-sdk/src/SharedKey.js":
/*!**************************************************!*\
  !*** ./node_modules/symbol-sdk/src/SharedKey.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deriveSharedKeyFactory: () => (/* binding */ deriveSharedKeyFactory),
/* harmony export */   deriveSharedSecretFactory: () => (/* binding */ deriveSharedSecretFactory)
/* harmony export */ });
/* harmony import */ var _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CryptoTypes.js */ "./node_modules/symbol-sdk/src/CryptoTypes.js");
/* harmony import */ var _impl_external_tweetnacl_nacl_fast_symbol_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./impl/external/tweetnacl-nacl-fast-symbol.js */ "./node_modules/symbol-sdk/src/impl/external/tweetnacl-nacl-fast-symbol.js");
/* harmony import */ var _noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/hkdf */ "./node_modules/@noble/hashes/esm/hkdf.js");
/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/sha256 */ "./node_modules/@noble/hashes/esm/sha256.js");
// this file contains implementation details and is not intended to be used directly






// order matches order of exported methods
const tweetnacl_lowlevel = (/** @type {any} */ (_impl_external_tweetnacl_nacl_fast_symbol_js__WEBPACK_IMPORTED_MODULE_1__["default"])).lowlevel;
const {
	gf, neq25519, pack, unpackneg
} = tweetnacl_lowlevel;

// publicKey is canonical if the y coordinate is smaller than 2^255 - 19
// note: this version is based on server version and should be constant-time
// note 2: don't touch it, you'll break it
const isCanonicalKey = publicKey => {
	const buffer = publicKey.bytes;
	let a = (buffer[31] & 0x7F) ^ 0x7F;
	for (let i = 30; 0 < i; --i)
		a |= buffer[i] ^ 0xFF;

	a = (a - 1) >>> 8;

	const b = (0xED - 1 - buffer[0]) >>> 8;
	return 0 !== 1 - (a & b & 1);
};

const isInMainSubgroup = point => {
	const { scalarmult, L } = tweetnacl_lowlevel;
	const result = [gf(), gf(), gf(), gf()];
	// multiply by group order
	scalarmult(result, point, L);

	// check if result is neutral element
	const gf0 = gf();
	const areEqual = neq25519(result[1], result[2]);
	const isZero = neq25519(gf0, result[0]);

	// yes, this is supposed to be  bit OR
	return 0 === (areEqual | isZero);
};

/**
 * Creates a shared secret factory given a hash function.
 * @param {object} hasher Hash object to use.
 * @returns {function(Uint8Array, PublicKey): Uint8Array} Creates a shared secret from a raw private key and public key.
 */
const deriveSharedSecretFactory = hasher => (privateKeyBytes, otherPublicKey) => {
	const { scalarmult, Z } = tweetnacl_lowlevel;
	const point = [gf(), gf(), gf(), gf()];

	if (!isCanonicalKey(otherPublicKey) || 0 !== unpackneg(point, otherPublicKey.bytes) || !isInMainSubgroup(point))
		throw Error('invalid point');

	// negate point == negate X coordinate and 't'
	Z(point[0], gf(), point[0]);
	Z(point[3], gf(), point[3]);

	const scalar = new Uint8Array(64);

	_impl_external_tweetnacl_nacl_fast_symbol_js__WEBPACK_IMPORTED_MODULE_1__["default"].lowlevel.crypto_hash(scalar, privateKeyBytes, 32, hasher);
	scalar[0] &= 248;
	scalar[31] &= 127;
	scalar[31] |= 64;

	const result = [gf(), gf(), gf(), gf()];
	scalarmult(result, point, scalar);

	const sharedSecret = new Uint8Array(32);
	pack(sharedSecret, result);
	return sharedSecret;
};

/**
 * Creates a shared key factory given a tag and a hash function.
 * @param {string} info Tag used in HKDF algorithm.
 * @param {object} hasher Hash object to use.
 * @returns {function(Uint8Array, PublicKey): SharedKey256} Creates a shared key from a raw private key and public key.
 */
const deriveSharedKeyFactory = (info, hasher) => {
	const deriveSharedSecret = deriveSharedSecretFactory(hasher);
	return (privateKeyBytes, otherPublicKey) => {
		const sharedSecret = deriveSharedSecret(privateKeyBytes, otherPublicKey);
		return new _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_0__.SharedKey256((0,_noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_2__.hkdf)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_3__.sha256, sharedSecret, undefined, info, 32));
	};
};




/***/ }),

/***/ "./node_modules/symbol-sdk/src/TransactionDescriptorProcessor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/symbol-sdk/src/TransactionDescriptorProcessor.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TransactionDescriptorProcessor)
/* harmony export */ });
/**
 * Processes and looks up transaction descriptor properties.
 * This class is not intended to be used directly.
 */
class TransactionDescriptorProcessor {
	/**
	 * Creates a transaction descriptor processor.
	 * @param {object} transactionDescriptor Transaction descriptor.
	 * @param {Map<string, Function>} typeParsingRules Type-dependent parsing rules.
	 * @param {Function|undefined} typeConverter Converts a generated type to an sdk type (optional).
	 */
	constructor(transactionDescriptor, typeParsingRules, typeConverter = undefined) {
		/**
		 * @private
		 */
		this._transactionDescriptor = transactionDescriptor;

		/**
		 * @private
		 */
		this._typeParsingRules = typeParsingRules;

		/**
		 * Tries to coerce a value to a more appropriate type.
		 * @param {object} value Original value.
		 * @returns {object} Type converted value.
		 * @private
		 */
		this._typeConverter = typeConverter || (value => value);

		/**
		 * @private
		 */
		this._typeHints = {};
	}

	/**
	 * Looks up value and applies type hints.
	 * @param {string} key Key for which to retrieve value.
	 * @returns {object} Value corresponding to key.
	 * @private
	 */
	_lookupValueAndApplyTypeHints(key) {
		if (undefined === this._transactionDescriptor[key])
			throw RangeError(`transaction descriptor does not have attribute ${key}`);

		let value = this._transactionDescriptor[key];
		const typeHint = this._typeHints[key];
		const rule = this._typeParsingRules.get(typeHint);
		if (rule)
			value = rule(value);

		return value;
	}

	/**
	 * Looks up the value for key.
	 * @param {string} key Key for which to retrieve value.
	 * @returns {object} Value corresponding to key.
	 */
	lookupValue(key) {
		const value = this._lookupValueAndApplyTypeHints(key);
		return Array.isArray(value)
			? value.map(item => this._typeConverter(item))
			: this._typeConverter(value);
	}

	/**
	 * Copies all descriptor information to a transaction.
	 * @param {object} transaction Transaction to which to copy keys.
	 * @param {Array<string>|undefined} ignoreKeys Keys of descriptor values not to copy (optional).
	 */
	copyTo(transaction, ignoreKeys = undefined) {
		Object.getOwnPropertyNames(this._transactionDescriptor).forEach(key => {
			if (ignoreKeys && -1 !== ignoreKeys.indexOf(key))
				return;

			if (key.endsWith('Computed'))
				throw RangeError(`cannot explicitly set computed field ${key}`);

			if (undefined === transaction[key])
				throw RangeError(`transaction does not have attribute ${key}`);

			const value = this.lookupValue(key);
			transaction[key] = value;
		});
	}

	/**
	 * Sets type hints.
	 * @param {TypeHintsMap|undefined} typeHints New type hints. // eslint-disable-line valid-jsdoc
	 */
	setTypeHints(typeHints) {
		this._typeHints = typeHints || {};
	}
}

// region type declarations

/**
 * Type hints map.
 * @class
 * @typedef {{[key: string]: string}} TypeHintsMap
 */

// endregion


/***/ }),

/***/ "./node_modules/symbol-sdk/src/facade/SymbolFacade.js":
/*!************************************************************!*\
  !*** ./node_modules/symbol-sdk/src/facade/SymbolFacade.js ***!
  \************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SymbolAccount: () => (/* binding */ SymbolAccount),
/* harmony export */   SymbolFacade: () => (/* binding */ SymbolFacade),
/* harmony export */   SymbolPublicAccount: () => (/* binding */ SymbolPublicAccount)
/* harmony export */ });
/* harmony import */ var _Bip32_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Bip32.js */ "./node_modules/symbol-sdk/src/Bip32.js");
/* harmony import */ var _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CryptoTypes.js */ "./node_modules/symbol-sdk/src/CryptoTypes.js");
/* harmony import */ var _Network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Network.js */ "./node_modules/symbol-sdk/src/Network.js");
/* harmony import */ var _symbol_KeyPair_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../symbol/KeyPair.js */ "./node_modules/symbol-sdk/src/symbol/KeyPair.js");
/* harmony import */ var _symbol_MessageEncoder_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../symbol/MessageEncoder.js */ "./node_modules/symbol-sdk/src/symbol/MessageEncoder.js");
/* harmony import */ var _symbol_Network_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../symbol/Network.js */ "./node_modules/symbol-sdk/src/symbol/Network.js");
/* harmony import */ var _symbol_SharedKey_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../symbol/SharedKey.js */ "./node_modules/symbol-sdk/src/symbol/SharedKey.js");
/* harmony import */ var _symbol_TransactionFactory_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../symbol/TransactionFactory.js */ "./node_modules/symbol-sdk/src/symbol/TransactionFactory.js");
/* harmony import */ var _symbol_merkle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../symbol/merkle.js */ "./node_modules/symbol-sdk/src/symbol/merkle.js");
/* harmony import */ var _symbol_models_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../symbol/models.js */ "./node_modules/symbol-sdk/src/symbol/models.js");
/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @noble/hashes/sha3 */ "./node_modules/@noble/hashes/esm/sha3.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_symbol_KeyPair_js__WEBPACK_IMPORTED_MODULE_3__, _symbol_MessageEncoder_js__WEBPACK_IMPORTED_MODULE_4__, _symbol_SharedKey_js__WEBPACK_IMPORTED_MODULE_6__]);
([_symbol_KeyPair_js__WEBPACK_IMPORTED_MODULE_3__, _symbol_MessageEncoder_js__WEBPACK_IMPORTED_MODULE_4__, _symbol_SharedKey_js__WEBPACK_IMPORTED_MODULE_6__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
/* eslint-disable no-unused-vars */

/* eslint-enable no-unused-vars */











const TRANSACTION_HEADER_SIZE = [
	4, // size
	4, // reserved1
	_CryptoTypes_js__WEBPACK_IMPORTED_MODULE_1__.Signature.SIZE, // signature
	_CryptoTypes_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey.SIZE, // signer
	4 // reserved2
].reduce((x, y) => x + y);

const AGGREGATE_HASHED_SIZE = [
	4, // version, network, type
	8, // maxFee
	8, // deadline
	_CryptoTypes_js__WEBPACK_IMPORTED_MODULE_1__.Hash256.SIZE // transactionsHash
].reduce((x, y) => x + y);

const isAggregateTransaction = transactionBuffer => {
	const transactionTypeOffset = TRANSACTION_HEADER_SIZE + 2; // skip version and network byte
	const transactionType = (transactionBuffer[transactionTypeOffset + 1] << 8) + transactionBuffer[transactionTypeOffset];
	const aggregateTypes = [_symbol_models_js__WEBPACK_IMPORTED_MODULE_9__.TransactionType.AGGREGATE_BONDED.value, _symbol_models_js__WEBPACK_IMPORTED_MODULE_9__.TransactionType.AGGREGATE_COMPLETE.value];
	return aggregateTypes.some(aggregateType => aggregateType === transactionType);
};

const transactionDataBuffer = transactionBuffer => {
	const dataBufferStart = TRANSACTION_HEADER_SIZE;
	const dataBufferEnd = isAggregateTransaction(transactionBuffer)
		? TRANSACTION_HEADER_SIZE + AGGREGATE_HASHED_SIZE
		: transactionBuffer.length;

	return transactionBuffer.subarray(dataBufferStart, dataBufferEnd);
};

// region SymbolPublicAccount / SymbolAccount

/**
 * Symbol public account.
 */
class SymbolPublicAccount {
	/**
	 * Creates a Symbol public account.
	 * @param {SymbolFacade} facade Symbol facade.
	 * @param {PublicKey} publicKey Account public key.
	 */
	constructor(facade, publicKey) {
		/**
		 * @protected
		 */
		this._facade = facade;

		/**
		 * Account public key.
		 * @type {PublicKey}
		 */
		this.publicKey = publicKey;

		/**
		 * Account address.
		 * @type {Address}
		 */
		this.address = this._facade.network.publicKeyToAddress(this.publicKey);
	}
}

/**
 * Symbol account.
 */
class SymbolAccount extends SymbolPublicAccount {
	/**
	 * Creates a Symbol account.
	 * @param {SymbolFacade} facade Symbol facade.
	 * @param {KeyPair} keyPair Account key pair.
	 */
	constructor(facade, keyPair) {
		super(facade, keyPair.publicKey);

		/**
		 * Account key pair.
		 * @type {KeyPair}
		 */
		this.keyPair = keyPair;
	}

	/**
	 * Creates a message encoder that can be used for encrypting and encoding messages between two parties.
	 * @returns {MessageEncoder} Message encoder using this account as one party.
	 */
	messageEncoder() {
		return new _symbol_MessageEncoder_js__WEBPACK_IMPORTED_MODULE_4__["default"](this.keyPair);
	}

	/**
	 * Signs a Symbol transaction.
	 * @param {sc.Transaction} transaction Transaction object.
	 * @returns {Signature} Transaction signature.
	 */
	signTransaction(transaction) {
		return this._facade.signTransaction(this.keyPair, transaction);
	}

	/**
	 * Cosigns a Symbol transaction.
	 * @param {sc.Transaction} transaction Transaction object.
	 * @param {boolean} detached \c true if resulting cosignature is appropriate for network propagation.
	 *                           \c false if resulting cosignature is appropriate for attaching to an aggregate.
	 * @returns {sc.Cosignature|sc.DetachedCosignature} Signed cosignature.
	 */
	cosignTransaction(transaction, detached = false) {
		return this._facade.cosignTransaction(this.keyPair, transaction, detached);
	}

	/**
	 * Cosigns a Symbol transaction hash.
	 * @param {Hash256} transactionHash Transaction hash.
	 * @param {boolean} detached \c true if resulting cosignature is appropriate for network propagation.
	 *                           \c false if resulting cosignature is appropriate for attaching to an aggregate.
	 * @returns {sc.Cosignature|sc.DetachedCosignature} Signed cosignature.
	 */
	cosignTransactionHash(transactionHash, detached = false) {
		return this._facade.static.cosignTransactionHash(this.keyPair, transactionHash, detached);
	}
}

// endregion

/**
 * Facade used to interact with Symbol blockchain.
 */
class SymbolFacade {
	/**
	 * BIP32 curve name.
	 * @type {string}
	 */
	static BIP32_CURVE_NAME = 'ed25519';

	/**
	 * Network address class type.
	 * @type {typeof Address}
	 */
	static Address = _symbol_Network_js__WEBPACK_IMPORTED_MODULE_5__.Address;

	/**
	 * Network key pair class type.
	 * @type {typeof KeyPair}
	 */
	static KeyPair = _symbol_KeyPair_js__WEBPACK_IMPORTED_MODULE_3__.KeyPair;

	/**
	 * Network verifier class type.
	 * @type {typeof Verifier}
	 */
	static Verifier = _symbol_KeyPair_js__WEBPACK_IMPORTED_MODULE_3__.Verifier;

	/**
	 * Derives shared key from key pair and other party's public key.
	 * @param {KeyPair} keyPair Key pair.
	 * @param {PublicKey} otherPublicKey Other party's public key.
	 * @returns {SharedKey256} Shared encryption key.
	 */
	static deriveSharedKey = _symbol_SharedKey_js__WEBPACK_IMPORTED_MODULE_6__.deriveSharedKey;

	/**
	 * Creates a Symbol facade.
	 * @param {string|Network} network Symbol network or network name.
	 */
	constructor(network) {
		/**
		 * Underlying network.
		 * @type {Network}
		 */
		this.network = 'string' === typeof network ? _Network_js__WEBPACK_IMPORTED_MODULE_2__.NetworkLocator.findByName(_symbol_Network_js__WEBPACK_IMPORTED_MODULE_5__.Network.NETWORKS, network) : network;

		/**
		 * Underlying transaction factory.
		 * @type {TransactionFactory}
		 */
		this.transactionFactory = new _symbol_TransactionFactory_js__WEBPACK_IMPORTED_MODULE_7__["default"](this.network);
	}

	/**
	 * Gets class type.
	 * @returns {typeof SymbolFacade} Class type.
	 */
	get static() { // eslint-disable-line class-methods-use-this
		return SymbolFacade;
	}

	/**
	 * Creates a network timestamp representing the current time.
	 * @returns {NetworkTimestamp} Network timestamp representing the current time.
	 */
	now() {
		return this.network.fromDatetime(new Date());
	}

	/**
	 * Creates a Symbol public account from a public key.
	 * @param {PublicKey} publicKey Account public key.
	 * @returns {SymbolPublicAccount} Symbol public account.
	 */
	createPublicAccount(publicKey) {
		return new SymbolPublicAccount(this, publicKey);
	}

	/**
	 * Creates a Symbol account from a private key.
	 * @param {PrivateKey} privateKey Account private key.
	 * @returns {SymbolAccount} Symbol account.
	 */
	createAccount(privateKey) {
		return new SymbolAccount(this, new _symbol_KeyPair_js__WEBPACK_IMPORTED_MODULE_3__.KeyPair(privateKey));
	}

	/**
	 * Creates a transaction from a (typed) transaction descriptor.
	 * @param {object} typedDescriptor Transaction (typed) descriptor.
	 * @param {PublicKey} signerPublicKey Signer public key.
	 * @param {number} feeMultiplier Fee multiplier.
	 * @param {number} deadlineSeconds Approximate seconds from now for deadline.
	 * @param {number} cosignatureCount Number of cosignature spaces to reserve.
	 * @returns {sc.Transaction} Created transaction.
	 */
	createTransactionFromTypedDescriptor(typedDescriptor, signerPublicKey, feeMultiplier, deadlineSeconds, cosignatureCount = 0) {
		const rawDescriptor = typedDescriptor.toMap();
		const transaction = this.transactionFactory.create({
			...rawDescriptor,

			signerPublicKey,
			deadline: this.now().addSeconds(deadlineSeconds).timestamp
		});

		// if cosignatures are specified in the descriptor, use the max of them and cosignatureCount
		let cosignatureCountAdjustment = cosignatureCount;
		if (rawDescriptor.cosignatures) {
			cosignatureCountAdjustment = rawDescriptor.cosignatures.length > cosignatureCount
				? 0
				: cosignatureCount - rawDescriptor.cosignatures.length;
		}

		const transactionWithCosignaturesSize = transaction.size + (cosignatureCountAdjustment * new _symbol_models_js__WEBPACK_IMPORTED_MODULE_9__.Cosignature().size);
		transaction.fee = new _symbol_models_js__WEBPACK_IMPORTED_MODULE_9__.Amount(BigInt(transactionWithCosignaturesSize) * BigInt(feeMultiplier));
		return transaction;
	}

	/**
	 * Creates an embedded transaction from a (typed) transaction descriptor.
	 * @param {object} typedDescriptor Transaction (typed) descriptor.
	 * @param {PublicKey} signerPublicKey Signer public key.
	 * @returns {sc.EmbeddedTransaction} Created embedded transaction.
	 */
	createEmbeddedTransactionFromTypedDescriptor(typedDescriptor, signerPublicKey) {
		const transaction = this.transactionFactory.createEmbedded({
			...typedDescriptor.toMap(),

			signerPublicKey
		});
		return transaction;
	}

	/**
	 * Hashes a Symbol transaction.
	 * @param {sc.Transaction} transaction Transaction object.
	 * @returns {Hash256} Transaction hash.
	 */
	hashTransaction(transaction) {
		const hasher = _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_10__.sha3_256.create();
		hasher.update(transaction.signature.bytes);
		hasher.update(transaction.signerPublicKey.bytes);
		hasher.update(this.network.generationHashSeed.bytes);
		hasher.update(transactionDataBuffer(transaction.serialize()));
		return new _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_1__.Hash256(hasher.digest());
	}

	/**
	 * Gets the payload to sign given a Symbol transaction.
	 * @param {sc.Transaction} transaction Transaction object.
	 * @returns {Uint8Array} Verifiable data to sign.
	 */
	extractSigningPayload(transaction) {
		return new Uint8Array([
			...this.network.generationHashSeed.bytes,
			...transactionDataBuffer(transaction.serialize())
		]);
	}

	/**
	 * Signs a Symbol transaction.
	 * @param {KeyPair} keyPair Key pair.
	 * @param {sc.Transaction} transaction Transaction object.
	 * @returns {Signature} Transaction signature.
	 */
	signTransaction(keyPair, transaction) {
		return keyPair.sign(this.extractSigningPayload(transaction));
	}

	/**
	 * Verifies a Symbol transaction.
	 * @param {sc.Transaction} transaction Transaction object.
	 * @param {Signature} signature Signature to verify.
	 * @returns {boolean} \c true if transaction signature is verified.
	 */
	verifyTransaction(transaction, signature) {
		const verifyBuffer = new Uint8Array(this.extractSigningPayload(transaction));
		return new _symbol_KeyPair_js__WEBPACK_IMPORTED_MODULE_3__.Verifier(transaction.signerPublicKey).verify(verifyBuffer, signature);
	}

	/**
	 * Cosigns a Symbol transaction hash.
	 * @param {KeyPair} keyPair Key pair of the cosignatory.
	 * @param {Hash256} transactionHash Transaction hash.
	 * @param {boolean} detached \c true if resulting cosignature is appropriate for network propagation.
	 *                           \c false if resulting cosignature is appropriate for attaching to an aggregate.
	 * @returns {sc.Cosignature|sc.DetachedCosignature} Signed cosignature.
	 */
	static cosignTransactionHash(keyPair, transactionHash, detached = false) {
		const initializeCosignature = cosignature => {
			cosignature.version = 0n;
			cosignature.signerPublicKey = new _symbol_models_js__WEBPACK_IMPORTED_MODULE_9__.PublicKey(keyPair.publicKey.bytes);
			cosignature.signature = new _symbol_models_js__WEBPACK_IMPORTED_MODULE_9__.Signature(keyPair.sign(transactionHash.bytes).bytes);
		};

		if (detached) {
			const cosignature = new _symbol_models_js__WEBPACK_IMPORTED_MODULE_9__.DetachedCosignature();
			cosignature.parentHash = new _symbol_models_js__WEBPACK_IMPORTED_MODULE_9__.Hash256(transactionHash.bytes);
			initializeCosignature(cosignature);
			return cosignature;
		}

		const cosignature = new _symbol_models_js__WEBPACK_IMPORTED_MODULE_9__.Cosignature();
		initializeCosignature(cosignature);
		return cosignature;
	}

	/**
	 * Cosigns a Symbol transaction.
	 * @param {KeyPair} keyPair Key pair of the cosignatory.
	 * @param {sc.Transaction} transaction Transaction object.
	 * @param {boolean} detached \c true if resulting cosignature is appropriate for network propagation.
	 *                           \c false if resulting cosignature is appropriate for attaching to an aggregate.
	 * @returns {sc.Cosignature|sc.DetachedCosignature} Signed cosignature.
	 */
	cosignTransaction(keyPair, transaction, detached = false) {
		const transactionHash = this.hashTransaction(transaction);

		return SymbolFacade.cosignTransactionHash(keyPair, transactionHash, detached);
	}

	/**
	 * Hashes embedded transactions of an aggregate transaction.
	 * @param {Array<sc.EmbeddedTransaction>} embeddedTransactions Embedded transactions to hash.
	 * @returns {Hash256} Aggregate transactions hash.
	 */
	static hashEmbeddedTransactions(embeddedTransactions) {
		const hashBuilder = new _symbol_merkle_js__WEBPACK_IMPORTED_MODULE_8__.MerkleHashBuilder();
		embeddedTransactions.forEach(embeddedTransaction => {
			hashBuilder.update(new _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_1__.Hash256((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_10__.sha3_256)(embeddedTransaction.serialize())));
		});

		return hashBuilder.final();
	}

	/**
	 * Creates a network compatible BIP32 path for the specified account.
	 * @param {number} accountId Id of the account for which to generate a BIP32 path.
	 * @returns {Array<number>} BIP32 path for the specified account.
	 */
	bip32Path(accountId) {
		return [44, 'mainnet' === this.network.name ? 4343 : 1, accountId, 0, 0];
	}

	/**
	 * Derives a Symbol KeyPair from a BIP32 node.
	 * @param {Bip32Node} bip32Node BIP32 node.
	 * @returns {KeyPair} Derived key pair.
	 */
	static bip32NodeToKeyPair(bip32Node) {
		return new _symbol_KeyPair_js__WEBPACK_IMPORTED_MODULE_3__.KeyPair(new _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_1__.PrivateKey(bip32Node.privateKey.bytes));
	}
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/symbol-sdk/src/impl/CipherHelpers.js":
/*!***********************************************************!*\
  !*** ./node_modules/symbol-sdk/src/impl/CipherHelpers.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   concatArrays: () => (/* binding */ concatArrays),
/* harmony export */   decodeAesCbc: () => (/* binding */ decodeAesCbc),
/* harmony export */   decodeAesGcm: () => (/* binding */ decodeAesGcm),
/* harmony export */   encodeAesCbc: () => (/* binding */ encodeAesCbc),
/* harmony export */   encodeAesGcm: () => (/* binding */ encodeAesGcm)
/* harmony export */ });
/* harmony import */ var _Cipher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Cipher.js */ "./node_modules/symbol-sdk/src/Cipher.js");
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ "./node_modules/crypto-browserify/index.js");
// this file contains implementation details and is not intended to be used directly




const GCM_IV_SIZE = 12;
const CBC_IV_SIZE = 16;
const SALT_SIZE = 32;

const concatArrays = (...arrays) => {
	const totalLength = arrays.map(buffer => buffer.length).reduce((accumulator, currentValue) => accumulator + currentValue);
	const result = new Uint8Array(totalLength);
	let targetOffset = 0;
	arrays.forEach(buffer => {
		result.set(buffer, targetOffset);
		targetOffset += buffer.length;
	});
	return result;
};

const decode = (tagSize, ivSize, encodedMessage) => ({
	tag: encodedMessage.subarray(0, tagSize),
	initializationVector: encodedMessage.subarray(tagSize, tagSize + ivSize),
	encodedMessageData: encodedMessage.subarray(tagSize + ivSize)
});

const decodeAesGcm = (deriveSharedKey, keyPair, recipientPublicKey, encodedMessage) => {
	const { tag, initializationVector, encodedMessageData } = decode(_Cipher_js__WEBPACK_IMPORTED_MODULE_0__.AesGcmCipher.TAG_SIZE, GCM_IV_SIZE, encodedMessage);

	const sharedKey = deriveSharedKey(keyPair, recipientPublicKey);
	const cipher = new _Cipher_js__WEBPACK_IMPORTED_MODULE_0__.AesGcmCipher(sharedKey);

	return new Uint8Array(cipher.decrypt(concatArrays(encodedMessageData, tag), initializationVector));
};

const decodeAesCbc = (deriveSharedKey, keyPair, recipientPublicKey, encodedMessage) => {
	const { tag, initializationVector, encodedMessageData } = decode(SALT_SIZE, CBC_IV_SIZE, encodedMessage);

	const sharedKey = deriveSharedKey(keyPair, recipientPublicKey, tag);
	const cipher = new _Cipher_js__WEBPACK_IMPORTED_MODULE_0__.AesCbcCipher(sharedKey);

	return new Uint8Array(cipher.decrypt(encodedMessageData, initializationVector));
};

const encodeAesGcm = (deriveSharedKey, keyPair, recipientPublicKey, message) => {
	const sharedKey = deriveSharedKey(keyPair, recipientPublicKey);
	const cipher = new _Cipher_js__WEBPACK_IMPORTED_MODULE_0__.AesGcmCipher(sharedKey);

	const initializationVector = new Uint8Array(crypto__WEBPACK_IMPORTED_MODULE_1__.randomBytes(GCM_IV_SIZE));
	const cipherText = cipher.encrypt(message, initializationVector);
	const tagStartOffset = cipherText.length - _Cipher_js__WEBPACK_IMPORTED_MODULE_0__.AesGcmCipher.TAG_SIZE;
	const tag = cipherText.subarray(tagStartOffset);

	return { tag, initializationVector, cipherText: cipherText.subarray(0, tagStartOffset) };
};

const encodeAesCbc = (deriveSharedKey, keyPair, recipientPublicKey, message) => {
	const salt = new Uint8Array(crypto__WEBPACK_IMPORTED_MODULE_1__.randomBytes(SALT_SIZE));
	const sharedKey = deriveSharedKey(keyPair, recipientPublicKey, salt);
	const cipher = new _Cipher_js__WEBPACK_IMPORTED_MODULE_0__.AesCbcCipher(sharedKey);

	const initializationVector = new Uint8Array(crypto__WEBPACK_IMPORTED_MODULE_1__.randomBytes(CBC_IV_SIZE));
	const cipherText = cipher.encrypt(message, initializationVector);

	return { salt, initializationVector, cipherText };
};




/***/ }),

/***/ "./node_modules/symbol-sdk/src/impl/ed25519.js":
/*!*****************************************************!*\
  !*** ./node_modules/symbol-sdk/src/impl/ed25519.js ***!
  \*****************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ed25519_js_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ed25519_js.js */ "./node_modules/symbol-sdk/src/impl/ed25519_js.js");
/* harmony import */ var _ed25519_wasm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ed25519_wasm.js */ "./node_modules/symbol-sdk/src/impl/ed25519_wasm.js");
/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ "./node_modules/process/browser.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_ed25519_wasm_js__WEBPACK_IMPORTED_MODULE_1__]);
_ed25519_wasm_js__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
// this file contains implementation details and is not intended to be used directly




let ed25519;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
	get: () => {
		// 1. certain environments, like ReactNative, do not support WebAssembly
		//    in those cases, default to JS-implementation
		// 2. for testing, check environment variable to force JS-implementation
		if (!ed25519)
			ed25519 = globalThis.WebAssembly && !process.env.SYMBOL_SDK_NO_WASM ? _ed25519_wasm_js__WEBPACK_IMPORTED_MODULE_1__["default"] : _ed25519_js_js__WEBPACK_IMPORTED_MODULE_0__["default"];

		return ed25519;
	},
	unload: () => {
		ed25519 = undefined;
	}
});

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/symbol-sdk/src/impl/ed25519_js.js":
/*!********************************************************!*\
  !*** ./node_modules/symbol-sdk/src/impl/ed25519_js.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _external_tweetnacl_nacl_fast_symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./external/tweetnacl-nacl-fast-symbol.js */ "./node_modules/symbol-sdk/src/impl/external/tweetnacl-nacl-fast-symbol.js");
/* harmony import */ var _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/arrayHelpers.js */ "./node_modules/symbol-sdk/src/utils/arrayHelpers.js");
/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha3 */ "./node_modules/@noble/hashes/esm/sha3.js");
/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/sha512 */ "./node_modules/@noble/hashes/esm/sha512.js");
// this file contains implementation details and is not intended to be used directly






const getHasher = hashMode => ('Keccak' === hashMode ? _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_2__.keccak_512 : _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_3__.sha512);

const isCanonicalS = encodedS => {
	const reduce = r => {
		const x = new Float64Array(64);
		let i;
		for (i = 0; 64 > i; i++)
			x[i] = r[i];

		for (i = 0; 64 > i; i++)
			r[i] = 0;

		_external_tweetnacl_nacl_fast_symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].lowlevel.modL(r, x);
	};

	// require canonical signature
	const reducedEncodedS = new Uint8Array([...encodedS, ...new Uint8Array(32)]);
	reduce(reducedEncodedS);
	return 0 === (0,_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_1__.deepCompare)(encodedS, reducedEncodedS.subarray(0, 32));
};

const ed25519 = {
	keyPairFromSeed: (hashMode, seed) => _external_tweetnacl_nacl_fast_symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].sign.keyPair.fromSeed(seed, getHasher(hashMode)),
	sign: (hashMode, message, keyPair) => _external_tweetnacl_nacl_fast_symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].sign.detached(message, keyPair.secretKey, getHasher(hashMode)),
	verify: (hashMode, message, signature, publicKey) => _external_tweetnacl_nacl_fast_symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].sign.detached.verify(message, signature, publicKey, getHasher(hashMode))
		&& isCanonicalS(signature.subarray(32, 64))
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ed25519);


/***/ }),

/***/ "./node_modules/symbol-sdk/src/impl/ed25519_wasm.js":
/*!**********************************************************!*\
  !*** ./node_modules/symbol-sdk/src/impl/ed25519_wasm.js ***!
  \**********************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var symbol_crypto_wasm_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! symbol-crypto-wasm-node */ "./node_modules/symbol-crypto-wasm-web/symbol_crypto_wasm.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([symbol_crypto_wasm_node__WEBPACK_IMPORTED_MODULE_0__]);
symbol_crypto_wasm_node__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
// this file contains implementation details and is not intended to be used directly

/* eslint-disable import/no-extraneous-dependencies */

/* eslint-enable import/no-extraneous-dependencies */

const CRYPTO_SIGN_BYTES = 64;
const CRYPTO_SIGN_PUBLICKEYBYTES = 32;

const ed25519 = {
	keyPairFromSeed: (hashMode, seed) => {
		const publicKey = new Uint8Array(CRYPTO_SIGN_PUBLICKEYBYTES);
		(0,symbol_crypto_wasm_node__WEBPACK_IMPORTED_MODULE_0__.crypto_sign_keypair)(symbol_crypto_wasm_node__WEBPACK_IMPORTED_MODULE_0__.HashMode[hashMode], seed, publicKey);
		return { publicKey, privateKey: seed };
	},
	sign: (hashMode, message, keyPair) => {
		const signature = new Uint8Array(CRYPTO_SIGN_BYTES);
		(0,symbol_crypto_wasm_node__WEBPACK_IMPORTED_MODULE_0__.crypto_private_sign)(symbol_crypto_wasm_node__WEBPACK_IMPORTED_MODULE_0__.HashMode[hashMode], keyPair.privateKey, message, signature);
		return signature;
	},
	verify: (hashMode, message, signature, publicKey) => (0,symbol_crypto_wasm_node__WEBPACK_IMPORTED_MODULE_0__.crypto_private_verify)(symbol_crypto_wasm_node__WEBPACK_IMPORTED_MODULE_0__.HashMode[hashMode], publicKey, message, signature)
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ed25519);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/symbol-sdk/src/impl/external/tweetnacl-nacl-fast-symbol.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/symbol-sdk/src/impl/external/tweetnacl-nacl-fast-symbol.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// this file is based on tweetnacl/nacl-fast with the following changes:
// - allows custom hash functions
// - pruned to include minimal dependencies
// - ES6

/* eslint-disable
	comma-spacing,
	computed-property-spacing,
	curly,
	func-style,
	indent,
	keyword-spacing,
	max-len,
	no-mixed-operators,
	no-mixed-spaces-and-tabs,
	no-multi-spaces,
	no-underscore-dangle,
	no-var,
	nonblock-statement-body-position,
	object-curly-spacing,
	one-var,
	one-var-declaration-per-line,
	space-before-function-paren,
	space-infix-ops,
	vars-on-top,
	yoda,
	jsdoc/require-jsdoc
*/

var gf = function(init) {
	var i, r = new Float64Array(16);
	if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
	return r;
};

var _9 = new Uint8Array(32); _9[0] = 9;

var gf0 = gf(),
		gf1 = gf([1]),
		D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
		D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
		X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
		Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
		I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

function vn(x, xi, y, yi, n) {
	var i,d = 0;
	for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
	return (1 & ((d - 1) >>> 8)) - 1;
}

function crypto_verify_32(x, xi, y, yi) {
	return vn(x,xi,y,yi,32);
}

function set25519(r, a) {
	var i;
	for (i = 0; i < 16; i++) r[i] = a[i]|0;
}

function car25519(o) {
	var i, v, c = 1;
	for (i = 0; i < 16; i++) {
		v = o[i] + c + 65535;
		c = Math.floor(v / 65536);
		o[i] = v - c * 65536;
	}
	o[0] += c-1 + 37 * (c-1);
}

function sel25519(p, q, b) {
	var t, c = ~(b-1);
	for (var i = 0; i < 16; i++) {
		t = c & (p[i] ^ q[i]);
		p[i] ^= t;
		q[i] ^= t;
	}
}

function pack25519(o, n) {
	var i, j, b;
	var m = gf(), t = gf();
	for (i = 0; i < 16; i++) t[i] = n[i];
	car25519(t);
	car25519(t);
	car25519(t);
	for (j = 0; j < 2; j++) {
		m[0] = t[0] - 0xffed;
		for (i = 1; i < 15; i++) {
			m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
			m[i-1] &= 0xffff;
		}
		m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
		b = (m[15]>>16) & 1;
		m[14] &= 0xffff;
		sel25519(t, m, 1-b);
	}
	for (i = 0; i < 16; i++) {
		o[2*i] = t[i] & 0xff;
		o[2*i+1] = t[i]>>8;
	}
}

function neq25519(a, b) {
	var c = new Uint8Array(32), d = new Uint8Array(32);
	pack25519(c, a);
	pack25519(d, b);
	return crypto_verify_32(c, 0, d, 0);
}

function par25519(a) {
	var d = new Uint8Array(32);
	pack25519(d, a);
	return d[0] & 1;
}

function unpack25519(o, n) {
	var i;
	for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
	o[15] &= 0x7fff;
}

function A(o, a, b) {
	for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
}

function Z(o, a, b) {
	for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
}

function M(o, a, b) {
	var v, c,
		 t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
		 t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
		t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
		t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
		b0 = b[0],
		b1 = b[1],
		b2 = b[2],
		b3 = b[3],
		b4 = b[4],
		b5 = b[5],
		b6 = b[6],
		b7 = b[7],
		b8 = b[8],
		b9 = b[9],
		b10 = b[10],
		b11 = b[11],
		b12 = b[12],
		b13 = b[13],
		b14 = b[14],
		b15 = b[15];

	v = a[0];
	t0 += v * b0;
	t1 += v * b1;
	t2 += v * b2;
	t3 += v * b3;
	t4 += v * b4;
	t5 += v * b5;
	t6 += v * b6;
	t7 += v * b7;
	t8 += v * b8;
	t9 += v * b9;
	t10 += v * b10;
	t11 += v * b11;
	t12 += v * b12;
	t13 += v * b13;
	t14 += v * b14;
	t15 += v * b15;
	v = a[1];
	t1 += v * b0;
	t2 += v * b1;
	t3 += v * b2;
	t4 += v * b3;
	t5 += v * b4;
	t6 += v * b5;
	t7 += v * b6;
	t8 += v * b7;
	t9 += v * b8;
	t10 += v * b9;
	t11 += v * b10;
	t12 += v * b11;
	t13 += v * b12;
	t14 += v * b13;
	t15 += v * b14;
	t16 += v * b15;
	v = a[2];
	t2 += v * b0;
	t3 += v * b1;
	t4 += v * b2;
	t5 += v * b3;
	t6 += v * b4;
	t7 += v * b5;
	t8 += v * b6;
	t9 += v * b7;
	t10 += v * b8;
	t11 += v * b9;
	t12 += v * b10;
	t13 += v * b11;
	t14 += v * b12;
	t15 += v * b13;
	t16 += v * b14;
	t17 += v * b15;
	v = a[3];
	t3 += v * b0;
	t4 += v * b1;
	t5 += v * b2;
	t6 += v * b3;
	t7 += v * b4;
	t8 += v * b5;
	t9 += v * b6;
	t10 += v * b7;
	t11 += v * b8;
	t12 += v * b9;
	t13 += v * b10;
	t14 += v * b11;
	t15 += v * b12;
	t16 += v * b13;
	t17 += v * b14;
	t18 += v * b15;
	v = a[4];
	t4 += v * b0;
	t5 += v * b1;
	t6 += v * b2;
	t7 += v * b3;
	t8 += v * b4;
	t9 += v * b5;
	t10 += v * b6;
	t11 += v * b7;
	t12 += v * b8;
	t13 += v * b9;
	t14 += v * b10;
	t15 += v * b11;
	t16 += v * b12;
	t17 += v * b13;
	t18 += v * b14;
	t19 += v * b15;
	v = a[5];
	t5 += v * b0;
	t6 += v * b1;
	t7 += v * b2;
	t8 += v * b3;
	t9 += v * b4;
	t10 += v * b5;
	t11 += v * b6;
	t12 += v * b7;
	t13 += v * b8;
	t14 += v * b9;
	t15 += v * b10;
	t16 += v * b11;
	t17 += v * b12;
	t18 += v * b13;
	t19 += v * b14;
	t20 += v * b15;
	v = a[6];
	t6 += v * b0;
	t7 += v * b1;
	t8 += v * b2;
	t9 += v * b3;
	t10 += v * b4;
	t11 += v * b5;
	t12 += v * b6;
	t13 += v * b7;
	t14 += v * b8;
	t15 += v * b9;
	t16 += v * b10;
	t17 += v * b11;
	t18 += v * b12;
	t19 += v * b13;
	t20 += v * b14;
	t21 += v * b15;
	v = a[7];
	t7 += v * b0;
	t8 += v * b1;
	t9 += v * b2;
	t10 += v * b3;
	t11 += v * b4;
	t12 += v * b5;
	t13 += v * b6;
	t14 += v * b7;
	t15 += v * b8;
	t16 += v * b9;
	t17 += v * b10;
	t18 += v * b11;
	t19 += v * b12;
	t20 += v * b13;
	t21 += v * b14;
	t22 += v * b15;
	v = a[8];
	t8 += v * b0;
	t9 += v * b1;
	t10 += v * b2;
	t11 += v * b3;
	t12 += v * b4;
	t13 += v * b5;
	t14 += v * b6;
	t15 += v * b7;
	t16 += v * b8;
	t17 += v * b9;
	t18 += v * b10;
	t19 += v * b11;
	t20 += v * b12;
	t21 += v * b13;
	t22 += v * b14;
	t23 += v * b15;
	v = a[9];
	t9 += v * b0;
	t10 += v * b1;
	t11 += v * b2;
	t12 += v * b3;
	t13 += v * b4;
	t14 += v * b5;
	t15 += v * b6;
	t16 += v * b7;
	t17 += v * b8;
	t18 += v * b9;
	t19 += v * b10;
	t20 += v * b11;
	t21 += v * b12;
	t22 += v * b13;
	t23 += v * b14;
	t24 += v * b15;
	v = a[10];
	t10 += v * b0;
	t11 += v * b1;
	t12 += v * b2;
	t13 += v * b3;
	t14 += v * b4;
	t15 += v * b5;
	t16 += v * b6;
	t17 += v * b7;
	t18 += v * b8;
	t19 += v * b9;
	t20 += v * b10;
	t21 += v * b11;
	t22 += v * b12;
	t23 += v * b13;
	t24 += v * b14;
	t25 += v * b15;
	v = a[11];
	t11 += v * b0;
	t12 += v * b1;
	t13 += v * b2;
	t14 += v * b3;
	t15 += v * b4;
	t16 += v * b5;
	t17 += v * b6;
	t18 += v * b7;
	t19 += v * b8;
	t20 += v * b9;
	t21 += v * b10;
	t22 += v * b11;
	t23 += v * b12;
	t24 += v * b13;
	t25 += v * b14;
	t26 += v * b15;
	v = a[12];
	t12 += v * b0;
	t13 += v * b1;
	t14 += v * b2;
	t15 += v * b3;
	t16 += v * b4;
	t17 += v * b5;
	t18 += v * b6;
	t19 += v * b7;
	t20 += v * b8;
	t21 += v * b9;
	t22 += v * b10;
	t23 += v * b11;
	t24 += v * b12;
	t25 += v * b13;
	t26 += v * b14;
	t27 += v * b15;
	v = a[13];
	t13 += v * b0;
	t14 += v * b1;
	t15 += v * b2;
	t16 += v * b3;
	t17 += v * b4;
	t18 += v * b5;
	t19 += v * b6;
	t20 += v * b7;
	t21 += v * b8;
	t22 += v * b9;
	t23 += v * b10;
	t24 += v * b11;
	t25 += v * b12;
	t26 += v * b13;
	t27 += v * b14;
	t28 += v * b15;
	v = a[14];
	t14 += v * b0;
	t15 += v * b1;
	t16 += v * b2;
	t17 += v * b3;
	t18 += v * b4;
	t19 += v * b5;
	t20 += v * b6;
	t21 += v * b7;
	t22 += v * b8;
	t23 += v * b9;
	t24 += v * b10;
	t25 += v * b11;
	t26 += v * b12;
	t27 += v * b13;
	t28 += v * b14;
	t29 += v * b15;
	v = a[15];
	t15 += v * b0;
	t16 += v * b1;
	t17 += v * b2;
	t18 += v * b3;
	t19 += v * b4;
	t20 += v * b5;
	t21 += v * b6;
	t22 += v * b7;
	t23 += v * b8;
	t24 += v * b9;
	t25 += v * b10;
	t26 += v * b11;
	t27 += v * b12;
	t28 += v * b13;
	t29 += v * b14;
	t30 += v * b15;

	t0  += 38 * t16;
	t1  += 38 * t17;
	t2  += 38 * t18;
	t3  += 38 * t19;
	t4  += 38 * t20;
	t5  += 38 * t21;
	t6  += 38 * t22;
	t7  += 38 * t23;
	t8  += 38 * t24;
	t9  += 38 * t25;
	t10 += 38 * t26;
	t11 += 38 * t27;
	t12 += 38 * t28;
	t13 += 38 * t29;
	t14 += 38 * t30;
	// t15 left as is

	// first car
	c = 1;
	v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
	v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
	v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
	v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
	v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
	v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
	v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
	v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
	v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
	v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
	v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
	v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
	v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
	v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
	v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
	v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
	t0 += c-1 + 37 * (c-1);

	// second car
	c = 1;
	v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
	v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
	v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
	v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
	v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
	v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
	v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
	v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
	v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
	v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
	v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
	v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
	v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
	v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
	v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
	v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
	t0 += c-1 + 37 * (c-1);

	o[ 0] = t0;
	o[ 1] = t1;
	o[ 2] = t2;
	o[ 3] = t3;
	o[ 4] = t4;
	o[ 5] = t5;
	o[ 6] = t6;
	o[ 7] = t7;
	o[ 8] = t8;
	o[ 9] = t9;
	o[10] = t10;
	o[11] = t11;
	o[12] = t12;
	o[13] = t13;
	o[14] = t14;
	o[15] = t15;
}

function S(o, a) {
	M(o, a, a);
}

function inv25519(o, i) {
	var c = gf();
	var a;
	for (a = 0; a < 16; a++) c[a] = i[a];
	for (a = 253; a >= 0; a--) {
		S(c, c);
		if(a !== 2 && a !== 4) M(c, c, i);
	}
	for (a = 0; a < 16; a++) o[a] = c[a];
}

function pow2523(o, i) {
	var c = gf();
	var a;
	for (a = 0; a < 16; a++) c[a] = i[a];
	for (a = 250; a >= 0; a--) {
			S(c, c);
			if(a !== 1) M(c, c, i);
	}
	for (a = 0; a < 16; a++) o[a] = c[a];
}

function crypto_hash(out, m, n, hasher) {
	const hashBuilder = hasher.create();
	hashBuilder.update(m.subarray(0, n));
	const hash = hashBuilder.digest();

	for (let i = 0; i < out.length; ++i)
		out[i] = hash[i];

	return 0;
}

function add(p, q) {
	var a = gf(), b = gf(), c = gf(),
			d = gf(), e = gf(), f = gf(),
			g = gf(), h = gf(), t = gf();

	Z(a, p[1], p[0]);
	Z(t, q[1], q[0]);
	M(a, a, t);
	A(b, p[0], p[1]);
	A(t, q[0], q[1]);
	M(b, b, t);
	M(c, p[3], q[3]);
	M(c, c, D2);
	M(d, p[2], q[2]);
	A(d, d, d);
	Z(e, b, a);
	Z(f, d, c);
	A(g, d, c);
	A(h, b, a);

	M(p[0], e, f);
	M(p[1], h, g);
	M(p[2], g, f);
	M(p[3], e, h);
}

function cswap(p, q, b) {
	var i;
	for (i = 0; i < 4; i++) {
		sel25519(p[i], q[i], b);
	}
}

function pack(r, p) {
	var tx = gf(), ty = gf(), zi = gf();
	inv25519(zi, p[2]);
	M(tx, p[0], zi);
	M(ty, p[1], zi);
	pack25519(r, ty);
	r[31] ^= par25519(tx) << 7;
}

function scalarmult(p, q, s) {
	var b, i;
	set25519(p[0], gf0);
	set25519(p[1], gf1);
	set25519(p[2], gf1);
	set25519(p[3], gf0);
	for (i = 255; i >= 0; --i) {
		b = (s[(i/8)|0] >> (i&7)) & 1;
		cswap(p, q, b);
		add(q, p);
		add(p, p);
		cswap(p, q, b);
	}
}

function scalarbase(p, s) {
	var q = [gf(), gf(), gf(), gf()];
	set25519(q[0], X);
	set25519(q[1], Y);
	set25519(q[2], gf1);
	M(q[3], X, Y);
	scalarmult(p, q, s);
}

function crypto_sign_keypair(pk, sk, hasher) {
	var d = new Uint8Array(64);
	var p = [gf(), gf(), gf(), gf()];
	var i;

	crypto_hash(d, sk, 32, hasher);
	d[0] &= 248;
	d[31] &= 127;
	d[31] |= 64;

	scalarbase(p, d);
	pack(pk, p);

	for (i = 0; i < 32; i++) sk[i+32] = pk[i];
	return 0;
}

var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

function modL(r, x) {
	var carry, i, j, k;
	for (i = 63; i >= 32; --i) {
		carry = 0;
		for (j = i - 32, k = i - 12; j < k; ++j) {
			x[j] += carry - 16 * x[i] * L[j - (i - 32)];
			carry = Math.floor((x[j] + 128) / 256);
			x[j] -= carry * 256;
		}
		x[j] += carry;
		x[i] = 0;
	}
	carry = 0;
	for (j = 0; j < 32; j++) {
		x[j] += carry - (x[31] >> 4) * L[j];
		carry = x[j] >> 8;
		x[j] &= 255;
	}
	for (j = 0; j < 32; j++) x[j] -= carry * L[j];
	for (i = 0; i < 32; i++) {
		x[i+1] += x[i] >> 8;
		r[i] = x[i] & 255;
	}
}

function reduce(r) {
	var x = new Float64Array(64), i;
	for (i = 0; i < 64; i++) x[i] = r[i];
	for (i = 0; i < 64; i++) r[i] = 0;
	modL(r, x);
}

// Note: difference from C - smlen returned, not passed as argument.
function crypto_sign(sm, m, n, sk, hasher) {
	var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
	var i, j, x = new Float64Array(64);
	var p = [gf(), gf(), gf(), gf()];

	crypto_hash(d, sk, 32, hasher);
	d[0] &= 248;
	d[31] &= 127;
	d[31] |= 64;

	var smlen = n + 64;
	for (i = 0; i < n; i++) sm[64 + i] = m[i];
	for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

	crypto_hash(r, sm.subarray(32), n+32, hasher);
	reduce(r);
	scalarbase(p, r);
	pack(sm, p);

	for (i = 32; i < 64; i++) sm[i] = sk[i];
	crypto_hash(h, sm, n + 64, hasher);
	reduce(h);

	for (i = 0; i < 64; i++) x[i] = 0;
	for (i = 0; i < 32; i++) x[i] = r[i];
	for (i = 0; i < 32; i++) {
		for (j = 0; j < 32; j++) {
			x[i+j] += h[i] * d[j];
		}
	}

	modL(sm.subarray(32), x);
	return smlen;
}

function unpackneg(r, p) {
	var t = gf(), chk = gf(), num = gf(),
			den = gf(), den2 = gf(), den4 = gf(),
			den6 = gf();

	set25519(r[2], gf1);
	unpack25519(r[1], p);
	S(num, r[1]);
	M(den, num, D);
	Z(num, num, r[2]);
	A(den, r[2], den);

	S(den2, den);
	S(den4, den2);
	M(den6, den4, den2);
	M(t, den6, num);
	M(t, t, den);

	pow2523(t, t);
	M(t, t, num);
	M(t, t, den);
	M(t, t, den);
	M(r[0], t, den);

	S(chk, r[0]);
	M(chk, chk, den);
	if (neq25519(chk, num)) M(r[0], r[0], I);

	S(chk, r[0]);
	M(chk, chk, den);
	if (neq25519(chk, num)) return -1;

	if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

	M(r[3], r[0], r[1]);
	return 0;
}

function crypto_sign_open(m, sm, n, pk, hasher) {
	var i;
	var t = new Uint8Array(32), h = new Uint8Array(64);
	var p = [gf(), gf(), gf(), gf()],
			q = [gf(), gf(), gf(), gf()];

	if (n < 64) return -1;

	if (unpackneg(q, pk)) return -1;

	for (i = 0; i < n; i++) m[i] = sm[i];
	for (i = 0; i < 32; i++) m[i+32] = pk[i];
	crypto_hash(h, m, n, hasher);
	reduce(h);
	scalarmult(p, q, h);

	scalarbase(q, sm.subarray(32));
	add(p, q);
	pack(t, p);

	n -= 64; // eslint-disable-line no-param-reassign
	if (crypto_verify_32(sm, 0, t, 0)) {
		for (i = 0; i < n; i++) m[i] = 0;
		return -1;
	}

	for (i = 0; i < n; i++) m[i] = sm[i + 64];
	return n;
}

var crypto_sign_BYTES = 64,
		crypto_sign_PUBLICKEYBYTES = 32,
		crypto_sign_SECRETKEYBYTES = 64,
		crypto_sign_SEEDBYTES = 32;

const nacl = {};
nacl.lowlevel = {
	crypto_hash,

	gf,
	L,
	Z,
	modL,
	scalarmult,
	neq25519,
	par25519,
	inv25519,
	pack,
	unpackneg
};

/* High-level API */

function checkArrayTypes(...params) {
	for (var i = 0; i < params.length; i++) {
		if (!(params[i] instanceof Uint8Array))
			throw new TypeError('unexpected type, use Uint8Array');
	}
}

nacl.sign = function(msg, secretKey, hasher) {
	checkArrayTypes(msg, secretKey);
	if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
		throw new Error('bad secret key size');
	var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
	crypto_sign(signedMsg, msg, msg.length, secretKey, hasher);
	return signedMsg;
};

nacl.sign.detached = function(msg, secretKey, hasher) {
	var signedMsg = nacl.sign(msg, secretKey, hasher);
	var sig = new Uint8Array(crypto_sign_BYTES);
	for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
	return sig;
};

nacl.sign.detached.verify = function(msg, sig, publicKey, hasher) {
	checkArrayTypes(msg, sig, publicKey);
	if (sig.length !== crypto_sign_BYTES)
		throw new Error('bad signature size');
	if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
		throw new Error('bad public key size');
	var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
	var m = new Uint8Array(crypto_sign_BYTES + msg.length);
	var i;
	for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
	for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
	return (crypto_sign_open(m, sm, sm.length, publicKey, hasher) >= 0);
};

nacl.sign.keyPair = {};
nacl.sign.keyPair.fromSeed = function(seed, hasher) {
	checkArrayTypes(seed);
	if (seed.length !== crypto_sign_SEEDBYTES)
		throw new Error('bad seed size');
	var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
	var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
	for (var i = 0; i < 32; i++) sk[i] = seed[i];
	crypto_sign_keypair(pk, sk, hasher);
	return {publicKey: pk, secretKey: sk};
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (nacl);


/***/ }),

/***/ "./node_modules/symbol-sdk/src/symbol/KeyPair.js":
/*!*******************************************************!*\
  !*** ./node_modules/symbol-sdk/src/symbol/KeyPair.js ***!
  \*******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeyPair: () => (/* binding */ KeyPair),
/* harmony export */   Verifier: () => (/* binding */ Verifier)
/* harmony export */ });
/* harmony import */ var _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CryptoTypes.js */ "./node_modules/symbol-sdk/src/CryptoTypes.js");
/* harmony import */ var _impl_ed25519_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../impl/ed25519.js */ "./node_modules/symbol-sdk/src/impl/ed25519.js");
/* harmony import */ var _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/arrayHelpers.js */ "./node_modules/symbol-sdk/src/utils/arrayHelpers.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_impl_ed25519_js__WEBPACK_IMPORTED_MODULE_1__]);
_impl_ed25519_js__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];




const HASH_MODE = 'Sha2_512';

/**
 * Represents an ED25519 private and public key.
 */
class KeyPair {
	/**
	 * Creates a key pair from a private key.
	 * @param {PrivateKey} privateKey Private key.
	 */
	constructor(privateKey) {
		/**
		 * @private
		 */
		this._privateKey = privateKey;

		/**
		 * @private
		 */
		this._keyPair = _impl_ed25519_js__WEBPACK_IMPORTED_MODULE_1__["default"].get().keyPairFromSeed(HASH_MODE, this._privateKey.bytes);
	}

	/**
	 * Gets the public key.
	 * @returns {PublicKey} Public key.
	 */
	get publicKey() {
		return new _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(this._keyPair.publicKey);
	}

	/**
	 * Gets the private key.
	 * @returns {PrivateKey} Private key.
	 */
	get privateKey() {
		return new _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_0__.PrivateKey(this._privateKey.bytes);
	}

	/**
	 * Signs a message with the private key.
	 * @param {Uint8Array} message Message to sign.
	 * @returns {Signature} Message signature.
	 */
	sign(message) {
		return new _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_0__.Signature(_impl_ed25519_js__WEBPACK_IMPORTED_MODULE_1__["default"].get().sign(HASH_MODE, message, this._keyPair));
	}
}

/**
 * Verifies signatures signed by a single key pair.
 */
class Verifier {
	/**
	 * Creates a verifier from a public key.
	 * @param {PublicKey} publicKey Public key.
	 */
	constructor(publicKey) {
		if (0 === (0,_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_2__.deepCompare)(new Uint8Array(_CryptoTypes_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey.SIZE), publicKey.bytes))
			throw new Error('public key cannot be zero');

		/**
		 * Public key used for signature verification.
		 * @type {PublicKey}
		 */
		this.publicKey = publicKey;
	}

	/**
	 * Verifies a message signature.
	 * @param {Uint8Array} message Message to verify.
	 * @param {Signature} signature Signature to verify.
	 * @returns {boolean} true if the message signature verifies.
	 */
	verify(message, signature) {
		return _impl_ed25519_js__WEBPACK_IMPORTED_MODULE_1__["default"].get().verify(HASH_MODE, message, signature.bytes, this.publicKey.bytes);
	}
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/symbol-sdk/src/symbol/MessageEncoder.js":
/*!**************************************************************!*\
  !*** ./node_modules/symbol-sdk/src/symbol/MessageEncoder.js ***!
  \**************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MessageEncoder)
/* harmony export */ });
/* harmony import */ var _KeyPair_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KeyPair.js */ "./node_modules/symbol-sdk/src/symbol/KeyPair.js");
/* harmony import */ var _SharedKey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SharedKey.js */ "./node_modules/symbol-sdk/src/symbol/SharedKey.js");
/* harmony import */ var _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CryptoTypes.js */ "./node_modules/symbol-sdk/src/CryptoTypes.js");
/* harmony import */ var _impl_CipherHelpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../impl/CipherHelpers.js */ "./node_modules/symbol-sdk/src/impl/CipherHelpers.js");
/* harmony import */ var _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/arrayHelpers.js */ "./node_modules/symbol-sdk/src/utils/arrayHelpers.js");
/* harmony import */ var _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/converter.js */ "./node_modules/symbol-sdk/src/utils/converter.js");
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_KeyPair_js__WEBPACK_IMPORTED_MODULE_0__, _SharedKey_js__WEBPACK_IMPORTED_MODULE_1__]);
([_KeyPair_js__WEBPACK_IMPORTED_MODULE_0__, _SharedKey_js__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);







const DELEGATION_MARKER = Uint8Array.from(Buffer.from('FE2A8061577301E2', 'hex'));

const filterExceptions = (statement, exceptions) => {
	try {
		const message = statement();
		return [true, message];
	} catch (exception) {
		if (!exceptions.some(exceptionMessage => exception.message.includes(exceptionMessage)))
			throw exception;
	}

	return [false, undefined];
};

/**
 * Encrypts and encodes messages between two parties.
 */
class MessageEncoder {
	/**
	 * Creates message encoder around key pair.
	 * @param {KeyPair} keyPair Key pair.
	 */
	constructor(keyPair) {
		/**
		 * @private
		 */
		this._keyPair = keyPair;
	}

	/**
	 * Public key used for message encoding.
	 * @returns {PublicKey} Public key used for message encoding.
	 */
	get publicKey() {
		return this._keyPair.publicKey;
	}

	/**
	 * Tries to decode encoded message.
	 * @param {PublicKey} recipientPublicKey Recipient's public key.
	 * @param {Uint8Array} encodedMessage Encoded message.
	 * @returns {TryDecodeResult} Tuple containing decoded status and message.
	 */
	tryDecode(recipientPublicKey, encodedMessage) {
		if (1 === encodedMessage[0]) {
			const [result, message] = filterExceptions(
				() => (0,_impl_CipherHelpers_js__WEBPACK_IMPORTED_MODULE_3__.decodeAesGcm)(_SharedKey_js__WEBPACK_IMPORTED_MODULE_1__.deriveSharedKey, this._keyPair, recipientPublicKey, encodedMessage.subarray(1)),
				['Unsupported state or unable to authenticate data']
			);
			if (result)
				return { isDecoded: true, message };
		}

		if (0xFE === encodedMessage[0] && 0 === (0,_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.deepCompare)(DELEGATION_MARKER, encodedMessage.slice(0, 8))) {
			const ephemeralPublicKeyStart = DELEGATION_MARKER.length;
			const ephemeralPublicKeyEnd = ephemeralPublicKeyStart + _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey.SIZE;
			const ephemeralPublicKey = new _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(encodedMessage.subarray(ephemeralPublicKeyStart, ephemeralPublicKeyEnd));

			const [result, message] = filterExceptions(
				() => (0,_impl_CipherHelpers_js__WEBPACK_IMPORTED_MODULE_3__.decodeAesGcm)(_SharedKey_js__WEBPACK_IMPORTED_MODULE_1__.deriveSharedKey, this._keyPair, ephemeralPublicKey, encodedMessage.subarray(ephemeralPublicKeyEnd)),
				[
					'Unsupported state or unable to authenticate data',
					'invalid point'
				]
			);
			if (result)
				return { isDecoded: true, message };
		}

		return { isDecoded: false, message: encodedMessage };
	}

	/**
	 * Encodes message to recipient using recommended format.
	 * @param {PublicKey} recipientPublicKey Recipient public key.
	 * @param {Uint8Array} message Message to encode.
	 * @returns {Uint8Array} Encrypted and encoded message.
	 */
	encode(recipientPublicKey, message) {
		const { tag, initializationVector, cipherText } = (0,_impl_CipherHelpers_js__WEBPACK_IMPORTED_MODULE_3__.encodeAesGcm)(_SharedKey_js__WEBPACK_IMPORTED_MODULE_1__.deriveSharedKey, this._keyPair, recipientPublicKey, message);

		return (0,_impl_CipherHelpers_js__WEBPACK_IMPORTED_MODULE_3__.concatArrays)(new Uint8Array([1]), tag, initializationVector, cipherText);
	}

	/**
	 * Encodes persistent harvesting delegation to node.
	 * @param {PublicKey} nodePublicKey Node public key.
	 * @param {KeyPair} remoteKeyPair Remote key pair.
	 * @param {KeyPair} vrfKeyPair Vrf key pair.
	 * @returns {Uint8Array} Encrypted and encoded harvesting delegation request.
	 */
	// eslint-disable-next-line class-methods-use-this
	encodePersistentHarvestingDelegation(nodePublicKey, remoteKeyPair, vrfKeyPair) {
		const ephemeralKeyPair = new _KeyPair_js__WEBPACK_IMPORTED_MODULE_0__.KeyPair(_CryptoTypes_js__WEBPACK_IMPORTED_MODULE_2__.PrivateKey.random());
		const message = (0,_impl_CipherHelpers_js__WEBPACK_IMPORTED_MODULE_3__.concatArrays)(remoteKeyPair.privateKey.bytes, vrfKeyPair.privateKey.bytes);
		const { tag, initializationVector, cipherText } = (0,_impl_CipherHelpers_js__WEBPACK_IMPORTED_MODULE_3__.encodeAesGcm)(_SharedKey_js__WEBPACK_IMPORTED_MODULE_1__.deriveSharedKey, ephemeralKeyPair, nodePublicKey, message);

		return (0,_impl_CipherHelpers_js__WEBPACK_IMPORTED_MODULE_3__.concatArrays)(DELEGATION_MARKER, ephemeralKeyPair.publicKey.bytes, tag, initializationVector, cipherText);
	}

	/**
	 * Tries to decode encoded message.
	 * @deprecated This function is only provided for compatability with the original Symbol wallets.
	 *             Please use `tryDecode` in any new code.
	 * @param {PublicKey} recipientPublicKey Recipient's public key.
	 * @param {Uint8Array} encodedMessage Encoded message
	 * @returns {TryDecodeResult} Tuple containing decoded status and message.
	 */
	tryDecodeDeprecated(recipientPublicKey, encodedMessage) {
		const encodedHexString = new TextDecoder().decode(encodedMessage.subarray(1));
		if (1 === encodedMessage[0] && (0,_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(encodedHexString)) {
			// wallet additionally hex encodes
			return this.tryDecode(recipientPublicKey, new Uint8Array([1, ...(0,_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.hexToUint8)(encodedHexString)]));
		}

		return this.tryDecode(recipientPublicKey, encodedMessage);
	}

	/**
	 * Encodes message to recipient using (deprecated) wallet format.
	 * @deprecated This function is only provided for compatability with the original Symbol wallets.
	 *             Please use `encode` in any new code.
	 * @param {PublicKey} recipientPublicKey Recipient public key.
	 * @param {Uint8Array} message Message to encode.
	 * @returns {Uint8Array} Encrypted and encoded message.
	 */
	encodeDeprecated(recipientPublicKey, message) {
		// wallet additionally hex encodes
		const encodedHexString = (0,_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex)(this.encode(recipientPublicKey, message).subarray(1));
		const encodedHexStringBytes = new TextEncoder().encode(encodedHexString);
		return new Uint8Array([1, ...encodedHexStringBytes]);
	}
}

// region type declarations

/**
 * Result of a try decode operation.
 * @class
 * @typedef {object} TryDecodeResult
 * @property {boolean} isDecoded \c true if message has been decoded and decrypted; \c false otherwise.
 * @property {Uint8Array} message Decoded message when `isDecoded` is \c true; encoded message otherwise.
 */

// endregion

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/symbol-sdk/src/symbol/Network.js":
/*!*******************************************************!*\
  !*** ./node_modules/symbol-sdk/src/symbol/Network.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Address: () => (/* binding */ Address),
/* harmony export */   Network: () => (/* binding */ Network),
/* harmony export */   NetworkTimestamp: () => (/* binding */ NetworkTimestamp)
/* harmony export */ });
/* harmony import */ var _models_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./models.js */ "./node_modules/symbol-sdk/src/symbol/models.js");
/* harmony import */ var _ByteArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ByteArray.js */ "./node_modules/symbol-sdk/src/ByteArray.js");
/* harmony import */ var _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CryptoTypes.js */ "./node_modules/symbol-sdk/src/CryptoTypes.js");
/* harmony import */ var _Network_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Network.js */ "./node_modules/symbol-sdk/src/Network.js");
/* harmony import */ var _NetworkTimestamp_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../NetworkTimestamp.js */ "./node_modules/symbol-sdk/src/NetworkTimestamp.js");
/* harmony import */ var _utils_base32_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/base32.js */ "./node_modules/symbol-sdk/src/utils/base32.js");
/* harmony import */ var _utils_converter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/converter.js */ "./node_modules/symbol-sdk/src/utils/converter.js");
/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/hashes/sha3 */ "./node_modules/@noble/hashes/esm/sha3.js");









/**
 * Represents a Symbol network timestamp with millisecond resolution.
 */
class NetworkTimestamp extends _NetworkTimestamp_js__WEBPACK_IMPORTED_MODULE_4__.NetworkTimestamp {
	/**
	 * Adds a specified number of milliseconds to this timestamp.
	 * @param {number|bigint} count Number of milliseconds to add.
	 * @returns {NetworkTimestamp} New timestamp that is the specified number of milliseconds past this timestamp.
	 */
	addMilliseconds(count) {
		return new NetworkTimestamp(this.timestamp + BigInt(count));
	}

	/**
	 * Adds a specified number of seconds to this timestamp.
	 * @override
	 * @param {number|bigint} count Number of seconds to add.
	 * @returns {NetworkTimestamp} New timestamp that is the specified number of seconds past this timestamp.
	 */
	addSeconds(count) {
		return this.addMilliseconds(1000n * BigInt(count));
	}
}

/**
 * Represents a Symbol address.
 */
class Address extends _ByteArray_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
	/**
	 * Byte size of raw address.
	 * @type {number}
	 */
	static SIZE = 24;

	/**
	 * Length of encoded address string.
	 * @type {number}
	 */
	static ENCODED_SIZE = 39;

	/**
	 * Byte array name (required because `constructor.name` is dropped during minification).
	 * @type {string}
	 */
	static NAME = 'Address';

	/**
	 * Creates a Symbol address.
	 * @param {Uint8Array|string|Address} addressInput Input string, byte array or address.
	 */
	constructor(addressInput) {
		const extractAddressBytes = () => {
			if ('string' === typeof addressInput)
				return _utils_base32_js__WEBPACK_IMPORTED_MODULE_5__["default"].decode(`${addressInput}A`).slice(0, -1);

			if (addressInput instanceof Address)
				return addressInput.bytes;

			return addressInput;
		};

		super(Address.SIZE, extractAddressBytes());
	}

	/**
	 * Attempts to convert this address into a namespace id.
	 * @returns {NamespaceId|undefined} Namespace id if this adresss is an alias, undefined otherwise.
	 */
	toNamespaceId() {
		if (!(this.bytes[0] & 0x01))
			return undefined;

		const idBytes = this.bytes.slice(1, 9); // slice because namespace id is unaligned
		const ids = new BigUint64Array(idBytes.buffer);
		return new _models_js__WEBPACK_IMPORTED_MODULE_0__.NamespaceId(ids[0]);
	}

	/**
	 * Returns string representation of this object.
	 * @returns {string} String representation of this object
	 */
	toString() {
		return _utils_base32_js__WEBPACK_IMPORTED_MODULE_5__["default"].encode(new Uint8Array([...this.bytes, 0])).slice(0, -1);
	}

	/**
	 * Creates an address from a decoded address hex string (typically from REST).
	 * @param {string} hexString Decoded address hex string.
	 * @returns {Address} Equivalent address.
	 */
	static fromDecodedAddressHexString(hexString) {
		const bytes = (0,_utils_converter_js__WEBPACK_IMPORTED_MODULE_6__.hexToUint8)(hexString);
		return new Address(bytes);
	}

	/**
	 * Creates an address from a namespace id.
	 * @param {NamespaceId} namespaceId Namespace id.
	 * @param {number} networkIdentifier Network identifier byte.
	 * @returns {Address} Address referencing namespace id.
	 */
	static fromNamespaceId(namespaceId, networkIdentifier) {
		const ids = new BigUint64Array(1);
		ids[0] = /** @type {bigint} */ (namespaceId.value);

		return new Address(new Uint8Array([
			networkIdentifier + 1,
			...new Uint8Array(ids.buffer),
			...new Uint8Array(Address.SIZE - 9)
		]));
	}
}

/**
 * Represents a Symbol network.
 */
class Network extends _Network_js__WEBPACK_IMPORTED_MODULE_3__.Network {
	/**
	 * Symbol main network.
	 * @type {Network}
	 */
	static MAINNET;

	/**
	 * Symbol test network.
	 * @type {Network}
	 */
	static TESTNET;

	/**
	 * Symbol well known networks.
	 * @type {Array<Network>}
	 */
	static NETWORKS;

	/**
	 * Creates a new network with the specified name, identifier byte and generation hash seed.
	 * @param {string} name Network name.
	 * @param {number} identifier Network identifier byte.
	 * @param {Date} epochTime Network epoch time.
	 * @param {Hash256} generationHashSeed Network generation hash seed.
	 */
	constructor(name, identifier, epochTime, generationHashSeed) {
		super(
			name,
			identifier,
			new _NetworkTimestamp_js__WEBPACK_IMPORTED_MODULE_4__.NetworkTimestampDatetimeConverter(epochTime, 'milliseconds'),
			() => _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_7__.sha3_256.create(),
			(addressWithoutChecksum, checksum) => new Address(new Uint8Array([...addressWithoutChecksum, ...checksum.subarray(0, 3)])),
			Address,
			NetworkTimestamp
		);

		/**
		 * Network generation hash seed.
		 * @type {Hash256}
		 */
		this.generationHashSeed = generationHashSeed;
	}
}

Network.MAINNET = new Network(
	'mainnet',
	0x68,
	new Date(Date.UTC(2021, 2, 16, 0, 6, 25)),
	new _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_2__.Hash256('57F7DA205008026C776CB6AED843393F04CD458E0AA2D9F1D5F31A402072B2D6')
);
Network.TESTNET = new Network(
	'testnet',
	0x98,
	new Date(Date.UTC(2022, 9, 31, 21, 7, 47)),
	new _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_2__.Hash256('49D6E1CE276A85B70EAFE52349AACCA389302E7A9754BCF1221E79494FC665A4')
);
Network.NETWORKS = [Network.MAINNET, Network.TESTNET];


/***/ }),

/***/ "./node_modules/symbol-sdk/src/symbol/SharedKey.js":
/*!*********************************************************!*\
  !*** ./node_modules/symbol-sdk/src/symbol/SharedKey.js ***!
  \*********************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deriveSharedKey: () => (/* binding */ deriveSharedKey)
/* harmony export */ });
/* harmony import */ var _KeyPair_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KeyPair.js */ "./node_modules/symbol-sdk/src/symbol/KeyPair.js");
/* harmony import */ var _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CryptoTypes.js */ "./node_modules/symbol-sdk/src/CryptoTypes.js");
/* harmony import */ var _SharedKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../SharedKey.js */ "./node_modules/symbol-sdk/src/SharedKey.js");
/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/sha512 */ "./node_modules/@noble/hashes/esm/sha512.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_KeyPair_js__WEBPACK_IMPORTED_MODULE_0__]);
_KeyPair_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
/* eslint-disable no-unused-vars */


/* eslint-enable no-unused-vars */



const deriveSharedKeyImpl = (0,_SharedKey_js__WEBPACK_IMPORTED_MODULE_2__.deriveSharedKeyFactory)('catapult', _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_3__.sha512);

/**
 * Derives shared key from key pair and other party's public key.
 * @param {KeyPair} keyPair Key pair.
 * @param {PublicKey} otherPublicKey Other party's public key.
 * @returns {SharedKey256} Shared encryption key.
 */
const deriveSharedKey = (keyPair, otherPublicKey) => deriveSharedKeyImpl(keyPair.privateKey.bytes, otherPublicKey);

 // eslint-disable-line import/prefer-default-export

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/symbol-sdk/src/symbol/TransactionFactory.js":
/*!******************************************************************!*\
  !*** ./node_modules/symbol-sdk/src/symbol/TransactionFactory.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TransactionFactory)
/* harmony export */ });
/* harmony import */ var _Network_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Network.js */ "./node_modules/symbol-sdk/src/symbol/Network.js");
/* harmony import */ var _idGenerator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./idGenerator.js */ "./node_modules/symbol-sdk/src/symbol/idGenerator.js");
/* harmony import */ var _models_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./models.js */ "./node_modules/symbol-sdk/src/symbol/models.js");
/* harmony import */ var _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CryptoTypes.js */ "./node_modules/symbol-sdk/src/CryptoTypes.js");
/* harmony import */ var _RuleBasedTransactionFactory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../RuleBasedTransactionFactory.js */ "./node_modules/symbol-sdk/src/RuleBasedTransactionFactory.js");
/* harmony import */ var _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/converter.js */ "./node_modules/symbol-sdk/src/utils/converter.js");







/**
 * Factory for creating Symbol transactions.
 */
class TransactionFactory {
	/**
	 * Creates a factory for the specified network.
	 * @param {Network} network Symbol network.
	 * @param {Map<string, Function>|undefined} typeRuleOverrides Type rule overrides.
	 */
	constructor(network, typeRuleOverrides = undefined) {
		/**
		 * @private
		 */
		this._factory = TransactionFactory._buildRules(typeRuleOverrides); // eslint-disable-line no-underscore-dangle

		/**
		 * @private
		 */
		this._network = network;
	}

	/**
	 * Gets class type.
	 * @returns {typeof TransactionFactory} Class type.
	 */
	get static() { // eslint-disable-line class-methods-use-this
		return TransactionFactory;
	}

	/**
	 * Gets rule names with registered hints.
	 * @returns {Array<string>} Rule names with registered hints.
	 */
	get ruleNames() {
		return Array.from(this._factory.rules.keys());
	}

	/**
	 * Looks up the friendly name for the specified transaction.
	 * @param {sc.TransactionType} transactionType Transaction type.
	 * @param {number} transactionVersion Transaction version.
	 * @returns {string} Transaction friendly name.
	 */
	static lookupTransactionName(transactionType, transactionVersion) {
		return `${_models_js__WEBPACK_IMPORTED_MODULE_2__.TransactionType.valueToKey(transactionType.value).toLowerCase()}_transaction_v${transactionVersion}`;
	}

	/**
	 * Creates a transaction from a transaction descriptor.
	 * @template TTransaction
	 * @param {object} transactionDescriptor Transaction descriptor.
	 * @param {boolean} autosort When set (default), descriptor arrays requiring ordering will be automatically sorted.
	 *                           When unset, descriptor arrays will be presumed to be already sorted.
	 * @param {{createByName: Function}} FactoryClass Factory class used to create the transaction.
	 * @returns {TTransaction} Newly created transaction.
	 * @private
	 */
	_createAndExtend(transactionDescriptor, autosort, FactoryClass) {
		const transaction = this._factory.createFromFactory(FactoryClass.createByName, {
			...transactionDescriptor,
			network: this._network.identifier
		});
		if (autosort)
			transaction.sort();

		// autogenerate artifact ids
		if (_models_js__WEBPACK_IMPORTED_MODULE_2__.TransactionType.NAMESPACE_REGISTRATION === transaction.type) {
			const parentId = _models_js__WEBPACK_IMPORTED_MODULE_2__.NamespaceRegistrationType.CHILD === transaction.registrationType ? transaction.parentId.value : 0n;
			const rawNamespaceId = (0,_idGenerator_js__WEBPACK_IMPORTED_MODULE_1__.generateNamespaceId)(new TextDecoder().decode(transaction.name), parentId);
			transaction.id = new _models_js__WEBPACK_IMPORTED_MODULE_2__.NamespaceId(rawNamespaceId);
		} else if (_models_js__WEBPACK_IMPORTED_MODULE_2__.TransactionType.MOSAIC_DEFINITION === transaction.type) {
			const address = this._network.publicKeyToAddress(new _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_3__.PublicKey(transaction.signerPublicKey.bytes));
			transaction.id = new _models_js__WEBPACK_IMPORTED_MODULE_2__.MosaicId((0,_idGenerator_js__WEBPACK_IMPORTED_MODULE_1__.generateMosaicId)(address, transaction.nonce.value));
		}

		return transaction;
	}

	/**
	 * Creates a transaction from a transaction descriptor.
	 * @param {object} transactionDescriptor Transaction descriptor.
	 * @param {boolean} autosort When set (default), descriptor arrays requiring ordering will be automatically sorted.
	 *                           When unset, descriptor arrays will be presumed to be already sorted.
	 * @returns {sc.Transaction} Newly created transaction.
	 */
	create(transactionDescriptor, autosort = true) {
		return this._createAndExtend(transactionDescriptor, autosort, _models_js__WEBPACK_IMPORTED_MODULE_2__.TransactionFactory);
	}

	/**
	 * Creates an embedded transaction from a transaction descriptor.
	 * @param {object} transactionDescriptor Transaction descriptor.
	 * @param {boolean} autosort When set (default), descriptor arrays requiring ordering will be automatically sorted.
	 *                           When unset, descriptor arrays will be presumed to be already sorted.
	 * @returns {sc.EmbeddedTransaction} Newly created transaction.
	 */
	createEmbedded(transactionDescriptor, autosort = true) {
		return this._createAndExtend(transactionDescriptor, autosort, _models_js__WEBPACK_IMPORTED_MODULE_2__.EmbeddedTransactionFactory);
	}

	/**
	 * Deserializes a transaction from a binary payload.
	 * @param {Uint8Array} payload Binary payload.
	 * @returns {sc.Transaction} Deserialized transaction.
	 */
	static deserialize(payload) {
		return _models_js__WEBPACK_IMPORTED_MODULE_2__.TransactionFactory.deserialize(payload);
	}

	/**
	 * Deserializes an embedded transaction from a binary payload.
	 * @param {Uint8Array} payload Binary payload.
	 * @returns {sc.EmbeddedTransaction} Deserialized embedded transaction.
	 */
	static deserializeEmbedded(payload) {
		return _models_js__WEBPACK_IMPORTED_MODULE_2__.EmbeddedTransactionFactory.deserialize(payload);
	}

	/**
	 * Attaches a signature to a transaction.
	 * @param {sc.Transaction} transaction Transaction object.
	 * @param {Signature} signature Signature to attach.
	 * @returns {string} JSON transaction payload.
	 */
	static attachSignature(transaction, signature) {
		transaction.signature = new _models_js__WEBPACK_IMPORTED_MODULE_2__.Signature(signature.bytes);

		const transactionBuffer = transaction.serialize();
		const hexPayload = (0,_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex)(transactionBuffer);
		const jsonPayload = `{"payload": "${hexPayload}"}`;
		return jsonPayload;
	}

	/**
	 * Tries to coerce an sdk type to a model type.
	 * @param {object} value Value to convert.
	 * @returns {sc.Address|undefined} Converted value or undefined.
	 * @private
	 */
	static _symbolTypeConverter(value) {
		if (value instanceof _Network_js__WEBPACK_IMPORTED_MODULE_0__.Address)
			return new _models_js__WEBPACK_IMPORTED_MODULE_2__.UnresolvedAddress(value.bytes);

		return undefined;
	}

	/**
	 * Builds a rule based transaction factory.
	 * @param {Map<string, Function>|undefined} typeRuleOverrides Type rule overrides.
	 * @returns {RuleBasedTransactionFactory} Rule based transaction factory.
	 * @private
	 */
	static _buildRules(typeRuleOverrides) {
		const factory = new _RuleBasedTransactionFactory_js__WEBPACK_IMPORTED_MODULE_4__["default"](_models_js__WEBPACK_IMPORTED_MODULE_2__, this._symbolTypeConverter, typeRuleOverrides);
		factory.autodetect();

		['MosaicFlags', 'AccountRestrictionFlags'].forEach(name => { factory.addFlagsParser(name); });

		[
			'AliasAction', 'LinkAction', 'LockHashAlgorithm',
			'MosaicRestrictionType', 'MosaicSupplyChangeAction',
			'NamespaceRegistrationType', 'NetworkType', 'TransactionType'
		].forEach(name => { factory.addEnumParser(name); });

		factory.addStructParser('UnresolvedMosaic');

		const sdkTypeMapping = {
			UnresolvedAddress: _Network_js__WEBPACK_IMPORTED_MODULE_0__.Address,
			Address: _Network_js__WEBPACK_IMPORTED_MODULE_0__.Address,
			Hash256: _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_3__.Hash256,
			PublicKey: _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_3__.PublicKey,
			VotingPublicKey: _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_3__.PublicKey
		};
		Object.keys(sdkTypeMapping).forEach(name => { factory.addPodParser(name, sdkTypeMapping[name]); });

		['UnresolvedMosaicId', 'TransactionType', 'UnresolvedAddress', 'struct:UnresolvedMosaic'].forEach(name => {
			factory.addArrayParser(name);
		});

		return factory;
	}
}


/***/ }),

/***/ "./node_modules/symbol-sdk/src/symbol/VotingKeysGenerator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/symbol-sdk/src/symbol/VotingKeysGenerator.js ***!
  \*******************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VotingKeysGenerator)
/* harmony export */ });
/* harmony import */ var _KeyPair_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KeyPair.js */ "./node_modules/symbol-sdk/src/symbol/KeyPair.js");
/* harmony import */ var _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CryptoTypes.js */ "./node_modules/symbol-sdk/src/CryptoTypes.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_KeyPair_js__WEBPACK_IMPORTED_MODULE_0__]);
_KeyPair_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];



const setBuffer = (destination, offset, source) => {
	source.forEach((byte, i) => { destination.setUint8(offset + i, source[i]); });
};

/**
 * Generates symbol voting keys.
 */
class VotingKeysGenerator {
	/**
	 * Creates a generator around a voting root key pair.
	 * @param {KeyPair} rootKeyPair Voting root key pair.
	 * @param {Function} privateKeyGenerator Private key generator.
	 */
	constructor(rootKeyPair, privateKeyGenerator = _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_1__.PrivateKey.random) {
		/**
		 * @private
		 */
		this._rootKeyPair = rootKeyPair;

		/**
		 * @private
		 */
		this._privateKeyGenerator = privateKeyGenerator;
	}

	/**
	 * Generates voting keys for specified epochs.
	 * @param {bigint} startEpoch Start epoch.
	 * @param {bigint} endEpoch End epoch.
	 * @returns {Uint8Array} Serialized voting keys.
	 */
	generate(startEpoch, endEpoch) {
		const HEADER_SIZE = 80;
		const EPOCH_ENTRY_SIZE = 96;

		const numEpochs = Number(endEpoch - startEpoch + 1n);
		const buffer = new ArrayBuffer(HEADER_SIZE + (EPOCH_ENTRY_SIZE * numEpochs));

		const view = new DataView(buffer);
		view.setBigUint64(0, startEpoch, true); // start key identifier
		view.setBigUint64(8, endEpoch, true); // end key identifier
		view.setBigUint64(16, 0xFFFFFFFFFFFFFFFFn, true); // reserved - last (used) key identifier
		view.setBigUint64(24, 0xFFFFFFFFFFFFFFFFn, true); // reserved - last wiped key identifier

		setBuffer(view, 32, this._rootKeyPair.publicKey.bytes); // root voting public key
		view.setBigUint64(64, startEpoch, true); // level 1/1 start key identifier
		view.setBigUint64(72, endEpoch, true); // level 1/1 end key identifier

		for (let i = 0; i < numEpochs; ++i) {
			const identifier = endEpoch - BigInt(i);
			const childPrivateKey = this._privateKeyGenerator();
			const childKeyPair = new _KeyPair_js__WEBPACK_IMPORTED_MODULE_0__.KeyPair(childPrivateKey);

			const parentSignedPayloadBuffer = new ArrayBuffer(40);
			const parentSignedPayloadView = new DataView(parentSignedPayloadBuffer);
			setBuffer(parentSignedPayloadView, 0, childKeyPair.publicKey.bytes);
			parentSignedPayloadView.setBigUint64(32, identifier, true);
			const signature = this._rootKeyPair.sign(new Uint8Array(parentSignedPayloadBuffer));

			const startOffset = HEADER_SIZE + (EPOCH_ENTRY_SIZE * i);
			setBuffer(view, startOffset, childKeyPair.privateKey.bytes); // child voting private key used to sign votes for an epoch
			setBuffer(view, startOffset + _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_1__.PrivateKey.SIZE, signature.bytes); // signature proving derivation of child key pair from root
		}

		return new Uint8Array(buffer);
	}
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/symbol-sdk/src/symbol/idGenerator.js":
/*!***********************************************************!*\
  !*** ./node_modules/symbol-sdk/src/symbol/idGenerator.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateMosaicAliasId: () => (/* binding */ generateMosaicAliasId),
/* harmony export */   generateMosaicId: () => (/* binding */ generateMosaicId),
/* harmony export */   generateNamespaceId: () => (/* binding */ generateNamespaceId),
/* harmony export */   generateNamespacePath: () => (/* binding */ generateNamespacePath),
/* harmony export */   isValidNamespaceName: () => (/* binding */ isValidNamespaceName)
/* harmony export */ });
/* harmony import */ var _Network_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Network.js */ "./node_modules/symbol-sdk/src/symbol/Network.js");
/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha3 */ "./node_modules/@noble/hashes/esm/sha3.js");
/* eslint-disable no-unused-vars */

/* eslint-enable no-unused-vars */


const NAMESPACE_FLAG = 1n << 63n;

const uint32ToBytes = value => new Uint8Array([
	value & 0xFF,
	(value >> 8) & 0xFF,
	(value >> 16) & 0xFF,
	(value >> 24) & 0xFF
]);

const digestToBigInt = digest => {
	let result = 0n;
	for (let i = 0; 8 > i; ++i)
		result += (BigInt(digest[i]) << BigInt(8 * i));

	return result;
};

/**
 * Generates a mosaic id from an owner address and a nonce.
 * @param {Address} ownerAddress Owner address.
 * @param {number} nonce Nonce.
 * @returns {bigint} Computed mosaic id.
 */
const generateMosaicId = (ownerAddress, nonce) => {
	const hasher = _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_1__.sha3_256.create();
	hasher.update(uint32ToBytes(nonce));
	hasher.update(ownerAddress.bytes);
	const digest = hasher.digest();

	let result = digestToBigInt(digest);
	if (result & NAMESPACE_FLAG)
		result -= NAMESPACE_FLAG;

	return result;
};

/**
 * Generates a namespace id from a name and an optional parent namespace id.
 * @param {string} name Namespace name.
 * @param {bigint} parentNamespaceId Parent namespace id.
 * @returns {bigint} Computed namespace id.
 */
const generateNamespaceId = (name, parentNamespaceId = 0n) => {
	const hasher = _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_1__.sha3_256.create();
	hasher.update(uint32ToBytes(Number(parentNamespaceId & 0xFFFFFFFFn)));
	hasher.update(uint32ToBytes(Number((parentNamespaceId >> 32n) & 0xFFFFFFFFn)));
	hasher.update(name);
	const digest = new Uint8Array(hasher.digest());

	const result = digestToBigInt(digest);
	return result | NAMESPACE_FLAG;
};

/**
 * Returns true if a name is a valid namespace name.
 * @param {string} name Namespace name to check.
 * @returns {boolean} true if the specified name is valid.
 */
const isValidNamespaceName = name => {
	const isAlphanum = character => ('a' <= character && 'z' >= character) || ('0' <= character && '9' >= character);
	if (!name || !isAlphanum(name[0]))
		return false;

	for (let i = 0; i < name.length; ++i) {
		const ch = name[i];
		if (!isAlphanum(ch) && '_' !== ch && '-' !== ch)
			return false;
	}

	return true;
};

/**
 * Parses a fully qualified namespace name into a path.
 * @param {string} fullyQualifiedName Fully qualified namespace name.
 * @returns {Array<bigint>} Computed namespace path.
 */
const generateNamespacePath = fullyQualifiedName => {
	const path = [];
	let parentNamespaceId = 0n;
	fullyQualifiedName.split('.').forEach(name => {
		if (!isValidNamespaceName(name))
			throw Error(`fully qualified name is invalid due to invalid part name (${fullyQualifiedName})`);

		path.push(generateNamespaceId(name, parentNamespaceId));
		parentNamespaceId = path[path.length - 1];
	});

	return path;
};

/**
 * Generates a mosaic id from a fully qualified mosaic alias name.
 * @param {string} fullyQualifiedName Fully qualified mosaic name.
 * @returns {bigint} Computed mosaic id.
 */
const generateMosaicAliasId = fullyQualifiedName => {
	const path = generateNamespacePath(fullyQualifiedName);
	return path[path.length - 1];
};




/***/ }),

/***/ "./node_modules/symbol-sdk/src/symbol/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/symbol-sdk/src/symbol/index.js ***!
  \*****************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Address: () => (/* reexport safe */ _Network_js__WEBPACK_IMPORTED_MODULE_2__.Address),
/* harmony export */   KeyPair: () => (/* reexport safe */ _KeyPair_js__WEBPACK_IMPORTED_MODULE_0__.KeyPair),
/* harmony export */   MessageEncoder: () => (/* reexport safe */ _MessageEncoder_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   Network: () => (/* reexport safe */ _Network_js__WEBPACK_IMPORTED_MODULE_2__.Network),
/* harmony export */   NetworkTimestamp: () => (/* reexport safe */ _Network_js__WEBPACK_IMPORTED_MODULE_2__.NetworkTimestamp),
/* harmony export */   SymbolAccount: () => (/* reexport safe */ _facade_SymbolFacade_js__WEBPACK_IMPORTED_MODULE_10__.SymbolAccount),
/* harmony export */   SymbolFacade: () => (/* reexport safe */ _facade_SymbolFacade_js__WEBPACK_IMPORTED_MODULE_10__.SymbolFacade),
/* harmony export */   SymbolPublicAccount: () => (/* reexport safe */ _facade_SymbolFacade_js__WEBPACK_IMPORTED_MODULE_10__.SymbolPublicAccount),
/* harmony export */   SymbolTransactionFactory: () => (/* reexport safe */ _TransactionFactory_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   Verifier: () => (/* reexport safe */ _KeyPair_js__WEBPACK_IMPORTED_MODULE_0__.Verifier),
/* harmony export */   VotingKeysGenerator: () => (/* reexport safe */ _VotingKeysGenerator_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   descriptors: () => (/* reexport module object */ _models_ts_js__WEBPACK_IMPORTED_MODULE_9__),
/* harmony export */   deserializePatriciaTreeNodes: () => (/* reexport safe */ _merkle_js__WEBPACK_IMPORTED_MODULE_6__.deserializePatriciaTreeNodes),
/* harmony export */   generateMosaicAliasId: () => (/* reexport safe */ _idGenerator_js__WEBPACK_IMPORTED_MODULE_5__.generateMosaicAliasId),
/* harmony export */   generateMosaicId: () => (/* reexport safe */ _idGenerator_js__WEBPACK_IMPORTED_MODULE_5__.generateMosaicId),
/* harmony export */   generateNamespaceId: () => (/* reexport safe */ _idGenerator_js__WEBPACK_IMPORTED_MODULE_5__.generateNamespaceId),
/* harmony export */   generateNamespacePath: () => (/* reexport safe */ _idGenerator_js__WEBPACK_IMPORTED_MODULE_5__.generateNamespacePath),
/* harmony export */   isValidNamespaceName: () => (/* reexport safe */ _idGenerator_js__WEBPACK_IMPORTED_MODULE_5__.isValidNamespaceName),
/* harmony export */   metadataGenerateKey: () => (/* reexport safe */ _metadata_js__WEBPACK_IMPORTED_MODULE_7__.metadataGenerateKey),
/* harmony export */   metadataUpdateValue: () => (/* reexport safe */ _metadata_js__WEBPACK_IMPORTED_MODULE_7__.metadataUpdateValue),
/* harmony export */   models: () => (/* reexport module object */ _models_js__WEBPACK_IMPORTED_MODULE_8__),
/* harmony export */   proveMerkle: () => (/* reexport safe */ _merkle_js__WEBPACK_IMPORTED_MODULE_6__.proveMerkle),
/* harmony export */   provePatriciaMerkle: () => (/* reexport safe */ _merkle_js__WEBPACK_IMPORTED_MODULE_6__.provePatriciaMerkle)
/* harmony export */ });
/* harmony import */ var _KeyPair_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KeyPair.js */ "./node_modules/symbol-sdk/src/symbol/KeyPair.js");
/* harmony import */ var _MessageEncoder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MessageEncoder.js */ "./node_modules/symbol-sdk/src/symbol/MessageEncoder.js");
/* harmony import */ var _Network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Network.js */ "./node_modules/symbol-sdk/src/symbol/Network.js");
/* harmony import */ var _TransactionFactory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TransactionFactory.js */ "./node_modules/symbol-sdk/src/symbol/TransactionFactory.js");
/* harmony import */ var _VotingKeysGenerator_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VotingKeysGenerator.js */ "./node_modules/symbol-sdk/src/symbol/VotingKeysGenerator.js");
/* harmony import */ var _idGenerator_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./idGenerator.js */ "./node_modules/symbol-sdk/src/symbol/idGenerator.js");
/* harmony import */ var _merkle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./merkle.js */ "./node_modules/symbol-sdk/src/symbol/merkle.js");
/* harmony import */ var _metadata_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./metadata.js */ "./node_modules/symbol-sdk/src/symbol/metadata.js");
/* harmony import */ var _models_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./models.js */ "./node_modules/symbol-sdk/src/symbol/models.js");
/* harmony import */ var _models_ts_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./models_ts.js */ "./node_modules/symbol-sdk/src/symbol/models_ts.js");
/* harmony import */ var _facade_SymbolFacade_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../facade/SymbolFacade.js */ "./node_modules/symbol-sdk/src/facade/SymbolFacade.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_KeyPair_js__WEBPACK_IMPORTED_MODULE_0__, _MessageEncoder_js__WEBPACK_IMPORTED_MODULE_1__, _VotingKeysGenerator_js__WEBPACK_IMPORTED_MODULE_4__, _facade_SymbolFacade_js__WEBPACK_IMPORTED_MODULE_10__]);
([_KeyPair_js__WEBPACK_IMPORTED_MODULE_0__, _MessageEncoder_js__WEBPACK_IMPORTED_MODULE_1__, _VotingKeysGenerator_js__WEBPACK_IMPORTED_MODULE_4__, _facade_SymbolFacade_js__WEBPACK_IMPORTED_MODULE_10__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);














__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./node_modules/symbol-sdk/src/symbol/merkle.js":
/*!******************************************************!*\
  !*** ./node_modules/symbol-sdk/src/symbol/merkle.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BranchNode: () => (/* binding */ BranchNode),
/* harmony export */   LeafNode: () => (/* binding */ LeafNode),
/* harmony export */   MerkleHashBuilder: () => (/* binding */ MerkleHashBuilder),
/* harmony export */   PatriciaMerkleProofResult: () => (/* binding */ PatriciaMerkleProofResult),
/* harmony export */   TreeNode: () => (/* binding */ TreeNode),
/* harmony export */   deserializePatriciaTreeNodes: () => (/* binding */ deserializePatriciaTreeNodes),
/* harmony export */   proveMerkle: () => (/* binding */ proveMerkle),
/* harmony export */   provePatriciaMerkle: () => (/* binding */ provePatriciaMerkle)
/* harmony export */ });
/* harmony import */ var _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CryptoTypes.js */ "./node_modules/symbol-sdk/src/CryptoTypes.js");
/* harmony import */ var _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/arrayHelpers.js */ "./node_modules/symbol-sdk/src/utils/arrayHelpers.js");
/* harmony import */ var _utils_converter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/converter.js */ "./node_modules/symbol-sdk/src/utils/converter.js");
/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/sha3 */ "./node_modules/@noble/hashes/esm/sha3.js");





// region MerkleHashBuilder

/**
 * Builder for creating a merkle hash.
 */
class MerkleHashBuilder {
	/**
	 * Creates a merkle hash builder.
	 */
	constructor() {
		/**
		 * @private
		 */
		this._hashes = [];
	}

	/**
	 * Adds a hash to the merkle hash.
	 * @param {Hash256} componentHash Hash to add.
	 */
	update(componentHash) {
		this._hashes.push(componentHash.bytes);
	}

	/**
	 * Calculates the merkle hash.
	 * @returns {Hash256} Merkle hash.
	 */
	final() {
		if (0 === this._hashes.length)
			return _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_0__.Hash256.zero();

		let numRemainingHashes = this._hashes.length;
		while (1 < numRemainingHashes) {
			let i = 0;
			while (i < numRemainingHashes) {
				const hasher = _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_3__.sha3_256.create();
				hasher.update(this._hashes[i]);

				if (i + 1 < numRemainingHashes) {
					hasher.update(this._hashes[i + 1]);
				} else {
					// if there is an odd number of hashes, duplicate the last one
					hasher.update(this._hashes[i]);
					numRemainingHashes += 1;
				}

				this._hashes[Math.floor(i / 2)] = hasher.digest();
				i += 2;
			}

			numRemainingHashes = Math.floor(numRemainingHashes / 2);
		}

		return new _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_0__.Hash256(this._hashes[0]);
	}
}

// endregion

// region proveMerkle

/**
 * Proves a merkle hash.
 * @param {Hash256} leafHash Leaf hash to prove.
 * @param {Array<MerklePart>} merklePath Merkle *hash chain* path from leaf to root.
 * @param {Hash256} rootHash Root hash of the merkle tree.
 * @returns {boolean} \c true if leaf hash is connected to root hash; false otherwise.
 */
const proveMerkle = (leafHash, merklePath, rootHash) => {
	const computedRootHash = merklePath.reduce((workingHash, merklePart) => {
		const hasher = _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_3__.sha3_256.create();
		if (merklePart.isLeft) {
			hasher.update(merklePart.hash.bytes);
			hasher.update(workingHash.bytes);
		} else {
			hasher.update(workingHash.bytes);
			hasher.update(merklePart.hash.bytes);
		}

		return new _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_0__.Hash256(hasher.digest());
	}, leafHash);

	return 0 === (0,_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_1__.deepCompare)(rootHash.bytes, computedRootHash.bytes);
};

// endregion

// region LeafNode / BranchNode

const getNibbleAt = (path, index) => {
	const byte = path.path[Math.floor(index / 2)];
	return 1 === index % 2 ? byte & 0xF : byte >>> 4;
};

const encodePath = (path, isLeaf) => {
	let i = 0;
	const buffer = new Uint8Array(1 + Math.floor(path.size / 2));
	buffer[0] = isLeaf ? 0x20 : 0;
	if (1 === path.size % 2) {
		buffer[0] |= 0x10 | getNibbleAt(path, 0);
		++i;
	}

	while (i < path.size) {
		buffer[1 + Math.floor(i / 2)] = (getNibbleAt(path, i) << 4) + (getNibbleAt(path, i + 1));
		i += 2;
	}

	return buffer;
};

/**
 *  Node in a compact Patricia tree.
 */
class TreeNode {
	/**
	 * Creates a tree node.
	 * @param {PatriciaTreePath} path Node path.
	 */
	constructor(path) {
		/**
		 * Node path.
		 * @type {PatriciaTreePath}
		 */
		this.path = path;
	}

	/**
	 * Gets hex representation of path.
	 * @returns {string} Hex representation of path.
	 */
	get hexPath() {
		return (0,_utils_converter_js__WEBPACK_IMPORTED_MODULE_2__.uint8ToHex)(this.path.path).substring(0, this.path.size);
	}

	/**
	 * Calculates node hash.
	 * @returns {Hash256} Hash of the node.
	 */
	calculateHash() { // eslint-disable-line class-methods-use-this
		return _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_0__.Hash256.zero();
	}
}

/**
 *  Leaf node in a compact Patricia tree.
 */
class LeafNode extends TreeNode {
	/**
	 * Creates a leaf node.
	 * @param {PatriciaTreePath} path Leaf path.
	 * @param {Hash256} value Leaf value.
	 */
	constructor(path, value) {
		super(path);

		/**
		 * Leaf value.
		 * @type {Hash256}
		 */
		this.value = value;
	}

	/**
	 * Calculates node hash.
	 * @override
	 * @returns {Hash256} Hash of the node.
	 */
	calculateHash() {
		const hasher = _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_3__.sha3_256.create();
		hasher.update(encodePath(this.path, true));
		hasher.update(this.value.bytes);
		return new _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_0__.Hash256(hasher.digest());
	}
}

/**
 *  Branch node in a compact Patricia tree.
 */
class BranchNode extends TreeNode {
	/**
	 * Creates a branch node.
	 * @param {PatriciaTreePath} path Branch path.
	 * @param {Array<Hash256>} links Branch links.
	 */
	constructor(path, links) {
		super(path);

		/**
		 * Branch links.
		 * @type {Array<Hash256>}
		 */
		this.links = links;
	}

	/**
	 * Calculates node hash.
	 * @override
	 * @returns {Hash256} Hash of the node.
	 */
	calculateHash() {
		const hasher = _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_3__.sha3_256.create();
		hasher.update(encodePath(this.path, false));
		this.links.forEach(link => {
			hasher.update((undefined === link ? _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_0__.Hash256.zero() : link).bytes);
		});

		return new _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_0__.Hash256(hasher.digest());
	}
}

// endregion

// region deserializePatriciaTreeNodes

class BufferReader {
	constructor(buffer) {
		this.view = new DataView(buffer);
		this.offset = 0;
	}

	get eof() {
		return this.offset === this.view.byteLength;
	}

	readByte() {
		const result = this.view.getUint8(this.offset);
		++this.offset;
		return result;
	}

	readShort() {
		const result = this.view.getUint16(this.offset, true);
		this.offset += 2;
		return result;
	}

	readBytes(count) {
		const result = new Uint8Array(this.view.buffer, this.offset, count);
		this.offset += count;
		return result;
	}
}

const deserializePath = reader => {
	const numNibbles = reader.readByte();
	const numBytes = Math.floor((numNibbles + 1) / 2);
	return { path: reader.readBytes(numBytes), size: numNibbles };
};

const deserializeLeaf = reader => {
	const path = deserializePath(reader);
	const value = new _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_0__.Hash256(reader.readBytes(_CryptoTypes_js__WEBPACK_IMPORTED_MODULE_0__.Hash256.SIZE));
	return new LeafNode(path, value);
};

const deserializeBranch = reader => {
	const path = deserializePath(reader);

	const linksMask = reader.readShort();
	const links = new Array(16);
	for (let i = 0; i < links.length; ++i)
		links[i] = linksMask & (2 ** i) ? new _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_0__.Hash256(reader.readBytes(_CryptoTypes_js__WEBPACK_IMPORTED_MODULE_0__.Hash256.SIZE)) : undefined;

	return new BranchNode(path, links);
};

/**
 * Deserializes a buffer containing patricia tree nodes.
 * @param {Uint8Array} buffer Buffer containing serialized patricia tree nodes.
 * @returns {Array<TreeNode>} Deserialized patricia tree nodes.
 */
const deserializePatriciaTreeNodes = buffer => {
	const reader = new BufferReader(buffer.buffer);
	const nodes = [];
	while (!reader.eof) {
		const nodeMarker = reader.readByte();

		switch (nodeMarker) {
		case 0xFF:
			nodes.push(deserializeLeaf(reader));
			break;

		case 0x00:
			nodes.push(deserializeBranch(reader));
			break;

		default:
			throw new Error(`invalid marker of a serialized node (${nodeMarker})`);
		}
	}

	return nodes;
};

// endregion

// region provePatriciaMerkle

/**
 * Possible results of a patricia merkle proof.
 */
class PatriciaMerkleProofResult {
	/**
	 * Proof is valid (positive).
	 * @type {number}
	 */
	static VALID_POSITIVE = 0x0001;

	/**
	 * Proof is valid (negative).
	 * @type {number}
	 */
	static VALID_NEGATIVE = 0x0002;

	/**
	 * Negative proof is inconclusive.
	 * @type {number}
	 */
	static INCONCLUSIVE = 0x4001;

	/**
	 * State hash cannot be derived from subcache merkle roots.
	 * @type {number}
	 */
	static STATE_HASH_DOES_NOT_MATCH_ROOTS = 0x8001;

	/**
	 * Root of the path tree being proven is not a subcache merkle root.
	 * @type {number}
	 */
	static UNANCHORED_PATH_TREE = 0x8002;

	/**
	 * Leaf value does not match expected value.
	 * @type {number}
	 */
	static LEAF_VALUE_MISMATCH = 0x8003;

	/**
	 * Provided merkle hash contains an unlinked node.
	 * @type {number}
	 */
	static UNLINKED_NODE = 0x8004;

	/**
	 * Actual merkle path does not match encoded key.
	 * @type {number}
	 */
	static PATH_MISMATCH = 0x8005;
}

const checkStateHash = (stateHash, subcacheMerkleRoots) => {
	const hasher = _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_3__.sha3_256.create();
	subcacheMerkleRoots.forEach(root => {
		hasher.update(root.bytes);
	});

	return 0 === (0,_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_1__.deepCompare)(stateHash.bytes, hasher.digest());
};

const findLinkIndex = (branchNode, targetLinkHash) => (
	branchNode.links.findIndex(link => undefined !== link && 0 === (0,_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_1__.deepCompare)(targetLinkHash.bytes, link.bytes))
);

/**
 * Proves a patricia merkle hash.
 * @param {Hash256} encodedKey Encoded key of the state to prove.
 * @param {Hash256} valueToTest Expected hash of the state to prove.
 * @param {Array<TreeNode>} merklePath Merkle *node* path from root to leaf.
 * @param {Hash256} stateHash State hash from a block header.
 * @param {Array<Hash256>} subcacheMerkleRoots Sub cache merkle roots corresponding to the state hash.
 * @returns {number} Proof result code.
 */
const provePatriciaMerkle = (encodedKey, valueToTest, merklePath, stateHash, subcacheMerkleRoots) => {
	if (!checkStateHash(stateHash, subcacheMerkleRoots))
		return PatriciaMerkleProofResult.STATE_HASH_DOES_NOT_MATCH_ROOTS;

	const pathRootHash = merklePath[0].calculateHash();
	if (subcacheMerkleRoots.every(root => 0 !== (0,_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_1__.deepCompare)(pathRootHash.bytes, root.bytes)))
		return PatriciaMerkleProofResult.UNANCHORED_PATH_TREE;

	// positive proof must end with a leaf
	const isPositiveProof = 'value' in merklePath[merklePath.length - 1];
	if (isPositiveProof) {
		if (0 !== (0,_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_1__.deepCompare)(valueToTest.bytes, (/** @type {LeafNode} */ (merklePath[merklePath.length - 1])).value.bytes))
			return PatriciaMerkleProofResult.LEAF_VALUE_MISMATCH;
	}

	let childHash;
	let actualPath = '';
	for (let i = merklePath.length - 1; 0 <= i; --i) {
		const node = merklePath[i];
		const nodeHash = node.calculateHash();
		let formattedLinkIndex = '';
		if (childHash) {
			const linkIndex = findLinkIndex(node, childHash);
			if (-1 === linkIndex)
				return PatriciaMerkleProofResult.UNLINKED_NODE;

			formattedLinkIndex = (0,_utils_converter_js__WEBPACK_IMPORTED_MODULE_2__.uint8ToHex)(new Uint8Array([linkIndex]))[1];
		}

		childHash = nodeHash;
		actualPath = `${formattedLinkIndex}${node.hexPath}${actualPath}`;
	}

	if (isPositiveProof) {
		// for positive proof, expected and calculated paths must match exactly
		return actualPath !== encodedKey.toString() ? PatriciaMerkleProofResult.PATH_MISMATCH : PatriciaMerkleProofResult.VALID_POSITIVE;
	}

	// for negative proof, expected path must start with calculated path and next nibble must be a dead end
	if (!encodedKey.toString().startsWith(actualPath))
		return PatriciaMerkleProofResult.PATH_MISMATCH;

	const nextNibble = getNibbleAt({ path: encodedKey.bytes, size: 2 * encodedKey.bytes.length }, actualPath.length);
	const nextNode = (/** @type {BranchNode} */ (merklePath[merklePath.length - 1])).links[nextNibble];
	return undefined !== nextNode ? PatriciaMerkleProofResult.INCONCLUSIVE : PatriciaMerkleProofResult.VALID_NEGATIVE;
};

// endregion



// region type declarations

/**
 * Path in a Patricia merkle treee.
 * @class
 * @typedef {object} PatriciaTreePath
 * @property {Uint8Array} path Bytes composing the full path.
 * @property {number} size Length (in nibbles) of the path.
 */

/**
 * Represents part of a merkle tree proof.
 * @class
 * @typedef {object} MerklePart
 * @property {Hash256} hash Hash at this node.
 * @property {boolean} isLeft \c true if this is a left node; right otherwise.
 */

// endregion


/***/ }),

/***/ "./node_modules/symbol-sdk/src/symbol/metadata.js":
/*!********************************************************!*\
  !*** ./node_modules/symbol-sdk/src/symbol/metadata.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   metadataGenerateKey: () => (/* binding */ metadataGenerateKey),
/* harmony export */   metadataUpdateValue: () => (/* binding */ metadataUpdateValue)
/* harmony export */ });
/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ "./node_modules/@noble/hashes/esm/sha3.js");


/**
 * Generates a metadata key from a string.
 * @param {string} seed Metadata key seed.
 * @returns {bigint} Metadata key.
 */
const metadataGenerateKey = seed => {
	const hashResult = (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.sha3_256)(seed);

	const keyBytes = hashResult.subarray(0, 8);
	keyBytes[7] |= 0x80; // set high bit to match SDK V2 implementation

	const keys = new BigUint64Array(keyBytes.buffer);
	return keys[0];
};

/**
 * Creates a metadata payload for updating old value to new value.
 * @param {Uint8Array|undefined} oldValue Old metadata value.
 * @param {Uint8Array} newValue New metadata value.
 * @returns {Uint8Array} Metadata payload for updating old value to new value.
 */
const metadataUpdateValue = (oldValue, newValue) => {
	if (!oldValue)
		return newValue;

	const shorterLength = Math.min(oldValue.length, newValue.length);
	const longerLength = Math.max(oldValue.length, newValue.length);
	const isNewValueShorter = oldValue.length > newValue.length;

	const result = new Uint8Array(longerLength);

	let i = 0;
	for (i = 0; i < shorterLength; ++i)
		result[i] = oldValue[i] ^ newValue[i];

	for (; i < longerLength; ++i)
		result[i] = (isNewValueShorter ? oldValue : newValue)[i];

	return result;
};




/***/ }),

/***/ "./node_modules/symbol-sdk/src/symbol/models.js":
/*!******************************************************!*\
  !*** ./node_modules/symbol-sdk/src/symbol/models.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AccountAddressRestrictionTransactionV1: () => (/* binding */ AccountAddressRestrictionTransactionV1),
/* harmony export */   AccountKeyLinkTransactionV1: () => (/* binding */ AccountKeyLinkTransactionV1),
/* harmony export */   AccountMetadataTransactionV1: () => (/* binding */ AccountMetadataTransactionV1),
/* harmony export */   AccountMosaicRestrictionTransactionV1: () => (/* binding */ AccountMosaicRestrictionTransactionV1),
/* harmony export */   AccountOperationRestrictionTransactionV1: () => (/* binding */ AccountOperationRestrictionTransactionV1),
/* harmony export */   AccountRestrictionFlags: () => (/* binding */ AccountRestrictionFlags),
/* harmony export */   Address: () => (/* binding */ Address),
/* harmony export */   AddressAliasTransactionV1: () => (/* binding */ AddressAliasTransactionV1),
/* harmony export */   AddressResolutionEntry: () => (/* binding */ AddressResolutionEntry),
/* harmony export */   AddressResolutionStatement: () => (/* binding */ AddressResolutionStatement),
/* harmony export */   AggregateBondedTransactionV1: () => (/* binding */ AggregateBondedTransactionV1),
/* harmony export */   AggregateBondedTransactionV2: () => (/* binding */ AggregateBondedTransactionV2),
/* harmony export */   AggregateCompleteTransactionV1: () => (/* binding */ AggregateCompleteTransactionV1),
/* harmony export */   AggregateCompleteTransactionV2: () => (/* binding */ AggregateCompleteTransactionV2),
/* harmony export */   AliasAction: () => (/* binding */ AliasAction),
/* harmony export */   Amount: () => (/* binding */ Amount),
/* harmony export */   Block: () => (/* binding */ Block),
/* harmony export */   BlockDuration: () => (/* binding */ BlockDuration),
/* harmony export */   BlockFactory: () => (/* binding */ BlockFactory),
/* harmony export */   BlockFeeMultiplier: () => (/* binding */ BlockFeeMultiplier),
/* harmony export */   BlockStatement: () => (/* binding */ BlockStatement),
/* harmony export */   BlockType: () => (/* binding */ BlockType),
/* harmony export */   Cosignature: () => (/* binding */ Cosignature),
/* harmony export */   DetachedCosignature: () => (/* binding */ DetachedCosignature),
/* harmony export */   Difficulty: () => (/* binding */ Difficulty),
/* harmony export */   EmbeddedAccountAddressRestrictionTransactionV1: () => (/* binding */ EmbeddedAccountAddressRestrictionTransactionV1),
/* harmony export */   EmbeddedAccountKeyLinkTransactionV1: () => (/* binding */ EmbeddedAccountKeyLinkTransactionV1),
/* harmony export */   EmbeddedAccountMetadataTransactionV1: () => (/* binding */ EmbeddedAccountMetadataTransactionV1),
/* harmony export */   EmbeddedAccountMosaicRestrictionTransactionV1: () => (/* binding */ EmbeddedAccountMosaicRestrictionTransactionV1),
/* harmony export */   EmbeddedAccountOperationRestrictionTransactionV1: () => (/* binding */ EmbeddedAccountOperationRestrictionTransactionV1),
/* harmony export */   EmbeddedAddressAliasTransactionV1: () => (/* binding */ EmbeddedAddressAliasTransactionV1),
/* harmony export */   EmbeddedHashLockTransactionV1: () => (/* binding */ EmbeddedHashLockTransactionV1),
/* harmony export */   EmbeddedMosaicAddressRestrictionTransactionV1: () => (/* binding */ EmbeddedMosaicAddressRestrictionTransactionV1),
/* harmony export */   EmbeddedMosaicAliasTransactionV1: () => (/* binding */ EmbeddedMosaicAliasTransactionV1),
/* harmony export */   EmbeddedMosaicDefinitionTransactionV1: () => (/* binding */ EmbeddedMosaicDefinitionTransactionV1),
/* harmony export */   EmbeddedMosaicGlobalRestrictionTransactionV1: () => (/* binding */ EmbeddedMosaicGlobalRestrictionTransactionV1),
/* harmony export */   EmbeddedMosaicMetadataTransactionV1: () => (/* binding */ EmbeddedMosaicMetadataTransactionV1),
/* harmony export */   EmbeddedMosaicSupplyChangeTransactionV1: () => (/* binding */ EmbeddedMosaicSupplyChangeTransactionV1),
/* harmony export */   EmbeddedMosaicSupplyRevocationTransactionV1: () => (/* binding */ EmbeddedMosaicSupplyRevocationTransactionV1),
/* harmony export */   EmbeddedMultisigAccountModificationTransactionV1: () => (/* binding */ EmbeddedMultisigAccountModificationTransactionV1),
/* harmony export */   EmbeddedNamespaceMetadataTransactionV1: () => (/* binding */ EmbeddedNamespaceMetadataTransactionV1),
/* harmony export */   EmbeddedNamespaceRegistrationTransactionV1: () => (/* binding */ EmbeddedNamespaceRegistrationTransactionV1),
/* harmony export */   EmbeddedNodeKeyLinkTransactionV1: () => (/* binding */ EmbeddedNodeKeyLinkTransactionV1),
/* harmony export */   EmbeddedSecretLockTransactionV1: () => (/* binding */ EmbeddedSecretLockTransactionV1),
/* harmony export */   EmbeddedSecretProofTransactionV1: () => (/* binding */ EmbeddedSecretProofTransactionV1),
/* harmony export */   EmbeddedTransaction: () => (/* binding */ EmbeddedTransaction),
/* harmony export */   EmbeddedTransactionFactory: () => (/* binding */ EmbeddedTransactionFactory),
/* harmony export */   EmbeddedTransferTransactionV1: () => (/* binding */ EmbeddedTransferTransactionV1),
/* harmony export */   EmbeddedVotingKeyLinkTransactionV1: () => (/* binding */ EmbeddedVotingKeyLinkTransactionV1),
/* harmony export */   EmbeddedVrfKeyLinkTransactionV1: () => (/* binding */ EmbeddedVrfKeyLinkTransactionV1),
/* harmony export */   FinalizationEpoch: () => (/* binding */ FinalizationEpoch),
/* harmony export */   FinalizationPoint: () => (/* binding */ FinalizationPoint),
/* harmony export */   FinalizationRound: () => (/* binding */ FinalizationRound),
/* harmony export */   FinalizedBlockHeader: () => (/* binding */ FinalizedBlockHeader),
/* harmony export */   HarvestFeeReceipt: () => (/* binding */ HarvestFeeReceipt),
/* harmony export */   Hash256: () => (/* binding */ Hash256),
/* harmony export */   Hash512: () => (/* binding */ Hash512),
/* harmony export */   HashLockTransactionV1: () => (/* binding */ HashLockTransactionV1),
/* harmony export */   Height: () => (/* binding */ Height),
/* harmony export */   Importance: () => (/* binding */ Importance),
/* harmony export */   ImportanceBlockV1: () => (/* binding */ ImportanceBlockV1),
/* harmony export */   ImportanceHeight: () => (/* binding */ ImportanceHeight),
/* harmony export */   InflationReceipt: () => (/* binding */ InflationReceipt),
/* harmony export */   LinkAction: () => (/* binding */ LinkAction),
/* harmony export */   LockHashAlgorithm: () => (/* binding */ LockHashAlgorithm),
/* harmony export */   LockHashCompletedFeeReceipt: () => (/* binding */ LockHashCompletedFeeReceipt),
/* harmony export */   LockHashCreatedFeeReceipt: () => (/* binding */ LockHashCreatedFeeReceipt),
/* harmony export */   LockHashExpiredFeeReceipt: () => (/* binding */ LockHashExpiredFeeReceipt),
/* harmony export */   LockSecretCompletedFeeReceipt: () => (/* binding */ LockSecretCompletedFeeReceipt),
/* harmony export */   LockSecretCreatedFeeReceipt: () => (/* binding */ LockSecretCreatedFeeReceipt),
/* harmony export */   LockSecretExpiredFeeReceipt: () => (/* binding */ LockSecretExpiredFeeReceipt),
/* harmony export */   Mosaic: () => (/* binding */ Mosaic),
/* harmony export */   MosaicAddressRestrictionTransactionV1: () => (/* binding */ MosaicAddressRestrictionTransactionV1),
/* harmony export */   MosaicAliasTransactionV1: () => (/* binding */ MosaicAliasTransactionV1),
/* harmony export */   MosaicDefinitionTransactionV1: () => (/* binding */ MosaicDefinitionTransactionV1),
/* harmony export */   MosaicExpiredReceipt: () => (/* binding */ MosaicExpiredReceipt),
/* harmony export */   MosaicFlags: () => (/* binding */ MosaicFlags),
/* harmony export */   MosaicGlobalRestrictionTransactionV1: () => (/* binding */ MosaicGlobalRestrictionTransactionV1),
/* harmony export */   MosaicId: () => (/* binding */ MosaicId),
/* harmony export */   MosaicMetadataTransactionV1: () => (/* binding */ MosaicMetadataTransactionV1),
/* harmony export */   MosaicNonce: () => (/* binding */ MosaicNonce),
/* harmony export */   MosaicRentalFeeReceipt: () => (/* binding */ MosaicRentalFeeReceipt),
/* harmony export */   MosaicResolutionEntry: () => (/* binding */ MosaicResolutionEntry),
/* harmony export */   MosaicResolutionStatement: () => (/* binding */ MosaicResolutionStatement),
/* harmony export */   MosaicRestrictionKey: () => (/* binding */ MosaicRestrictionKey),
/* harmony export */   MosaicRestrictionType: () => (/* binding */ MosaicRestrictionType),
/* harmony export */   MosaicSupplyChangeAction: () => (/* binding */ MosaicSupplyChangeAction),
/* harmony export */   MosaicSupplyChangeTransactionV1: () => (/* binding */ MosaicSupplyChangeTransactionV1),
/* harmony export */   MosaicSupplyRevocationTransactionV1: () => (/* binding */ MosaicSupplyRevocationTransactionV1),
/* harmony export */   MultisigAccountModificationTransactionV1: () => (/* binding */ MultisigAccountModificationTransactionV1),
/* harmony export */   NamespaceDeletedReceipt: () => (/* binding */ NamespaceDeletedReceipt),
/* harmony export */   NamespaceExpiredReceipt: () => (/* binding */ NamespaceExpiredReceipt),
/* harmony export */   NamespaceId: () => (/* binding */ NamespaceId),
/* harmony export */   NamespaceMetadataTransactionV1: () => (/* binding */ NamespaceMetadataTransactionV1),
/* harmony export */   NamespaceRegistrationTransactionV1: () => (/* binding */ NamespaceRegistrationTransactionV1),
/* harmony export */   NamespaceRegistrationType: () => (/* binding */ NamespaceRegistrationType),
/* harmony export */   NamespaceRentalFeeReceipt: () => (/* binding */ NamespaceRentalFeeReceipt),
/* harmony export */   NemesisBlockV1: () => (/* binding */ NemesisBlockV1),
/* harmony export */   NetworkType: () => (/* binding */ NetworkType),
/* harmony export */   NodeKeyLinkTransactionV1: () => (/* binding */ NodeKeyLinkTransactionV1),
/* harmony export */   NormalBlockV1: () => (/* binding */ NormalBlockV1),
/* harmony export */   ProofGamma: () => (/* binding */ ProofGamma),
/* harmony export */   ProofScalar: () => (/* binding */ ProofScalar),
/* harmony export */   ProofVerificationHash: () => (/* binding */ ProofVerificationHash),
/* harmony export */   PublicKey: () => (/* binding */ PublicKey),
/* harmony export */   Receipt: () => (/* binding */ Receipt),
/* harmony export */   ReceiptFactory: () => (/* binding */ ReceiptFactory),
/* harmony export */   ReceiptSource: () => (/* binding */ ReceiptSource),
/* harmony export */   ReceiptType: () => (/* binding */ ReceiptType),
/* harmony export */   SecretLockTransactionV1: () => (/* binding */ SecretLockTransactionV1),
/* harmony export */   SecretProofTransactionV1: () => (/* binding */ SecretProofTransactionV1),
/* harmony export */   Signature: () => (/* binding */ Signature),
/* harmony export */   Timestamp: () => (/* binding */ Timestamp),
/* harmony export */   Transaction: () => (/* binding */ Transaction),
/* harmony export */   TransactionFactory: () => (/* binding */ TransactionFactory),
/* harmony export */   TransactionStatement: () => (/* binding */ TransactionStatement),
/* harmony export */   TransactionType: () => (/* binding */ TransactionType),
/* harmony export */   TransferTransactionV1: () => (/* binding */ TransferTransactionV1),
/* harmony export */   UnresolvedAddress: () => (/* binding */ UnresolvedAddress),
/* harmony export */   UnresolvedMosaic: () => (/* binding */ UnresolvedMosaic),
/* harmony export */   UnresolvedMosaicId: () => (/* binding */ UnresolvedMosaicId),
/* harmony export */   VotingKeyLinkTransactionV1: () => (/* binding */ VotingKeyLinkTransactionV1),
/* harmony export */   VotingPublicKey: () => (/* binding */ VotingPublicKey),
/* harmony export */   VrfKeyLinkTransactionV1: () => (/* binding */ VrfKeyLinkTransactionV1),
/* harmony export */   VrfProof: () => (/* binding */ VrfProof)
/* harmony export */ });
/* harmony import */ var _BaseValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../BaseValue.js */ "./node_modules/symbol-sdk/src/BaseValue.js");
/* harmony import */ var _ByteArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ByteArray.js */ "./node_modules/symbol-sdk/src/ByteArray.js");
/* harmony import */ var _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/BufferView.js */ "./node_modules/symbol-sdk/src/utils/BufferView.js");
/* harmony import */ var _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Writer.js */ "./node_modules/symbol-sdk/src/utils/Writer.js");
/* harmony import */ var _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/arrayHelpers.js */ "./node_modules/symbol-sdk/src/utils/arrayHelpers.js");
/* harmony import */ var _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/converter.js */ "./node_modules/symbol-sdk/src/utils/converter.js");
/* eslint-disable max-len, object-property-newline, no-underscore-dangle, no-use-before-define */








class Amount extends _BaseValue_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
	static SIZE = 8;

	constructor(amount = 0n) {
		super(Amount.SIZE, amount);
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new Amount(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigIntUnaligned(byteArray, 8, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return new Amount(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(byteArray, 8, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 8, false);
	}
}

class BlockDuration extends _BaseValue_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
	static SIZE = 8;

	constructor(blockDuration = 0n) {
		super(BlockDuration.SIZE, blockDuration);
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new BlockDuration(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigIntUnaligned(byteArray, 8, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return new BlockDuration(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(byteArray, 8, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 8, false);
	}
}

class BlockFeeMultiplier extends _BaseValue_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
	static SIZE = 4;

	constructor(blockFeeMultiplier = 0) {
		super(BlockFeeMultiplier.SIZE, blockFeeMultiplier);
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new BlockFeeMultiplier(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(byteArray, 4, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return new BlockFeeMultiplier(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(byteArray, 4, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 4, false);
	}
}

class Difficulty extends _BaseValue_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
	static SIZE = 8;

	constructor(difficulty = 0n) {
		super(Difficulty.SIZE, difficulty);
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new Difficulty(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigIntUnaligned(byteArray, 8, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return new Difficulty(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(byteArray, 8, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 8, false);
	}
}

class FinalizationEpoch extends _BaseValue_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
	static SIZE = 4;

	constructor(finalizationEpoch = 0) {
		super(FinalizationEpoch.SIZE, finalizationEpoch);
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new FinalizationEpoch(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(byteArray, 4, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return new FinalizationEpoch(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(byteArray, 4, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 4, false);
	}
}

class FinalizationPoint extends _BaseValue_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
	static SIZE = 4;

	constructor(finalizationPoint = 0) {
		super(FinalizationPoint.SIZE, finalizationPoint);
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new FinalizationPoint(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(byteArray, 4, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return new FinalizationPoint(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(byteArray, 4, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 4, false);
	}
}

class Height extends _BaseValue_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
	static SIZE = 8;

	constructor(height = 0n) {
		super(Height.SIZE, height);
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new Height(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigIntUnaligned(byteArray, 8, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return new Height(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(byteArray, 8, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 8, false);
	}
}

class Importance extends _BaseValue_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
	static SIZE = 8;

	constructor(importance = 0n) {
		super(Importance.SIZE, importance);
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new Importance(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigIntUnaligned(byteArray, 8, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return new Importance(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(byteArray, 8, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 8, false);
	}
}

class ImportanceHeight extends _BaseValue_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
	static SIZE = 8;

	constructor(importanceHeight = 0n) {
		super(ImportanceHeight.SIZE, importanceHeight);
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new ImportanceHeight(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigIntUnaligned(byteArray, 8, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return new ImportanceHeight(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(byteArray, 8, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 8, false);
	}
}

class UnresolvedMosaicId extends _BaseValue_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
	static SIZE = 8;

	constructor(unresolvedMosaicId = 0n) {
		super(UnresolvedMosaicId.SIZE, unresolvedMosaicId);
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new UnresolvedMosaicId(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigIntUnaligned(byteArray, 8, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return new UnresolvedMosaicId(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(byteArray, 8, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 8, false);
	}
}

class MosaicId extends _BaseValue_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
	static SIZE = 8;

	constructor(mosaicId = 0n) {
		super(MosaicId.SIZE, mosaicId);
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new MosaicId(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigIntUnaligned(byteArray, 8, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return new MosaicId(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(byteArray, 8, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 8, false);
	}
}

class Timestamp extends _BaseValue_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
	static SIZE = 8;

	constructor(timestamp = 0n) {
		super(Timestamp.SIZE, timestamp);
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new Timestamp(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigIntUnaligned(byteArray, 8, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return new Timestamp(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(byteArray, 8, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 8, false);
	}
}

class UnresolvedAddress extends _ByteArray_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
	static SIZE = 24;

	constructor(unresolvedAddress = new Uint8Array(24)) {
		super(UnresolvedAddress.SIZE, unresolvedAddress);
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 24;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new UnresolvedAddress(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 24));
	}

	serialize() {
		return this.bytes;
	}
}

class Address extends _ByteArray_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
	static SIZE = 24;

	constructor(address = new Uint8Array(24)) {
		super(Address.SIZE, address);
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 24;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new Address(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 24));
	}

	serialize() {
		return this.bytes;
	}
}

class Hash256 extends _ByteArray_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
	static SIZE = 32;

	constructor(hash256 = new Uint8Array(32)) {
		super(Hash256.SIZE, hash256);
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 32;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new Hash256(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 32));
	}

	serialize() {
		return this.bytes;
	}
}

class Hash512 extends _ByteArray_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
	static SIZE = 64;

	constructor(hash512 = new Uint8Array(64)) {
		super(Hash512.SIZE, hash512);
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 64;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new Hash512(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 64));
	}

	serialize() {
		return this.bytes;
	}
}

class PublicKey extends _ByteArray_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
	static SIZE = 32;

	constructor(publicKey = new Uint8Array(32)) {
		super(PublicKey.SIZE, publicKey);
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 32;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new PublicKey(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 32));
	}

	serialize() {
		return this.bytes;
	}
}

class VotingPublicKey extends _ByteArray_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
	static SIZE = 32;

	constructor(votingPublicKey = new Uint8Array(32)) {
		super(VotingPublicKey.SIZE, votingPublicKey);
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 32;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new VotingPublicKey(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 32));
	}

	serialize() {
		return this.bytes;
	}
}

class Signature extends _ByteArray_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
	static SIZE = 64;

	constructor(signature = new Uint8Array(64)) {
		super(Signature.SIZE, signature);
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 64;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new Signature(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 64));
	}

	serialize() {
		return this.bytes;
	}
}

class Mosaic {
	static TYPE_HINTS = {
		mosaicId: 'pod:MosaicId',
		amount: 'pod:Amount'
	};

	constructor() {
		this._mosaicId = new MosaicId();
		this._amount = new Amount();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get mosaicId() {
		return this._mosaicId;
	}

	set mosaicId(value) {
		this._mosaicId = value;
	}

	get amount() {
		return this._amount;
	}

	set amount(value) {
		this._amount = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += this.mosaicId.size;
		size += this.amount.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new Mosaic();

		const mosaicId = MosaicId.deserialize(view.buffer);
		view.shiftRight(mosaicId.size);
		const amount = Amount.deserialize(view.buffer);
		view.shiftRight(amount.size);

		instance._mosaicId = mosaicId;
		instance._amount = amount;
		return instance;
	}

	static deserializeAligned(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new Mosaic();

		const mosaicId = MosaicId.deserializeAligned(view.buffer);
		view.shiftRight(mosaicId.size);
		const amount = Amount.deserializeAligned(view.buffer);
		view.shiftRight(amount.size);

		instance._mosaicId = mosaicId;
		instance._amount = amount;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		buffer.write(this._mosaicId.serialize());
		buffer.write(this._amount.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += `mosaicId: ${this._mosaicId.toString()}, `;
		result += `amount: ${this._amount.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		result.mosaicId = this._mosaicId.toJson();
		result.amount = this._amount.toJson();
		return result;
	}
}

class UnresolvedMosaic {
	static TYPE_HINTS = {
		mosaicId: 'pod:UnresolvedMosaicId',
		amount: 'pod:Amount'
	};

	constructor() {
		this._mosaicId = new UnresolvedMosaicId();
		this._amount = new Amount();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get mosaicId() {
		return this._mosaicId;
	}

	set mosaicId(value) {
		this._mosaicId = value;
	}

	get amount() {
		return this._amount;
	}

	set amount(value) {
		this._amount = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += this.mosaicId.size;
		size += this.amount.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new UnresolvedMosaic();

		const mosaicId = UnresolvedMosaicId.deserialize(view.buffer);
		view.shiftRight(mosaicId.size);
		const amount = Amount.deserialize(view.buffer);
		view.shiftRight(amount.size);

		instance._mosaicId = mosaicId;
		instance._amount = amount;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		buffer.write(this._mosaicId.serialize());
		buffer.write(this._amount.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += `mosaicId: ${this._mosaicId.toString()}, `;
		result += `amount: ${this._amount.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		result.mosaicId = this._mosaicId.toJson();
		result.amount = this._amount.toJson();
		return result;
	}
}

class LinkAction {
	static UNLINK = new LinkAction(0);

	static LINK = new LinkAction(1);

	constructor(value) {
		this.value = value;
	}

	static valueToKey(value) {
		const values = [
			0, 1
		];
		const keys = [
			'UNLINK', 'LINK'
		];

		const index = values.indexOf(value);
		if (-1 === index)
			throw RangeError(`invalid enum value ${value}`);

		return keys[index];
	}

	static fromValue(value) {
		return LinkAction[this.valueToKey(value)];
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 1;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(byteArray, 1, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(byteArray, 1, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 1, false);
	}

	toString() {
		return `LinkAction.${LinkAction.valueToKey(this.value)}`;
	}

	toJson() {
		return this.value;
	}
}

class NetworkType {
	static MAINNET = new NetworkType(104);

	static TESTNET = new NetworkType(152);

	constructor(value) {
		this.value = value;
	}

	static valueToKey(value) {
		const values = [
			104, 152
		];
		const keys = [
			'MAINNET', 'TESTNET'
		];

		const index = values.indexOf(value);
		if (-1 === index)
			throw RangeError(`invalid enum value ${value}`);

		return keys[index];
	}

	static fromValue(value) {
		return NetworkType[this.valueToKey(value)];
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 1;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(byteArray, 1, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(byteArray, 1, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 1, false);
	}

	toString() {
		return `NetworkType.${NetworkType.valueToKey(this.value)}`;
	}

	toJson() {
		return this.value;
	}
}

class TransactionType {
	static ACCOUNT_KEY_LINK = new TransactionType(16716);

	static NODE_KEY_LINK = new TransactionType(16972);

	static AGGREGATE_COMPLETE = new TransactionType(16705);

	static AGGREGATE_BONDED = new TransactionType(16961);

	static VOTING_KEY_LINK = new TransactionType(16707);

	static VRF_KEY_LINK = new TransactionType(16963);

	static HASH_LOCK = new TransactionType(16712);

	static SECRET_LOCK = new TransactionType(16722);

	static SECRET_PROOF = new TransactionType(16978);

	static ACCOUNT_METADATA = new TransactionType(16708);

	static MOSAIC_METADATA = new TransactionType(16964);

	static NAMESPACE_METADATA = new TransactionType(17220);

	static MOSAIC_DEFINITION = new TransactionType(16717);

	static MOSAIC_SUPPLY_CHANGE = new TransactionType(16973);

	static MOSAIC_SUPPLY_REVOCATION = new TransactionType(17229);

	static MULTISIG_ACCOUNT_MODIFICATION = new TransactionType(16725);

	static ADDRESS_ALIAS = new TransactionType(16974);

	static MOSAIC_ALIAS = new TransactionType(17230);

	static NAMESPACE_REGISTRATION = new TransactionType(16718);

	static ACCOUNT_ADDRESS_RESTRICTION = new TransactionType(16720);

	static ACCOUNT_MOSAIC_RESTRICTION = new TransactionType(16976);

	static ACCOUNT_OPERATION_RESTRICTION = new TransactionType(17232);

	static MOSAIC_ADDRESS_RESTRICTION = new TransactionType(16977);

	static MOSAIC_GLOBAL_RESTRICTION = new TransactionType(16721);

	static TRANSFER = new TransactionType(16724);

	constructor(value) {
		this.value = value;
	}

	static valueToKey(value) {
		const values = [
			16716, 16972, 16705, 16961, 16707, 16963, 16712, 16722, 16978, 16708, 16964, 17220, 16717, 16973, 17229, 16725, 16974, 17230,
			16718, 16720, 16976, 17232, 16977, 16721, 16724
		];
		const keys = [
			'ACCOUNT_KEY_LINK', 'NODE_KEY_LINK', 'AGGREGATE_COMPLETE', 'AGGREGATE_BONDED', 'VOTING_KEY_LINK', 'VRF_KEY_LINK', 'HASH_LOCK',
			'SECRET_LOCK', 'SECRET_PROOF', 'ACCOUNT_METADATA', 'MOSAIC_METADATA', 'NAMESPACE_METADATA', 'MOSAIC_DEFINITION',
			'MOSAIC_SUPPLY_CHANGE', 'MOSAIC_SUPPLY_REVOCATION', 'MULTISIG_ACCOUNT_MODIFICATION', 'ADDRESS_ALIAS', 'MOSAIC_ALIAS',
			'NAMESPACE_REGISTRATION', 'ACCOUNT_ADDRESS_RESTRICTION', 'ACCOUNT_MOSAIC_RESTRICTION', 'ACCOUNT_OPERATION_RESTRICTION',
			'MOSAIC_ADDRESS_RESTRICTION', 'MOSAIC_GLOBAL_RESTRICTION', 'TRANSFER'
		];

		const index = values.indexOf(value);
		if (-1 === index)
			throw RangeError(`invalid enum value ${value}`);

		return keys[index];
	}

	static fromValue(value) {
		return TransactionType[this.valueToKey(value)];
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 2;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(byteArray, 2, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(byteArray, 2, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 2, false);
	}

	toString() {
		return `TransactionType.${TransactionType.valueToKey(this.value)}`;
	}

	toJson() {
		return this.value;
	}
}

class Transaction {
	static TYPE_HINTS = {
		signature: 'pod:Signature',
		signerPublicKey: 'pod:PublicKey',
		network: 'enum:NetworkType',
		type: 'enum:TransactionType',
		fee: 'pod:Amount',
		deadline: 'pod:Timestamp'
	};

	constructor() {
		this._signature = new Signature();
		this._signerPublicKey = new PublicKey();
		this._version = 0;
		this._network = NetworkType.MAINNET;
		this._type = TransactionType.ACCOUNT_KEY_LINK;
		this._fee = new Amount();
		this._deadline = new Timestamp();
		this._verifiableEntityHeaderReserved_1 = 0; // reserved field
		this._entityBodyReserved_1 = 0; // reserved field
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get signature() {
		return this._signature;
	}

	set signature(value) {
		this._signature = value;
	}

	get signerPublicKey() {
		return this._signerPublicKey;
	}

	set signerPublicKey(value) {
		this._signerPublicKey = value;
	}

	get version() {
		return this._version;
	}

	set version(value) {
		this._version = value;
	}

	get network() {
		return this._network;
	}

	set network(value) {
		this._network = value;
	}

	get type() {
		return this._type;
	}

	set type(value) {
		this._type = value;
	}

	get fee() {
		return this._fee;
	}

	set fee(value) {
		this._fee = value;
	}

	get deadline() {
		return this._deadline;
	}

	set deadline(value) {
		this._deadline = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += 4;
		size += 4;
		size += this.signature.size;
		size += this.signerPublicKey.size;
		size += 4;
		size += 1;
		size += this.network.size;
		size += this.type.size;
		size += this.fee.size;
		size += this.deadline.size;
		return size;
	}

	static _deserialize(view, instance) {
		const size = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		view.shrink(size - 4);
		const verifiableEntityHeaderReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== verifiableEntityHeaderReserved_1)
			throw RangeError(`Invalid value of reserved field (${verifiableEntityHeaderReserved_1})`);
		const signature = Signature.deserialize(view.buffer);
		view.shiftRight(signature.size);
		const signerPublicKey = PublicKey.deserialize(view.buffer);
		view.shiftRight(signerPublicKey.size);
		const entityBodyReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== entityBodyReserved_1)
			throw RangeError(`Invalid value of reserved field (${entityBodyReserved_1})`);
		const version = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const network = NetworkType.deserializeAligned(view.buffer);
		view.shiftRight(network.size);
		const type = TransactionType.deserializeAligned(view.buffer);
		view.shiftRight(type.size);
		const fee = Amount.deserializeAligned(view.buffer);
		view.shiftRight(fee.size);
		const deadline = Timestamp.deserializeAligned(view.buffer);
		view.shiftRight(deadline.size);

		instance._signature = signature;
		instance._signerPublicKey = signerPublicKey;
		instance._version = version;
		instance._network = network;
		instance._type = type;
		instance._fee = fee;
		instance._deadline = deadline;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		this._serialize(buffer);
		return buffer.storage;
	}

	_serialize(buffer) {
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.size, 4, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._verifiableEntityHeaderReserved_1, 4, false));
		buffer.write(this._signature.serialize());
		buffer.write(this._signerPublicKey.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._entityBodyReserved_1, 4, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._version, 1, false));
		buffer.write(this._network.serialize());
		buffer.write(this._type.serialize());
		buffer.write(this._fee.serialize());
		buffer.write(this._deadline.serialize());
	}

	toString() {
		let result = '(';
		result += `signature: ${this._signature.toString()}, `;
		result += `signerPublicKey: ${this._signerPublicKey.toString()}, `;
		result += `version: ${'0x'.concat(this._version.toString(16))}, `;
		result += `network: ${this._network.toString()}, `;
		result += `type: ${this._type.toString()}, `;
		result += `fee: ${this._fee.toString()}, `;
		result += `deadline: ${this._deadline.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		result.signature = this._signature.toJson();
		result.signerPublicKey = this._signerPublicKey.toJson();
		result.version = this._version;
		result.network = this._network.toJson();
		result.type = this._type.toJson();
		result.fee = this._fee.toJson();
		result.deadline = this._deadline.toJson();
		return result;
	}
}

class EmbeddedTransaction {
	static TYPE_HINTS = {
		signerPublicKey: 'pod:PublicKey',
		network: 'enum:NetworkType',
		type: 'enum:TransactionType'
	};

	constructor() {
		this._signerPublicKey = new PublicKey();
		this._version = 0;
		this._network = NetworkType.MAINNET;
		this._type = TransactionType.ACCOUNT_KEY_LINK;
		this._embeddedTransactionHeaderReserved_1 = 0; // reserved field
		this._entityBodyReserved_1 = 0; // reserved field
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get signerPublicKey() {
		return this._signerPublicKey;
	}

	set signerPublicKey(value) {
		this._signerPublicKey = value;
	}

	get version() {
		return this._version;
	}

	set version(value) {
		this._version = value;
	}

	get network() {
		return this._network;
	}

	set network(value) {
		this._network = value;
	}

	get type() {
		return this._type;
	}

	set type(value) {
		this._type = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += 4;
		size += 4;
		size += this.signerPublicKey.size;
		size += 4;
		size += 1;
		size += this.network.size;
		size += this.type.size;
		return size;
	}

	static _deserialize(view, instance) {
		const size = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		view.shrink(size - 4);
		const embeddedTransactionHeaderReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== embeddedTransactionHeaderReserved_1)
			throw RangeError(`Invalid value of reserved field (${embeddedTransactionHeaderReserved_1})`);
		const signerPublicKey = PublicKey.deserialize(view.buffer);
		view.shiftRight(signerPublicKey.size);
		const entityBodyReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== entityBodyReserved_1)
			throw RangeError(`Invalid value of reserved field (${entityBodyReserved_1})`);
		const version = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const network = NetworkType.deserializeAligned(view.buffer);
		view.shiftRight(network.size);
		const type = TransactionType.deserializeAligned(view.buffer);
		view.shiftRight(type.size);

		instance._signerPublicKey = signerPublicKey;
		instance._version = version;
		instance._network = network;
		instance._type = type;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		this._serialize(buffer);
		return buffer.storage;
	}

	_serialize(buffer) {
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.size, 4, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._embeddedTransactionHeaderReserved_1, 4, false));
		buffer.write(this._signerPublicKey.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._entityBodyReserved_1, 4, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._version, 1, false));
		buffer.write(this._network.serialize());
		buffer.write(this._type.serialize());
	}

	toString() {
		let result = '(';
		result += `signerPublicKey: ${this._signerPublicKey.toString()}, `;
		result += `version: ${'0x'.concat(this._version.toString(16))}, `;
		result += `network: ${this._network.toString()}, `;
		result += `type: ${this._type.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		result.signerPublicKey = this._signerPublicKey.toJson();
		result.version = this._version;
		result.network = this._network.toJson();
		result.type = this._type.toJson();
		return result;
	}
}

class ProofGamma extends _ByteArray_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
	static SIZE = 32;

	constructor(proofGamma = new Uint8Array(32)) {
		super(ProofGamma.SIZE, proofGamma);
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 32;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new ProofGamma(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 32));
	}

	serialize() {
		return this.bytes;
	}
}

class ProofVerificationHash extends _ByteArray_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
	static SIZE = 16;

	constructor(proofVerificationHash = new Uint8Array(16)) {
		super(ProofVerificationHash.SIZE, proofVerificationHash);
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 16;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new ProofVerificationHash(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 16));
	}

	serialize() {
		return this.bytes;
	}
}

class ProofScalar extends _ByteArray_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
	static SIZE = 32;

	constructor(proofScalar = new Uint8Array(32)) {
		super(ProofScalar.SIZE, proofScalar);
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 32;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new ProofScalar(new Uint8Array(byteArray.buffer, byteArray.byteOffset, 32));
	}

	serialize() {
		return this.bytes;
	}
}

class BlockType {
	static NEMESIS = new BlockType(32835);

	static NORMAL = new BlockType(33091);

	static IMPORTANCE = new BlockType(33347);

	constructor(value) {
		this.value = value;
	}

	static valueToKey(value) {
		const values = [
			32835, 33091, 33347
		];
		const keys = [
			'NEMESIS', 'NORMAL', 'IMPORTANCE'
		];

		const index = values.indexOf(value);
		if (-1 === index)
			throw RangeError(`invalid enum value ${value}`);

		return keys[index];
	}

	static fromValue(value) {
		return BlockType[this.valueToKey(value)];
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 2;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(byteArray, 2, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(byteArray, 2, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 2, false);
	}

	toString() {
		return `BlockType.${BlockType.valueToKey(this.value)}`;
	}

	toJson() {
		return this.value;
	}
}

class VrfProof {
	static TYPE_HINTS = {
		gamma: 'pod:ProofGamma',
		verificationHash: 'pod:ProofVerificationHash',
		scalar: 'pod:ProofScalar'
	};

	constructor() {
		this._gamma = new ProofGamma();
		this._verificationHash = new ProofVerificationHash();
		this._scalar = new ProofScalar();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get gamma() {
		return this._gamma;
	}

	set gamma(value) {
		this._gamma = value;
	}

	get verificationHash() {
		return this._verificationHash;
	}

	set verificationHash(value) {
		this._verificationHash = value;
	}

	get scalar() {
		return this._scalar;
	}

	set scalar(value) {
		this._scalar = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += this.gamma.size;
		size += this.verificationHash.size;
		size += this.scalar.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new VrfProof();

		const gamma = ProofGamma.deserialize(view.buffer);
		view.shiftRight(gamma.size);
		const verificationHash = ProofVerificationHash.deserialize(view.buffer);
		view.shiftRight(verificationHash.size);
		const scalar = ProofScalar.deserialize(view.buffer);
		view.shiftRight(scalar.size);

		instance._gamma = gamma;
		instance._verificationHash = verificationHash;
		instance._scalar = scalar;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		buffer.write(this._gamma.serialize());
		buffer.write(this._verificationHash.serialize());
		buffer.write(this._scalar.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += `gamma: ${this._gamma.toString()}, `;
		result += `verificationHash: ${this._verificationHash.toString()}, `;
		result += `scalar: ${this._scalar.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		result.gamma = this._gamma.toJson();
		result.verificationHash = this._verificationHash.toJson();
		result.scalar = this._scalar.toJson();
		return result;
	}
}

class Block {
	static TYPE_HINTS = {
		signature: 'pod:Signature',
		signerPublicKey: 'pod:PublicKey',
		network: 'enum:NetworkType',
		type: 'enum:BlockType',
		height: 'pod:Height',
		timestamp: 'pod:Timestamp',
		difficulty: 'pod:Difficulty',
		generationHashProof: 'struct:VrfProof',
		previousBlockHash: 'pod:Hash256',
		transactionsHash: 'pod:Hash256',
		receiptsHash: 'pod:Hash256',
		stateHash: 'pod:Hash256',
		beneficiaryAddress: 'pod:Address',
		feeMultiplier: 'pod:BlockFeeMultiplier'
	};

	constructor() {
		this._signature = new Signature();
		this._signerPublicKey = new PublicKey();
		this._version = 0;
		this._network = NetworkType.MAINNET;
		this._type = BlockType.NEMESIS;
		this._height = new Height();
		this._timestamp = new Timestamp();
		this._difficulty = new Difficulty();
		this._generationHashProof = new VrfProof();
		this._previousBlockHash = new Hash256();
		this._transactionsHash = new Hash256();
		this._receiptsHash = new Hash256();
		this._stateHash = new Hash256();
		this._beneficiaryAddress = new Address();
		this._feeMultiplier = new BlockFeeMultiplier();
		this._verifiableEntityHeaderReserved_1 = 0; // reserved field
		this._entityBodyReserved_1 = 0; // reserved field
	}

	sort() {
		this._generationHashProof.sort();
	}

	get signature() {
		return this._signature;
	}

	set signature(value) {
		this._signature = value;
	}

	get signerPublicKey() {
		return this._signerPublicKey;
	}

	set signerPublicKey(value) {
		this._signerPublicKey = value;
	}

	get version() {
		return this._version;
	}

	set version(value) {
		this._version = value;
	}

	get network() {
		return this._network;
	}

	set network(value) {
		this._network = value;
	}

	get type() {
		return this._type;
	}

	set type(value) {
		this._type = value;
	}

	get height() {
		return this._height;
	}

	set height(value) {
		this._height = value;
	}

	get timestamp() {
		return this._timestamp;
	}

	set timestamp(value) {
		this._timestamp = value;
	}

	get difficulty() {
		return this._difficulty;
	}

	set difficulty(value) {
		this._difficulty = value;
	}

	get generationHashProof() {
		return this._generationHashProof;
	}

	set generationHashProof(value) {
		this._generationHashProof = value;
	}

	get previousBlockHash() {
		return this._previousBlockHash;
	}

	set previousBlockHash(value) {
		this._previousBlockHash = value;
	}

	get transactionsHash() {
		return this._transactionsHash;
	}

	set transactionsHash(value) {
		this._transactionsHash = value;
	}

	get receiptsHash() {
		return this._receiptsHash;
	}

	set receiptsHash(value) {
		this._receiptsHash = value;
	}

	get stateHash() {
		return this._stateHash;
	}

	set stateHash(value) {
		this._stateHash = value;
	}

	get beneficiaryAddress() {
		return this._beneficiaryAddress;
	}

	set beneficiaryAddress(value) {
		this._beneficiaryAddress = value;
	}

	get feeMultiplier() {
		return this._feeMultiplier;
	}

	set feeMultiplier(value) {
		this._feeMultiplier = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += 4;
		size += 4;
		size += this.signature.size;
		size += this.signerPublicKey.size;
		size += 4;
		size += 1;
		size += this.network.size;
		size += this.type.size;
		size += this.height.size;
		size += this.timestamp.size;
		size += this.difficulty.size;
		size += this.generationHashProof.size;
		size += this.previousBlockHash.size;
		size += this.transactionsHash.size;
		size += this.receiptsHash.size;
		size += this.stateHash.size;
		size += this.beneficiaryAddress.size;
		size += this.feeMultiplier.size;
		return size;
	}

	static _deserialize(view, instance) {
		const size = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		view.shrink(size - 4);
		const verifiableEntityHeaderReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== verifiableEntityHeaderReserved_1)
			throw RangeError(`Invalid value of reserved field (${verifiableEntityHeaderReserved_1})`);
		const signature = Signature.deserialize(view.buffer);
		view.shiftRight(signature.size);
		const signerPublicKey = PublicKey.deserialize(view.buffer);
		view.shiftRight(signerPublicKey.size);
		const entityBodyReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== entityBodyReserved_1)
			throw RangeError(`Invalid value of reserved field (${entityBodyReserved_1})`);
		const version = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const network = NetworkType.deserializeAligned(view.buffer);
		view.shiftRight(network.size);
		const type = BlockType.deserializeAligned(view.buffer);
		view.shiftRight(type.size);
		const height = Height.deserializeAligned(view.buffer);
		view.shiftRight(height.size);
		const timestamp = Timestamp.deserializeAligned(view.buffer);
		view.shiftRight(timestamp.size);
		const difficulty = Difficulty.deserializeAligned(view.buffer);
		view.shiftRight(difficulty.size);
		const generationHashProof = VrfProof.deserialize(view.buffer);
		view.shiftRight(generationHashProof.size);
		const previousBlockHash = Hash256.deserialize(view.buffer);
		view.shiftRight(previousBlockHash.size);
		const transactionsHash = Hash256.deserialize(view.buffer);
		view.shiftRight(transactionsHash.size);
		const receiptsHash = Hash256.deserialize(view.buffer);
		view.shiftRight(receiptsHash.size);
		const stateHash = Hash256.deserialize(view.buffer);
		view.shiftRight(stateHash.size);
		const beneficiaryAddress = Address.deserialize(view.buffer);
		view.shiftRight(beneficiaryAddress.size);
		const feeMultiplier = BlockFeeMultiplier.deserializeAligned(view.buffer);
		view.shiftRight(feeMultiplier.size);

		instance._signature = signature;
		instance._signerPublicKey = signerPublicKey;
		instance._version = version;
		instance._network = network;
		instance._type = type;
		instance._height = height;
		instance._timestamp = timestamp;
		instance._difficulty = difficulty;
		instance._generationHashProof = generationHashProof;
		instance._previousBlockHash = previousBlockHash;
		instance._transactionsHash = transactionsHash;
		instance._receiptsHash = receiptsHash;
		instance._stateHash = stateHash;
		instance._beneficiaryAddress = beneficiaryAddress;
		instance._feeMultiplier = feeMultiplier;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		this._serialize(buffer);
		return buffer.storage;
	}

	_serialize(buffer) {
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.size, 4, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._verifiableEntityHeaderReserved_1, 4, false));
		buffer.write(this._signature.serialize());
		buffer.write(this._signerPublicKey.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._entityBodyReserved_1, 4, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._version, 1, false));
		buffer.write(this._network.serialize());
		buffer.write(this._type.serialize());
		buffer.write(this._height.serialize());
		buffer.write(this._timestamp.serialize());
		buffer.write(this._difficulty.serialize());
		buffer.write(this._generationHashProof.serialize());
		buffer.write(this._previousBlockHash.serialize());
		buffer.write(this._transactionsHash.serialize());
		buffer.write(this._receiptsHash.serialize());
		buffer.write(this._stateHash.serialize());
		buffer.write(this._beneficiaryAddress.serialize());
		buffer.write(this._feeMultiplier.serialize());
	}

	toString() {
		let result = '(';
		result += `signature: ${this._signature.toString()}, `;
		result += `signerPublicKey: ${this._signerPublicKey.toString()}, `;
		result += `version: ${'0x'.concat(this._version.toString(16))}, `;
		result += `network: ${this._network.toString()}, `;
		result += `type: ${this._type.toString()}, `;
		result += `height: ${this._height.toString()}, `;
		result += `timestamp: ${this._timestamp.toString()}, `;
		result += `difficulty: ${this._difficulty.toString()}, `;
		result += `generationHashProof: ${this._generationHashProof.toString()}, `;
		result += `previousBlockHash: ${this._previousBlockHash.toString()}, `;
		result += `transactionsHash: ${this._transactionsHash.toString()}, `;
		result += `receiptsHash: ${this._receiptsHash.toString()}, `;
		result += `stateHash: ${this._stateHash.toString()}, `;
		result += `beneficiaryAddress: ${this._beneficiaryAddress.toString()}, `;
		result += `feeMultiplier: ${this._feeMultiplier.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		result.signature = this._signature.toJson();
		result.signerPublicKey = this._signerPublicKey.toJson();
		result.version = this._version;
		result.network = this._network.toJson();
		result.type = this._type.toJson();
		result.height = this._height.toJson();
		result.timestamp = this._timestamp.toJson();
		result.difficulty = this._difficulty.toJson();
		result.generationHashProof = this._generationHashProof.toJson();
		result.previousBlockHash = this._previousBlockHash.toJson();
		result.transactionsHash = this._transactionsHash.toJson();
		result.receiptsHash = this._receiptsHash.toJson();
		result.stateHash = this._stateHash.toJson();
		result.beneficiaryAddress = this._beneficiaryAddress.toJson();
		result.feeMultiplier = this._feeMultiplier.toJson();
		return result;
	}
}

class NemesisBlockV1 extends Block {
	static BLOCK_VERSION = 1;

	static BLOCK_TYPE = BlockType.NEMESIS;

	static TYPE_HINTS = {
		...Block.TYPE_HINTS,
		totalVotingBalance: 'pod:Amount',
		previousImportanceBlockHash: 'pod:Hash256',
		transactions: 'array[Transaction]'
	};

	constructor() {
		super();
		this._version = NemesisBlockV1.BLOCK_VERSION;
		this._type = NemesisBlockV1.BLOCK_TYPE;
		this._votingEligibleAccountsCount = 0;
		this._harvestingEligibleAccountsCount = 0n;
		this._totalVotingBalance = new Amount();
		this._previousImportanceBlockHash = new Hash256();
		this._transactions = [];
	}

	sort() {
		this._generationHashProof.sort();
	}

	get votingEligibleAccountsCount() {
		return this._votingEligibleAccountsCount;
	}

	set votingEligibleAccountsCount(value) {
		this._votingEligibleAccountsCount = value;
	}

	get harvestingEligibleAccountsCount() {
		return this._harvestingEligibleAccountsCount;
	}

	set harvestingEligibleAccountsCount(value) {
		this._harvestingEligibleAccountsCount = value;
	}

	get totalVotingBalance() {
		return this._totalVotingBalance;
	}

	set totalVotingBalance(value) {
		this._totalVotingBalance = value;
	}

	get previousImportanceBlockHash() {
		return this._previousImportanceBlockHash;
	}

	set previousImportanceBlockHash(value) {
		this._previousImportanceBlockHash = value;
	}

	get transactions() {
		return this._transactions;
	}

	set transactions(value) {
		this._transactions = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += 4;
		size += 8;
		size += this.totalVotingBalance.size;
		size += this.previousImportanceBlockHash.size;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.transactions, 8, true);
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new NemesisBlockV1();

		Block._deserialize(view, instance);
		const votingEligibleAccountsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		const harvestingEligibleAccountsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const totalVotingBalance = Amount.deserializeAligned(view.buffer);
		view.shiftRight(totalVotingBalance.size);
		const previousImportanceBlockHash = Hash256.deserialize(view.buffer);
		view.shiftRight(previousImportanceBlockHash.size);
		const transactions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readVariableSizeElements(view.buffer, TransactionFactory, 8, true);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(transactions, 8, true));

		instance._votingEligibleAccountsCount = votingEligibleAccountsCount;
		instance._harvestingEligibleAccountsCount = harvestingEligibleAccountsCount;
		instance._totalVotingBalance = totalVotingBalance;
		instance._previousImportanceBlockHash = previousImportanceBlockHash;
		instance._transactions = transactions;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._votingEligibleAccountsCount, 4, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._harvestingEligibleAccountsCount, 8, false));
		buffer.write(this._totalVotingBalance.serialize());
		buffer.write(this._previousImportanceBlockHash.serialize());
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeVariableSizeElements(buffer, this._transactions, 8, true);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `votingEligibleAccountsCount: ${'0x'.concat(this._votingEligibleAccountsCount.toString(16))}, `;
		result += `harvestingEligibleAccountsCount: ${'0x'.concat(this._harvestingEligibleAccountsCount.toString(16))}, `;
		result += `totalVotingBalance: ${this._totalVotingBalance.toString()}, `;
		result += `previousImportanceBlockHash: ${this._previousImportanceBlockHash.toString()}, `;
		result += `transactions: [${this._transactions.map(e => e.toString()).join(',')}], `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.votingEligibleAccountsCount = this._votingEligibleAccountsCount;
		result.harvestingEligibleAccountsCount = this._harvestingEligibleAccountsCount.toString();
		result.totalVotingBalance = this._totalVotingBalance.toJson();
		result.previousImportanceBlockHash = this._previousImportanceBlockHash.toJson();
		result.transactions = this._transactions.map(e => e.toJson());
		return result;
	}
}

class NormalBlockV1 extends Block {
	static BLOCK_VERSION = 1;

	static BLOCK_TYPE = BlockType.NORMAL;

	static TYPE_HINTS = {
		...Block.TYPE_HINTS,
		transactions: 'array[Transaction]'
	};

	constructor() {
		super();
		this._version = NormalBlockV1.BLOCK_VERSION;
		this._type = NormalBlockV1.BLOCK_TYPE;
		this._transactions = [];
		this._blockHeaderReserved_1 = 0; // reserved field
	}

	sort() {
		this._generationHashProof.sort();
	}

	get transactions() {
		return this._transactions;
	}

	set transactions(value) {
		this._transactions = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.transactions, 8, true);
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new NormalBlockV1();

		Block._deserialize(view, instance);
		const blockHeaderReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== blockHeaderReserved_1)
			throw RangeError(`Invalid value of reserved field (${blockHeaderReserved_1})`);
		const transactions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readVariableSizeElements(view.buffer, TransactionFactory, 8, true);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(transactions, 8, true));

		instance._transactions = transactions;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._blockHeaderReserved_1, 4, false));
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeVariableSizeElements(buffer, this._transactions, 8, true);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `transactions: [${this._transactions.map(e => e.toString()).join(',')}], `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.transactions = this._transactions.map(e => e.toJson());
		return result;
	}
}

class ImportanceBlockV1 extends Block {
	static BLOCK_VERSION = 1;

	static BLOCK_TYPE = BlockType.IMPORTANCE;

	static TYPE_HINTS = {
		...Block.TYPE_HINTS,
		totalVotingBalance: 'pod:Amount',
		previousImportanceBlockHash: 'pod:Hash256',
		transactions: 'array[Transaction]'
	};

	constructor() {
		super();
		this._version = ImportanceBlockV1.BLOCK_VERSION;
		this._type = ImportanceBlockV1.BLOCK_TYPE;
		this._votingEligibleAccountsCount = 0;
		this._harvestingEligibleAccountsCount = 0n;
		this._totalVotingBalance = new Amount();
		this._previousImportanceBlockHash = new Hash256();
		this._transactions = [];
	}

	sort() {
		this._generationHashProof.sort();
	}

	get votingEligibleAccountsCount() {
		return this._votingEligibleAccountsCount;
	}

	set votingEligibleAccountsCount(value) {
		this._votingEligibleAccountsCount = value;
	}

	get harvestingEligibleAccountsCount() {
		return this._harvestingEligibleAccountsCount;
	}

	set harvestingEligibleAccountsCount(value) {
		this._harvestingEligibleAccountsCount = value;
	}

	get totalVotingBalance() {
		return this._totalVotingBalance;
	}

	set totalVotingBalance(value) {
		this._totalVotingBalance = value;
	}

	get previousImportanceBlockHash() {
		return this._previousImportanceBlockHash;
	}

	set previousImportanceBlockHash(value) {
		this._previousImportanceBlockHash = value;
	}

	get transactions() {
		return this._transactions;
	}

	set transactions(value) {
		this._transactions = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += 4;
		size += 8;
		size += this.totalVotingBalance.size;
		size += this.previousImportanceBlockHash.size;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.transactions, 8, true);
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new ImportanceBlockV1();

		Block._deserialize(view, instance);
		const votingEligibleAccountsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		const harvestingEligibleAccountsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const totalVotingBalance = Amount.deserializeAligned(view.buffer);
		view.shiftRight(totalVotingBalance.size);
		const previousImportanceBlockHash = Hash256.deserialize(view.buffer);
		view.shiftRight(previousImportanceBlockHash.size);
		const transactions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readVariableSizeElements(view.buffer, TransactionFactory, 8, true);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(transactions, 8, true));

		instance._votingEligibleAccountsCount = votingEligibleAccountsCount;
		instance._harvestingEligibleAccountsCount = harvestingEligibleAccountsCount;
		instance._totalVotingBalance = totalVotingBalance;
		instance._previousImportanceBlockHash = previousImportanceBlockHash;
		instance._transactions = transactions;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._votingEligibleAccountsCount, 4, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._harvestingEligibleAccountsCount, 8, false));
		buffer.write(this._totalVotingBalance.serialize());
		buffer.write(this._previousImportanceBlockHash.serialize());
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeVariableSizeElements(buffer, this._transactions, 8, true);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `votingEligibleAccountsCount: ${'0x'.concat(this._votingEligibleAccountsCount.toString(16))}, `;
		result += `harvestingEligibleAccountsCount: ${'0x'.concat(this._harvestingEligibleAccountsCount.toString(16))}, `;
		result += `totalVotingBalance: ${this._totalVotingBalance.toString()}, `;
		result += `previousImportanceBlockHash: ${this._previousImportanceBlockHash.toString()}, `;
		result += `transactions: [${this._transactions.map(e => e.toString()).join(',')}], `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.votingEligibleAccountsCount = this._votingEligibleAccountsCount;
		result.harvestingEligibleAccountsCount = this._harvestingEligibleAccountsCount.toString();
		result.totalVotingBalance = this._totalVotingBalance.toJson();
		result.previousImportanceBlockHash = this._previousImportanceBlockHash.toJson();
		result.transactions = this._transactions.map(e => e.toJson());
		return result;
	}
}

class FinalizationRound {
	static TYPE_HINTS = {
		epoch: 'pod:FinalizationEpoch',
		point: 'pod:FinalizationPoint'
	};

	constructor() {
		this._epoch = new FinalizationEpoch();
		this._point = new FinalizationPoint();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get epoch() {
		return this._epoch;
	}

	set epoch(value) {
		this._epoch = value;
	}

	get point() {
		return this._point;
	}

	set point(value) {
		this._point = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += this.epoch.size;
		size += this.point.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new FinalizationRound();

		const epoch = FinalizationEpoch.deserialize(view.buffer);
		view.shiftRight(epoch.size);
		const point = FinalizationPoint.deserialize(view.buffer);
		view.shiftRight(point.size);

		instance._epoch = epoch;
		instance._point = point;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		buffer.write(this._epoch.serialize());
		buffer.write(this._point.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += `epoch: ${this._epoch.toString()}, `;
		result += `point: ${this._point.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		result.epoch = this._epoch.toJson();
		result.point = this._point.toJson();
		return result;
	}
}

class FinalizedBlockHeader {
	static TYPE_HINTS = {
		round: 'struct:FinalizationRound',
		height: 'pod:Height',
		hash: 'pod:Hash256'
	};

	constructor() {
		this._round = new FinalizationRound();
		this._height = new Height();
		this._hash = new Hash256();
	}

	sort() {
		this._round.sort();
	}

	get round() {
		return this._round;
	}

	set round(value) {
		this._round = value;
	}

	get height() {
		return this._height;
	}

	set height(value) {
		this._height = value;
	}

	get hash() {
		return this._hash;
	}

	set hash(value) {
		this._hash = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += this.round.size;
		size += this.height.size;
		size += this.hash.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new FinalizedBlockHeader();

		const round = FinalizationRound.deserialize(view.buffer);
		view.shiftRight(round.size);
		const height = Height.deserialize(view.buffer);
		view.shiftRight(height.size);
		const hash = Hash256.deserialize(view.buffer);
		view.shiftRight(hash.size);

		instance._round = round;
		instance._height = height;
		instance._hash = hash;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		buffer.write(this._round.serialize());
		buffer.write(this._height.serialize());
		buffer.write(this._hash.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += `round: ${this._round.toString()}, `;
		result += `height: ${this._height.toString()}, `;
		result += `hash: ${this._hash.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		result.round = this._round.toJson();
		result.height = this._height.toJson();
		result.hash = this._hash.toJson();
		return result;
	}
}

class ReceiptType {
	static MOSAIC_RENTAL_FEE = new ReceiptType(4685);

	static NAMESPACE_RENTAL_FEE = new ReceiptType(4942);

	static HARVEST_FEE = new ReceiptType(8515);

	static LOCK_HASH_COMPLETED = new ReceiptType(8776);

	static LOCK_HASH_EXPIRED = new ReceiptType(9032);

	static LOCK_SECRET_COMPLETED = new ReceiptType(8786);

	static LOCK_SECRET_EXPIRED = new ReceiptType(9042);

	static LOCK_HASH_CREATED = new ReceiptType(12616);

	static LOCK_SECRET_CREATED = new ReceiptType(12626);

	static MOSAIC_EXPIRED = new ReceiptType(16717);

	static NAMESPACE_EXPIRED = new ReceiptType(16718);

	static NAMESPACE_DELETED = new ReceiptType(16974);

	static INFLATION = new ReceiptType(20803);

	static TRANSACTION_GROUP = new ReceiptType(57667);

	static ADDRESS_ALIAS_RESOLUTION = new ReceiptType(61763);

	static MOSAIC_ALIAS_RESOLUTION = new ReceiptType(62019);

	constructor(value) {
		this.value = value;
	}

	static valueToKey(value) {
		const values = [
			4685, 4942, 8515, 8776, 9032, 8786, 9042, 12616, 12626, 16717, 16718, 16974, 20803, 57667, 61763, 62019
		];
		const keys = [
			'MOSAIC_RENTAL_FEE', 'NAMESPACE_RENTAL_FEE', 'HARVEST_FEE', 'LOCK_HASH_COMPLETED', 'LOCK_HASH_EXPIRED', 'LOCK_SECRET_COMPLETED',
			'LOCK_SECRET_EXPIRED', 'LOCK_HASH_CREATED', 'LOCK_SECRET_CREATED', 'MOSAIC_EXPIRED', 'NAMESPACE_EXPIRED', 'NAMESPACE_DELETED',
			'INFLATION', 'TRANSACTION_GROUP', 'ADDRESS_ALIAS_RESOLUTION', 'MOSAIC_ALIAS_RESOLUTION'
		];

		const index = values.indexOf(value);
		if (-1 === index)
			throw RangeError(`invalid enum value ${value}`);

		return keys[index];
	}

	static fromValue(value) {
		return ReceiptType[this.valueToKey(value)];
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 2;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(byteArray, 2, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(byteArray, 2, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 2, false);
	}

	toString() {
		return `ReceiptType.${ReceiptType.valueToKey(this.value)}`;
	}

	toJson() {
		return this.value;
	}
}

class Receipt {
	static TYPE_HINTS = {
		type: 'enum:ReceiptType'
	};

	constructor() {
		this._version = 0;
		this._type = ReceiptType.MOSAIC_RENTAL_FEE;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get version() {
		return this._version;
	}

	set version(value) {
		this._version = value;
	}

	get type() {
		return this._type;
	}

	set type(value) {
		this._type = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += 4;
		size += 2;
		size += this.type.size;
		return size;
	}

	static _deserialize(view, instance) {
		const size = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(view.buffer, 4, false);
		view.shiftRight(4);
		view.shrink(size - 4);
		const version = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(view.buffer, 2, false);
		view.shiftRight(2);
		const type = ReceiptType.deserialize(view.buffer);
		view.shiftRight(type.size);

		instance._version = version;
		instance._type = type;
	}

	static _deserializeAligned(view, instance) {
		const size = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		view.shrink(size - 4);
		const version = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 2, false);
		view.shiftRight(2);
		const type = ReceiptType.deserializeAligned(view.buffer);
		view.shiftRight(type.size);

		instance._version = version;
		instance._type = type;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		this._serialize(buffer);
		return buffer.storage;
	}

	_serialize(buffer) {
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.size, 4, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._version, 2, false));
		buffer.write(this._type.serialize());
	}

	toString() {
		let result = '(';
		result += `version: ${'0x'.concat(this._version.toString(16))}, `;
		result += `type: ${this._type.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		result.version = this._version;
		result.type = this._type.toJson();
		return result;
	}
}

class HarvestFeeReceipt extends Receipt {
	static RECEIPT_TYPE = ReceiptType.HARVEST_FEE;

	static TYPE_HINTS = {
		...Receipt.TYPE_HINTS,
		mosaic: 'struct:Mosaic',
		targetAddress: 'pod:Address'
	};

	constructor() {
		super();
		this._type = HarvestFeeReceipt.RECEIPT_TYPE;
		this._mosaic = new Mosaic();
		this._targetAddress = new Address();
	}

	sort() {
		this._mosaic.sort();
	}

	get mosaic() {
		return this._mosaic;
	}

	set mosaic(value) {
		this._mosaic = value;
	}

	get targetAddress() {
		return this._targetAddress;
	}

	set targetAddress(value) {
		this._targetAddress = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.mosaic.size;
		size += this.targetAddress.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new HarvestFeeReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const targetAddress = Address.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);

		instance._mosaic = mosaic;
		instance._targetAddress = targetAddress;
		return instance;
	}

	static deserializeAligned(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new HarvestFeeReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const targetAddress = Address.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);

		instance._mosaic = mosaic;
		instance._targetAddress = targetAddress;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._mosaic.serialize());
		buffer.write(this._targetAddress.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `mosaic: ${this._mosaic.toString()}, `;
		result += `targetAddress: ${this._targetAddress.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.mosaic = this._mosaic.toJson();
		result.targetAddress = this._targetAddress.toJson();
		return result;
	}
}

class InflationReceipt extends Receipt {
	static RECEIPT_TYPE = ReceiptType.INFLATION;

	static TYPE_HINTS = {
		...Receipt.TYPE_HINTS,
		mosaic: 'struct:Mosaic'
	};

	constructor() {
		super();
		this._type = InflationReceipt.RECEIPT_TYPE;
		this._mosaic = new Mosaic();
	}

	sort() {
		this._mosaic.sort();
	}

	get mosaic() {
		return this._mosaic;
	}

	set mosaic(value) {
		this._mosaic = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.mosaic.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new InflationReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);

		instance._mosaic = mosaic;
		return instance;
	}

	static deserializeAligned(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new InflationReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);

		instance._mosaic = mosaic;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._mosaic.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `mosaic: ${this._mosaic.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.mosaic = this._mosaic.toJson();
		return result;
	}
}

class LockHashCreatedFeeReceipt extends Receipt {
	static RECEIPT_TYPE = ReceiptType.LOCK_HASH_CREATED;

	static TYPE_HINTS = {
		...Receipt.TYPE_HINTS,
		mosaic: 'struct:Mosaic',
		targetAddress: 'pod:Address'
	};

	constructor() {
		super();
		this._type = LockHashCreatedFeeReceipt.RECEIPT_TYPE;
		this._mosaic = new Mosaic();
		this._targetAddress = new Address();
	}

	sort() {
		this._mosaic.sort();
	}

	get mosaic() {
		return this._mosaic;
	}

	set mosaic(value) {
		this._mosaic = value;
	}

	get targetAddress() {
		return this._targetAddress;
	}

	set targetAddress(value) {
		this._targetAddress = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.mosaic.size;
		size += this.targetAddress.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new LockHashCreatedFeeReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const targetAddress = Address.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);

		instance._mosaic = mosaic;
		instance._targetAddress = targetAddress;
		return instance;
	}

	static deserializeAligned(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new LockHashCreatedFeeReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const targetAddress = Address.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);

		instance._mosaic = mosaic;
		instance._targetAddress = targetAddress;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._mosaic.serialize());
		buffer.write(this._targetAddress.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `mosaic: ${this._mosaic.toString()}, `;
		result += `targetAddress: ${this._targetAddress.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.mosaic = this._mosaic.toJson();
		result.targetAddress = this._targetAddress.toJson();
		return result;
	}
}

class LockHashCompletedFeeReceipt extends Receipt {
	static RECEIPT_TYPE = ReceiptType.LOCK_HASH_COMPLETED;

	static TYPE_HINTS = {
		...Receipt.TYPE_HINTS,
		mosaic: 'struct:Mosaic',
		targetAddress: 'pod:Address'
	};

	constructor() {
		super();
		this._type = LockHashCompletedFeeReceipt.RECEIPT_TYPE;
		this._mosaic = new Mosaic();
		this._targetAddress = new Address();
	}

	sort() {
		this._mosaic.sort();
	}

	get mosaic() {
		return this._mosaic;
	}

	set mosaic(value) {
		this._mosaic = value;
	}

	get targetAddress() {
		return this._targetAddress;
	}

	set targetAddress(value) {
		this._targetAddress = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.mosaic.size;
		size += this.targetAddress.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new LockHashCompletedFeeReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const targetAddress = Address.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);

		instance._mosaic = mosaic;
		instance._targetAddress = targetAddress;
		return instance;
	}

	static deserializeAligned(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new LockHashCompletedFeeReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const targetAddress = Address.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);

		instance._mosaic = mosaic;
		instance._targetAddress = targetAddress;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._mosaic.serialize());
		buffer.write(this._targetAddress.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `mosaic: ${this._mosaic.toString()}, `;
		result += `targetAddress: ${this._targetAddress.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.mosaic = this._mosaic.toJson();
		result.targetAddress = this._targetAddress.toJson();
		return result;
	}
}

class LockHashExpiredFeeReceipt extends Receipt {
	static RECEIPT_TYPE = ReceiptType.LOCK_HASH_EXPIRED;

	static TYPE_HINTS = {
		...Receipt.TYPE_HINTS,
		mosaic: 'struct:Mosaic',
		targetAddress: 'pod:Address'
	};

	constructor() {
		super();
		this._type = LockHashExpiredFeeReceipt.RECEIPT_TYPE;
		this._mosaic = new Mosaic();
		this._targetAddress = new Address();
	}

	sort() {
		this._mosaic.sort();
	}

	get mosaic() {
		return this._mosaic;
	}

	set mosaic(value) {
		this._mosaic = value;
	}

	get targetAddress() {
		return this._targetAddress;
	}

	set targetAddress(value) {
		this._targetAddress = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.mosaic.size;
		size += this.targetAddress.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new LockHashExpiredFeeReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const targetAddress = Address.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);

		instance._mosaic = mosaic;
		instance._targetAddress = targetAddress;
		return instance;
	}

	static deserializeAligned(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new LockHashExpiredFeeReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const targetAddress = Address.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);

		instance._mosaic = mosaic;
		instance._targetAddress = targetAddress;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._mosaic.serialize());
		buffer.write(this._targetAddress.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `mosaic: ${this._mosaic.toString()}, `;
		result += `targetAddress: ${this._targetAddress.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.mosaic = this._mosaic.toJson();
		result.targetAddress = this._targetAddress.toJson();
		return result;
	}
}

class LockSecretCreatedFeeReceipt extends Receipt {
	static RECEIPT_TYPE = ReceiptType.LOCK_SECRET_CREATED;

	static TYPE_HINTS = {
		...Receipt.TYPE_HINTS,
		mosaic: 'struct:Mosaic',
		targetAddress: 'pod:Address'
	};

	constructor() {
		super();
		this._type = LockSecretCreatedFeeReceipt.RECEIPT_TYPE;
		this._mosaic = new Mosaic();
		this._targetAddress = new Address();
	}

	sort() {
		this._mosaic.sort();
	}

	get mosaic() {
		return this._mosaic;
	}

	set mosaic(value) {
		this._mosaic = value;
	}

	get targetAddress() {
		return this._targetAddress;
	}

	set targetAddress(value) {
		this._targetAddress = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.mosaic.size;
		size += this.targetAddress.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new LockSecretCreatedFeeReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const targetAddress = Address.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);

		instance._mosaic = mosaic;
		instance._targetAddress = targetAddress;
		return instance;
	}

	static deserializeAligned(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new LockSecretCreatedFeeReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const targetAddress = Address.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);

		instance._mosaic = mosaic;
		instance._targetAddress = targetAddress;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._mosaic.serialize());
		buffer.write(this._targetAddress.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `mosaic: ${this._mosaic.toString()}, `;
		result += `targetAddress: ${this._targetAddress.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.mosaic = this._mosaic.toJson();
		result.targetAddress = this._targetAddress.toJson();
		return result;
	}
}

class LockSecretCompletedFeeReceipt extends Receipt {
	static RECEIPT_TYPE = ReceiptType.LOCK_SECRET_COMPLETED;

	static TYPE_HINTS = {
		...Receipt.TYPE_HINTS,
		mosaic: 'struct:Mosaic',
		targetAddress: 'pod:Address'
	};

	constructor() {
		super();
		this._type = LockSecretCompletedFeeReceipt.RECEIPT_TYPE;
		this._mosaic = new Mosaic();
		this._targetAddress = new Address();
	}

	sort() {
		this._mosaic.sort();
	}

	get mosaic() {
		return this._mosaic;
	}

	set mosaic(value) {
		this._mosaic = value;
	}

	get targetAddress() {
		return this._targetAddress;
	}

	set targetAddress(value) {
		this._targetAddress = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.mosaic.size;
		size += this.targetAddress.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new LockSecretCompletedFeeReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const targetAddress = Address.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);

		instance._mosaic = mosaic;
		instance._targetAddress = targetAddress;
		return instance;
	}

	static deserializeAligned(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new LockSecretCompletedFeeReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const targetAddress = Address.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);

		instance._mosaic = mosaic;
		instance._targetAddress = targetAddress;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._mosaic.serialize());
		buffer.write(this._targetAddress.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `mosaic: ${this._mosaic.toString()}, `;
		result += `targetAddress: ${this._targetAddress.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.mosaic = this._mosaic.toJson();
		result.targetAddress = this._targetAddress.toJson();
		return result;
	}
}

class LockSecretExpiredFeeReceipt extends Receipt {
	static RECEIPT_TYPE = ReceiptType.LOCK_SECRET_EXPIRED;

	static TYPE_HINTS = {
		...Receipt.TYPE_HINTS,
		mosaic: 'struct:Mosaic',
		targetAddress: 'pod:Address'
	};

	constructor() {
		super();
		this._type = LockSecretExpiredFeeReceipt.RECEIPT_TYPE;
		this._mosaic = new Mosaic();
		this._targetAddress = new Address();
	}

	sort() {
		this._mosaic.sort();
	}

	get mosaic() {
		return this._mosaic;
	}

	set mosaic(value) {
		this._mosaic = value;
	}

	get targetAddress() {
		return this._targetAddress;
	}

	set targetAddress(value) {
		this._targetAddress = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.mosaic.size;
		size += this.targetAddress.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new LockSecretExpiredFeeReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const targetAddress = Address.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);

		instance._mosaic = mosaic;
		instance._targetAddress = targetAddress;
		return instance;
	}

	static deserializeAligned(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new LockSecretExpiredFeeReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const targetAddress = Address.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);

		instance._mosaic = mosaic;
		instance._targetAddress = targetAddress;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._mosaic.serialize());
		buffer.write(this._targetAddress.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `mosaic: ${this._mosaic.toString()}, `;
		result += `targetAddress: ${this._targetAddress.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.mosaic = this._mosaic.toJson();
		result.targetAddress = this._targetAddress.toJson();
		return result;
	}
}

class MosaicExpiredReceipt extends Receipt {
	static RECEIPT_TYPE = ReceiptType.MOSAIC_EXPIRED;

	static TYPE_HINTS = {
		...Receipt.TYPE_HINTS,
		artifactId: 'pod:MosaicId'
	};

	constructor() {
		super();
		this._type = MosaicExpiredReceipt.RECEIPT_TYPE;
		this._artifactId = new MosaicId();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get artifactId() {
		return this._artifactId;
	}

	set artifactId(value) {
		this._artifactId = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.artifactId.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new MosaicExpiredReceipt();

		Receipt._deserialize(view, instance);
		const artifactId = MosaicId.deserialize(view.buffer);
		view.shiftRight(artifactId.size);

		instance._artifactId = artifactId;
		return instance;
	}

	static deserializeAligned(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new MosaicExpiredReceipt();

		Receipt._deserialize(view, instance);
		const artifactId = MosaicId.deserializeAligned(view.buffer);
		view.shiftRight(artifactId.size);

		instance._artifactId = artifactId;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._artifactId.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `artifactId: ${this._artifactId.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.artifactId = this._artifactId.toJson();
		return result;
	}
}

class MosaicRentalFeeReceipt extends Receipt {
	static RECEIPT_TYPE = ReceiptType.MOSAIC_RENTAL_FEE;

	static TYPE_HINTS = {
		...Receipt.TYPE_HINTS,
		mosaic: 'struct:Mosaic',
		senderAddress: 'pod:Address',
		recipientAddress: 'pod:Address'
	};

	constructor() {
		super();
		this._type = MosaicRentalFeeReceipt.RECEIPT_TYPE;
		this._mosaic = new Mosaic();
		this._senderAddress = new Address();
		this._recipientAddress = new Address();
	}

	sort() {
		this._mosaic.sort();
	}

	get mosaic() {
		return this._mosaic;
	}

	set mosaic(value) {
		this._mosaic = value;
	}

	get senderAddress() {
		return this._senderAddress;
	}

	set senderAddress(value) {
		this._senderAddress = value;
	}

	get recipientAddress() {
		return this._recipientAddress;
	}

	set recipientAddress(value) {
		this._recipientAddress = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.mosaic.size;
		size += this.senderAddress.size;
		size += this.recipientAddress.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new MosaicRentalFeeReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const senderAddress = Address.deserialize(view.buffer);
		view.shiftRight(senderAddress.size);
		const recipientAddress = Address.deserialize(view.buffer);
		view.shiftRight(recipientAddress.size);

		instance._mosaic = mosaic;
		instance._senderAddress = senderAddress;
		instance._recipientAddress = recipientAddress;
		return instance;
	}

	static deserializeAligned(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new MosaicRentalFeeReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const senderAddress = Address.deserialize(view.buffer);
		view.shiftRight(senderAddress.size);
		const recipientAddress = Address.deserialize(view.buffer);
		view.shiftRight(recipientAddress.size);

		instance._mosaic = mosaic;
		instance._senderAddress = senderAddress;
		instance._recipientAddress = recipientAddress;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._mosaic.serialize());
		buffer.write(this._senderAddress.serialize());
		buffer.write(this._recipientAddress.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `mosaic: ${this._mosaic.toString()}, `;
		result += `senderAddress: ${this._senderAddress.toString()}, `;
		result += `recipientAddress: ${this._recipientAddress.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.mosaic = this._mosaic.toJson();
		result.senderAddress = this._senderAddress.toJson();
		result.recipientAddress = this._recipientAddress.toJson();
		return result;
	}
}

class NamespaceId extends _BaseValue_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
	static SIZE = 8;

	constructor(namespaceId = 0n) {
		super(NamespaceId.SIZE, namespaceId);
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new NamespaceId(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigIntUnaligned(byteArray, 8, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return new NamespaceId(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(byteArray, 8, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 8, false);
	}
}

class NamespaceRegistrationType {
	static ROOT = new NamespaceRegistrationType(0);

	static CHILD = new NamespaceRegistrationType(1);

	constructor(value) {
		this.value = value;
	}

	static valueToKey(value) {
		const values = [
			0, 1
		];
		const keys = [
			'ROOT', 'CHILD'
		];

		const index = values.indexOf(value);
		if (-1 === index)
			throw RangeError(`invalid enum value ${value}`);

		return keys[index];
	}

	static fromValue(value) {
		return NamespaceRegistrationType[this.valueToKey(value)];
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 1;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(byteArray, 1, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(byteArray, 1, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 1, false);
	}

	toString() {
		return `NamespaceRegistrationType.${NamespaceRegistrationType.valueToKey(this.value)}`;
	}

	toJson() {
		return this.value;
	}
}

class AliasAction {
	static UNLINK = new AliasAction(0);

	static LINK = new AliasAction(1);

	constructor(value) {
		this.value = value;
	}

	static valueToKey(value) {
		const values = [
			0, 1
		];
		const keys = [
			'UNLINK', 'LINK'
		];

		const index = values.indexOf(value);
		if (-1 === index)
			throw RangeError(`invalid enum value ${value}`);

		return keys[index];
	}

	static fromValue(value) {
		return AliasAction[this.valueToKey(value)];
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 1;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(byteArray, 1, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(byteArray, 1, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 1, false);
	}

	toString() {
		return `AliasAction.${AliasAction.valueToKey(this.value)}`;
	}

	toJson() {
		return this.value;
	}
}

class NamespaceExpiredReceipt extends Receipt {
	static RECEIPT_TYPE = ReceiptType.NAMESPACE_EXPIRED;

	static TYPE_HINTS = {
		...Receipt.TYPE_HINTS,
		artifactId: 'pod:NamespaceId'
	};

	constructor() {
		super();
		this._type = NamespaceExpiredReceipt.RECEIPT_TYPE;
		this._artifactId = new NamespaceId();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get artifactId() {
		return this._artifactId;
	}

	set artifactId(value) {
		this._artifactId = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.artifactId.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new NamespaceExpiredReceipt();

		Receipt._deserialize(view, instance);
		const artifactId = NamespaceId.deserialize(view.buffer);
		view.shiftRight(artifactId.size);

		instance._artifactId = artifactId;
		return instance;
	}

	static deserializeAligned(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new NamespaceExpiredReceipt();

		Receipt._deserialize(view, instance);
		const artifactId = NamespaceId.deserializeAligned(view.buffer);
		view.shiftRight(artifactId.size);

		instance._artifactId = artifactId;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._artifactId.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `artifactId: ${this._artifactId.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.artifactId = this._artifactId.toJson();
		return result;
	}
}

class NamespaceDeletedReceipt extends Receipt {
	static RECEIPT_TYPE = ReceiptType.NAMESPACE_DELETED;

	static TYPE_HINTS = {
		...Receipt.TYPE_HINTS,
		artifactId: 'pod:NamespaceId'
	};

	constructor() {
		super();
		this._type = NamespaceDeletedReceipt.RECEIPT_TYPE;
		this._artifactId = new NamespaceId();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get artifactId() {
		return this._artifactId;
	}

	set artifactId(value) {
		this._artifactId = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.artifactId.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new NamespaceDeletedReceipt();

		Receipt._deserialize(view, instance);
		const artifactId = NamespaceId.deserialize(view.buffer);
		view.shiftRight(artifactId.size);

		instance._artifactId = artifactId;
		return instance;
	}

	static deserializeAligned(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new NamespaceDeletedReceipt();

		Receipt._deserialize(view, instance);
		const artifactId = NamespaceId.deserializeAligned(view.buffer);
		view.shiftRight(artifactId.size);

		instance._artifactId = artifactId;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._artifactId.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `artifactId: ${this._artifactId.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.artifactId = this._artifactId.toJson();
		return result;
	}
}

class NamespaceRentalFeeReceipt extends Receipt {
	static RECEIPT_TYPE = ReceiptType.NAMESPACE_RENTAL_FEE;

	static TYPE_HINTS = {
		...Receipt.TYPE_HINTS,
		mosaic: 'struct:Mosaic',
		senderAddress: 'pod:Address',
		recipientAddress: 'pod:Address'
	};

	constructor() {
		super();
		this._type = NamespaceRentalFeeReceipt.RECEIPT_TYPE;
		this._mosaic = new Mosaic();
		this._senderAddress = new Address();
		this._recipientAddress = new Address();
	}

	sort() {
		this._mosaic.sort();
	}

	get mosaic() {
		return this._mosaic;
	}

	set mosaic(value) {
		this._mosaic = value;
	}

	get senderAddress() {
		return this._senderAddress;
	}

	set senderAddress(value) {
		this._senderAddress = value;
	}

	get recipientAddress() {
		return this._recipientAddress;
	}

	set recipientAddress(value) {
		this._recipientAddress = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.mosaic.size;
		size += this.senderAddress.size;
		size += this.recipientAddress.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new NamespaceRentalFeeReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const senderAddress = Address.deserialize(view.buffer);
		view.shiftRight(senderAddress.size);
		const recipientAddress = Address.deserialize(view.buffer);
		view.shiftRight(recipientAddress.size);

		instance._mosaic = mosaic;
		instance._senderAddress = senderAddress;
		instance._recipientAddress = recipientAddress;
		return instance;
	}

	static deserializeAligned(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new NamespaceRentalFeeReceipt();

		Receipt._deserialize(view, instance);
		const mosaic = Mosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const senderAddress = Address.deserialize(view.buffer);
		view.shiftRight(senderAddress.size);
		const recipientAddress = Address.deserialize(view.buffer);
		view.shiftRight(recipientAddress.size);

		instance._mosaic = mosaic;
		instance._senderAddress = senderAddress;
		instance._recipientAddress = recipientAddress;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._mosaic.serialize());
		buffer.write(this._senderAddress.serialize());
		buffer.write(this._recipientAddress.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `mosaic: ${this._mosaic.toString()}, `;
		result += `senderAddress: ${this._senderAddress.toString()}, `;
		result += `recipientAddress: ${this._recipientAddress.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.mosaic = this._mosaic.toJson();
		result.senderAddress = this._senderAddress.toJson();
		result.recipientAddress = this._recipientAddress.toJson();
		return result;
	}
}

class ReceiptSource {
	static TYPE_HINTS = {
	};

	constructor() {
		this._primaryId = 0;
		this._secondaryId = 0;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get primaryId() {
		return this._primaryId;
	}

	set primaryId(value) {
		this._primaryId = value;
	}

	get secondaryId() {
		return this._secondaryId;
	}

	set secondaryId(value) {
		this._secondaryId = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += 4;
		size += 4;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new ReceiptSource();

		const primaryId = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(view.buffer, 4, false);
		view.shiftRight(4);
		const secondaryId = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(view.buffer, 4, false);
		view.shiftRight(4);

		instance._primaryId = primaryId;
		instance._secondaryId = secondaryId;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._primaryId, 4, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._secondaryId, 4, false));
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += `primaryId: ${'0x'.concat(this._primaryId.toString(16))}, `;
		result += `secondaryId: ${'0x'.concat(this._secondaryId.toString(16))}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		result.primaryId = this._primaryId;
		result.secondaryId = this._secondaryId;
		return result;
	}
}

class AddressResolutionEntry {
	static TYPE_HINTS = {
		source: 'struct:ReceiptSource',
		resolvedValue: 'pod:Address'
	};

	constructor() {
		this._source = new ReceiptSource();
		this._resolvedValue = new Address();
	}

	sort() {
		this._source.sort();
	}

	get source() {
		return this._source;
	}

	set source(value) {
		this._source = value;
	}

	get resolvedValue() {
		return this._resolvedValue;
	}

	set resolvedValue(value) {
		this._resolvedValue = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += this.source.size;
		size += this.resolvedValue.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new AddressResolutionEntry();

		const source = ReceiptSource.deserialize(view.buffer);
		view.shiftRight(source.size);
		const resolvedValue = Address.deserialize(view.buffer);
		view.shiftRight(resolvedValue.size);

		instance._source = source;
		instance._resolvedValue = resolvedValue;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		buffer.write(this._source.serialize());
		buffer.write(this._resolvedValue.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += `source: ${this._source.toString()}, `;
		result += `resolvedValue: ${this._resolvedValue.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		result.source = this._source.toJson();
		result.resolvedValue = this._resolvedValue.toJson();
		return result;
	}
}

class AddressResolutionStatement {
	static TYPE_HINTS = {
		unresolved: 'pod:UnresolvedAddress',
		resolutionEntries: 'array[AddressResolutionEntry]'
	};

	constructor() {
		this._unresolved = new UnresolvedAddress();
		this._resolutionEntries = [];
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get unresolved() {
		return this._unresolved;
	}

	set unresolved(value) {
		this._unresolved = value;
	}

	get resolutionEntries() {
		return this._resolutionEntries;
	}

	set resolutionEntries(value) {
		this._resolutionEntries = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += this.unresolved.size;
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.resolutionEntries);
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new AddressResolutionStatement();

		const unresolved = UnresolvedAddress.deserialize(view.buffer);
		view.shiftRight(unresolved.size);
		const resolutionEntriesCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(view.buffer, 4, false);
		view.shiftRight(4);
		const resolutionEntries = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, AddressResolutionEntry, resolutionEntriesCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(resolutionEntries));

		instance._unresolved = unresolved;
		instance._resolutionEntries = resolutionEntries;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		buffer.write(this._unresolved.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._resolutionEntries.length, 4, false)); // bound: resolution_entries_count
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._resolutionEntries);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += `unresolved: ${this._unresolved.toString()}, `;
		result += `resolutionEntries: [${this._resolutionEntries.map(e => e.toString()).join(',')}], `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		result.unresolved = this._unresolved.toJson();
		result.resolutionEntries = this._resolutionEntries.map(e => e.toJson());
		return result;
	}
}

class MosaicResolutionEntry {
	static TYPE_HINTS = {
		source: 'struct:ReceiptSource',
		resolvedValue: 'pod:MosaicId'
	};

	constructor() {
		this._source = new ReceiptSource();
		this._resolvedValue = new MosaicId();
	}

	sort() {
		this._source.sort();
	}

	get source() {
		return this._source;
	}

	set source(value) {
		this._source = value;
	}

	get resolvedValue() {
		return this._resolvedValue;
	}

	set resolvedValue(value) {
		this._resolvedValue = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += this.source.size;
		size += this.resolvedValue.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new MosaicResolutionEntry();

		const source = ReceiptSource.deserialize(view.buffer);
		view.shiftRight(source.size);
		const resolvedValue = MosaicId.deserialize(view.buffer);
		view.shiftRight(resolvedValue.size);

		instance._source = source;
		instance._resolvedValue = resolvedValue;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		buffer.write(this._source.serialize());
		buffer.write(this._resolvedValue.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += `source: ${this._source.toString()}, `;
		result += `resolvedValue: ${this._resolvedValue.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		result.source = this._source.toJson();
		result.resolvedValue = this._resolvedValue.toJson();
		return result;
	}
}

class MosaicResolutionStatement {
	static TYPE_HINTS = {
		unresolved: 'pod:UnresolvedMosaicId',
		resolutionEntries: 'array[MosaicResolutionEntry]'
	};

	constructor() {
		this._unresolved = new UnresolvedMosaicId();
		this._resolutionEntries = [];
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get unresolved() {
		return this._unresolved;
	}

	set unresolved(value) {
		this._unresolved = value;
	}

	get resolutionEntries() {
		return this._resolutionEntries;
	}

	set resolutionEntries(value) {
		this._resolutionEntries = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += this.unresolved.size;
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.resolutionEntries);
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new MosaicResolutionStatement();

		const unresolved = UnresolvedMosaicId.deserialize(view.buffer);
		view.shiftRight(unresolved.size);
		const resolutionEntriesCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(view.buffer, 4, false);
		view.shiftRight(4);
		const resolutionEntries = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, MosaicResolutionEntry, resolutionEntriesCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(resolutionEntries));

		instance._unresolved = unresolved;
		instance._resolutionEntries = resolutionEntries;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		buffer.write(this._unresolved.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._resolutionEntries.length, 4, false)); // bound: resolution_entries_count
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._resolutionEntries);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += `unresolved: ${this._unresolved.toString()}, `;
		result += `resolutionEntries: [${this._resolutionEntries.map(e => e.toString()).join(',')}], `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		result.unresolved = this._unresolved.toJson();
		result.resolutionEntries = this._resolutionEntries.map(e => e.toJson());
		return result;
	}
}

class TransactionStatement {
	static TYPE_HINTS = {
		receipts: 'array[Receipt]'
	};

	constructor() {
		this._primaryId = 0;
		this._secondaryId = 0;
		this._receipts = [];
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get primaryId() {
		return this._primaryId;
	}

	set primaryId(value) {
		this._primaryId = value;
	}

	get secondaryId() {
		return this._secondaryId;
	}

	set secondaryId(value) {
		this._secondaryId = value;
	}

	get receipts() {
		return this._receipts;
	}

	set receipts(value) {
		this._receipts = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += 4;
		size += 4;
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.receipts);
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new TransactionStatement();

		const primaryId = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(view.buffer, 4, false);
		view.shiftRight(4);
		const secondaryId = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(view.buffer, 4, false);
		view.shiftRight(4);
		const receiptCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(view.buffer, 4, false);
		view.shiftRight(4);
		const receipts = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, ReceiptFactory, receiptCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(receipts));

		instance._primaryId = primaryId;
		instance._secondaryId = secondaryId;
		instance._receipts = receipts;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._primaryId, 4, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._secondaryId, 4, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._receipts.length, 4, false)); // bound: receipt_count
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._receipts);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += `primaryId: ${'0x'.concat(this._primaryId.toString(16))}, `;
		result += `secondaryId: ${'0x'.concat(this._secondaryId.toString(16))}, `;
		result += `receipts: [${this._receipts.map(e => e.toString()).join(',')}], `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		result.primaryId = this._primaryId;
		result.secondaryId = this._secondaryId;
		result.receipts = this._receipts.map(e => e.toJson());
		return result;
	}
}

class BlockStatement {
	static TYPE_HINTS = {
		transactionStatements: 'array[TransactionStatement]',
		addressResolutionStatements: 'array[AddressResolutionStatement]',
		mosaicResolutionStatements: 'array[MosaicResolutionStatement]'
	};

	constructor() {
		this._transactionStatements = [];
		this._addressResolutionStatements = [];
		this._mosaicResolutionStatements = [];
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get transactionStatements() {
		return this._transactionStatements;
	}

	set transactionStatements(value) {
		this._transactionStatements = value;
	}

	get addressResolutionStatements() {
		return this._addressResolutionStatements;
	}

	set addressResolutionStatements(value) {
		this._addressResolutionStatements = value;
	}

	get mosaicResolutionStatements() {
		return this._mosaicResolutionStatements;
	}

	set mosaicResolutionStatements(value) {
		this._mosaicResolutionStatements = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.transactionStatements);
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.addressResolutionStatements);
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.mosaicResolutionStatements);
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new BlockStatement();

		const transactionStatementCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(view.buffer, 4, false);
		view.shiftRight(4);
		const transactionStatements = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, TransactionStatement, transactionStatementCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(transactionStatements));
		const addressResolutionStatementCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(view.buffer, 4, false);
		view.shiftRight(4);
		const addressResolutionStatements = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, AddressResolutionStatement, addressResolutionStatementCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(addressResolutionStatements));
		const mosaicResolutionStatementCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(view.buffer, 4, false);
		view.shiftRight(4);
		const mosaicResolutionStatements = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, MosaicResolutionStatement, mosaicResolutionStatementCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(mosaicResolutionStatements));

		instance._transactionStatements = transactionStatements;
		instance._addressResolutionStatements = addressResolutionStatements;
		instance._mosaicResolutionStatements = mosaicResolutionStatements;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._transactionStatements.length, 4, false)); // bound: transaction_statement_count
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._transactionStatements);
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._addressResolutionStatements.length, 4, false)); // bound: address_resolution_statement_count
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._addressResolutionStatements);
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._mosaicResolutionStatements.length, 4, false)); // bound: mosaic_resolution_statement_count
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._mosaicResolutionStatements);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += `transactionStatements: [${this._transactionStatements.map(e => e.toString()).join(',')}], `;
		result += `addressResolutionStatements: [${this._addressResolutionStatements.map(e => e.toString()).join(',')}], `;
		result += `mosaicResolutionStatements: [${this._mosaicResolutionStatements.map(e => e.toString()).join(',')}], `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		result.transactionStatements = this._transactionStatements.map(e => e.toJson());
		result.addressResolutionStatements = this._addressResolutionStatements.map(e => e.toJson());
		result.mosaicResolutionStatements = this._mosaicResolutionStatements.map(e => e.toJson());
		return result;
	}
}

class AccountKeyLinkTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.ACCOUNT_KEY_LINK;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		linkedPublicKey: 'pod:PublicKey',
		linkAction: 'enum:LinkAction'
	};

	constructor() {
		super();
		this._version = AccountKeyLinkTransactionV1.TRANSACTION_VERSION;
		this._type = AccountKeyLinkTransactionV1.TRANSACTION_TYPE;
		this._linkedPublicKey = new PublicKey();
		this._linkAction = LinkAction.UNLINK;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get linkedPublicKey() {
		return this._linkedPublicKey;
	}

	set linkedPublicKey(value) {
		this._linkedPublicKey = value;
	}

	get linkAction() {
		return this._linkAction;
	}

	set linkAction(value) {
		this._linkAction = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.linkedPublicKey.size;
		size += this.linkAction.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new AccountKeyLinkTransactionV1();

		Transaction._deserialize(view, instance);
		const linkedPublicKey = PublicKey.deserialize(view.buffer);
		view.shiftRight(linkedPublicKey.size);
		const linkAction = LinkAction.deserializeAligned(view.buffer);
		view.shiftRight(linkAction.size);

		instance._linkedPublicKey = linkedPublicKey;
		instance._linkAction = linkAction;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._linkedPublicKey.serialize());
		buffer.write(this._linkAction.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `linkedPublicKey: ${this._linkedPublicKey.toString()}, `;
		result += `linkAction: ${this._linkAction.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.linkedPublicKey = this._linkedPublicKey.toJson();
		result.linkAction = this._linkAction.toJson();
		return result;
	}
}

class EmbeddedAccountKeyLinkTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.ACCOUNT_KEY_LINK;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		linkedPublicKey: 'pod:PublicKey',
		linkAction: 'enum:LinkAction'
	};

	constructor() {
		super();
		this._version = EmbeddedAccountKeyLinkTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedAccountKeyLinkTransactionV1.TRANSACTION_TYPE;
		this._linkedPublicKey = new PublicKey();
		this._linkAction = LinkAction.UNLINK;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get linkedPublicKey() {
		return this._linkedPublicKey;
	}

	set linkedPublicKey(value) {
		this._linkedPublicKey = value;
	}

	get linkAction() {
		return this._linkAction;
	}

	set linkAction(value) {
		this._linkAction = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.linkedPublicKey.size;
		size += this.linkAction.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedAccountKeyLinkTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const linkedPublicKey = PublicKey.deserialize(view.buffer);
		view.shiftRight(linkedPublicKey.size);
		const linkAction = LinkAction.deserializeAligned(view.buffer);
		view.shiftRight(linkAction.size);

		instance._linkedPublicKey = linkedPublicKey;
		instance._linkAction = linkAction;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._linkedPublicKey.serialize());
		buffer.write(this._linkAction.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `linkedPublicKey: ${this._linkedPublicKey.toString()}, `;
		result += `linkAction: ${this._linkAction.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.linkedPublicKey = this._linkedPublicKey.toJson();
		result.linkAction = this._linkAction.toJson();
		return result;
	}
}

class NodeKeyLinkTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.NODE_KEY_LINK;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		linkedPublicKey: 'pod:PublicKey',
		linkAction: 'enum:LinkAction'
	};

	constructor() {
		super();
		this._version = NodeKeyLinkTransactionV1.TRANSACTION_VERSION;
		this._type = NodeKeyLinkTransactionV1.TRANSACTION_TYPE;
		this._linkedPublicKey = new PublicKey();
		this._linkAction = LinkAction.UNLINK;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get linkedPublicKey() {
		return this._linkedPublicKey;
	}

	set linkedPublicKey(value) {
		this._linkedPublicKey = value;
	}

	get linkAction() {
		return this._linkAction;
	}

	set linkAction(value) {
		this._linkAction = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.linkedPublicKey.size;
		size += this.linkAction.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new NodeKeyLinkTransactionV1();

		Transaction._deserialize(view, instance);
		const linkedPublicKey = PublicKey.deserialize(view.buffer);
		view.shiftRight(linkedPublicKey.size);
		const linkAction = LinkAction.deserializeAligned(view.buffer);
		view.shiftRight(linkAction.size);

		instance._linkedPublicKey = linkedPublicKey;
		instance._linkAction = linkAction;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._linkedPublicKey.serialize());
		buffer.write(this._linkAction.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `linkedPublicKey: ${this._linkedPublicKey.toString()}, `;
		result += `linkAction: ${this._linkAction.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.linkedPublicKey = this._linkedPublicKey.toJson();
		result.linkAction = this._linkAction.toJson();
		return result;
	}
}

class EmbeddedNodeKeyLinkTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.NODE_KEY_LINK;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		linkedPublicKey: 'pod:PublicKey',
		linkAction: 'enum:LinkAction'
	};

	constructor() {
		super();
		this._version = EmbeddedNodeKeyLinkTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedNodeKeyLinkTransactionV1.TRANSACTION_TYPE;
		this._linkedPublicKey = new PublicKey();
		this._linkAction = LinkAction.UNLINK;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get linkedPublicKey() {
		return this._linkedPublicKey;
	}

	set linkedPublicKey(value) {
		this._linkedPublicKey = value;
	}

	get linkAction() {
		return this._linkAction;
	}

	set linkAction(value) {
		this._linkAction = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.linkedPublicKey.size;
		size += this.linkAction.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedNodeKeyLinkTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const linkedPublicKey = PublicKey.deserialize(view.buffer);
		view.shiftRight(linkedPublicKey.size);
		const linkAction = LinkAction.deserializeAligned(view.buffer);
		view.shiftRight(linkAction.size);

		instance._linkedPublicKey = linkedPublicKey;
		instance._linkAction = linkAction;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._linkedPublicKey.serialize());
		buffer.write(this._linkAction.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `linkedPublicKey: ${this._linkedPublicKey.toString()}, `;
		result += `linkAction: ${this._linkAction.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.linkedPublicKey = this._linkedPublicKey.toJson();
		result.linkAction = this._linkAction.toJson();
		return result;
	}
}

class Cosignature {
	static TYPE_HINTS = {
		signerPublicKey: 'pod:PublicKey',
		signature: 'pod:Signature'
	};

	constructor() {
		this._version = 0n;
		this._signerPublicKey = new PublicKey();
		this._signature = new Signature();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get version() {
		return this._version;
	}

	set version(value) {
		this._version = value;
	}

	get signerPublicKey() {
		return this._signerPublicKey;
	}

	set signerPublicKey(value) {
		this._signerPublicKey = value;
	}

	get signature() {
		return this._signature;
	}

	set signature(value) {
		this._signature = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += 8;
		size += this.signerPublicKey.size;
		size += this.signature.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new Cosignature();

		const version = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const signerPublicKey = PublicKey.deserialize(view.buffer);
		view.shiftRight(signerPublicKey.size);
		const signature = Signature.deserialize(view.buffer);
		view.shiftRight(signature.size);

		instance._version = version;
		instance._signerPublicKey = signerPublicKey;
		instance._signature = signature;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._version, 8, false));
		buffer.write(this._signerPublicKey.serialize());
		buffer.write(this._signature.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += `version: ${'0x'.concat(this._version.toString(16))}, `;
		result += `signerPublicKey: ${this._signerPublicKey.toString()}, `;
		result += `signature: ${this._signature.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		result.version = this._version.toString();
		result.signerPublicKey = this._signerPublicKey.toJson();
		result.signature = this._signature.toJson();
		return result;
	}
}

class DetachedCosignature {
	static TYPE_HINTS = {
		signerPublicKey: 'pod:PublicKey',
		signature: 'pod:Signature',
		parentHash: 'pod:Hash256'
	};

	constructor() {
		this._version = 0n;
		this._signerPublicKey = new PublicKey();
		this._signature = new Signature();
		this._parentHash = new Hash256();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get version() {
		return this._version;
	}

	set version(value) {
		this._version = value;
	}

	get signerPublicKey() {
		return this._signerPublicKey;
	}

	set signerPublicKey(value) {
		this._signerPublicKey = value;
	}

	get signature() {
		return this._signature;
	}

	set signature(value) {
		this._signature = value;
	}

	get parentHash() {
		return this._parentHash;
	}

	set parentHash(value) {
		this._parentHash = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += 8;
		size += this.signerPublicKey.size;
		size += this.signature.size;
		size += this.parentHash.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new DetachedCosignature();

		const version = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const signerPublicKey = PublicKey.deserialize(view.buffer);
		view.shiftRight(signerPublicKey.size);
		const signature = Signature.deserialize(view.buffer);
		view.shiftRight(signature.size);
		const parentHash = Hash256.deserialize(view.buffer);
		view.shiftRight(parentHash.size);

		instance._version = version;
		instance._signerPublicKey = signerPublicKey;
		instance._signature = signature;
		instance._parentHash = parentHash;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._version, 8, false));
		buffer.write(this._signerPublicKey.serialize());
		buffer.write(this._signature.serialize());
		buffer.write(this._parentHash.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += `version: ${'0x'.concat(this._version.toString(16))}, `;
		result += `signerPublicKey: ${this._signerPublicKey.toString()}, `;
		result += `signature: ${this._signature.toString()}, `;
		result += `parentHash: ${this._parentHash.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		result.version = this._version.toString();
		result.signerPublicKey = this._signerPublicKey.toJson();
		result.signature = this._signature.toJson();
		result.parentHash = this._parentHash.toJson();
		return result;
	}
}

class AggregateCompleteTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.AGGREGATE_COMPLETE;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		transactionsHash: 'pod:Hash256',
		transactions: 'array[EmbeddedTransaction]',
		cosignatures: 'array[Cosignature]'
	};

	constructor() {
		super();
		this._version = AggregateCompleteTransactionV1.TRANSACTION_VERSION;
		this._type = AggregateCompleteTransactionV1.TRANSACTION_TYPE;
		this._transactionsHash = new Hash256();
		this._transactions = [];
		this._cosignatures = [];
		this._aggregateTransactionHeaderReserved_1 = 0; // reserved field
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get transactionsHash() {
		return this._transactionsHash;
	}

	set transactionsHash(value) {
		this._transactionsHash = value;
	}

	get transactions() {
		return this._transactions;
	}

	set transactions(value) {
		this._transactions = value;
	}

	get cosignatures() {
		return this._cosignatures;
	}

	set cosignatures(value) {
		this._cosignatures = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.transactionsHash.size;
		size += 4;
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.transactions, 8, false);
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.cosignatures);
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new AggregateCompleteTransactionV1();

		Transaction._deserialize(view, instance);
		const transactionsHash = Hash256.deserialize(view.buffer);
		view.shiftRight(transactionsHash.size);
		const payloadSize = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		const aggregateTransactionHeaderReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== aggregateTransactionHeaderReserved_1)
			throw RangeError(`Invalid value of reserved field (${aggregateTransactionHeaderReserved_1})`);
		const transactions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readVariableSizeElements(view.window(payloadSize), EmbeddedTransactionFactory, 8, false);
		view.shiftRight(payloadSize);
		const cosignatures = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArray(view.buffer, Cosignature);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(cosignatures));

		instance._transactionsHash = transactionsHash;
		instance._transactions = transactions;
		instance._cosignatures = cosignatures;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._transactionsHash.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.transactions, 8, false), 4, false)); // bound: payload_size
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._aggregateTransactionHeaderReserved_1, 4, false));
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeVariableSizeElements(buffer, this._transactions, 8, false);
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._cosignatures);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `transactionsHash: ${this._transactionsHash.toString()}, `;
		result += `transactions: [${this._transactions.map(e => e.toString()).join(',')}], `;
		result += `cosignatures: [${this._cosignatures.map(e => e.toString()).join(',')}], `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.transactionsHash = this._transactionsHash.toJson();
		result.transactions = this._transactions.map(e => e.toJson());
		result.cosignatures = this._cosignatures.map(e => e.toJson());
		return result;
	}
}

class AggregateCompleteTransactionV2 extends Transaction {
	static TRANSACTION_VERSION = 2;

	static TRANSACTION_TYPE = TransactionType.AGGREGATE_COMPLETE;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		transactionsHash: 'pod:Hash256',
		transactions: 'array[EmbeddedTransaction]',
		cosignatures: 'array[Cosignature]'
	};

	constructor() {
		super();
		this._version = AggregateCompleteTransactionV2.TRANSACTION_VERSION;
		this._type = AggregateCompleteTransactionV2.TRANSACTION_TYPE;
		this._transactionsHash = new Hash256();
		this._transactions = [];
		this._cosignatures = [];
		this._aggregateTransactionHeaderReserved_1 = 0; // reserved field
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get transactionsHash() {
		return this._transactionsHash;
	}

	set transactionsHash(value) {
		this._transactionsHash = value;
	}

	get transactions() {
		return this._transactions;
	}

	set transactions(value) {
		this._transactions = value;
	}

	get cosignatures() {
		return this._cosignatures;
	}

	set cosignatures(value) {
		this._cosignatures = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.transactionsHash.size;
		size += 4;
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.transactions, 8, false);
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.cosignatures);
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new AggregateCompleteTransactionV2();

		Transaction._deserialize(view, instance);
		const transactionsHash = Hash256.deserialize(view.buffer);
		view.shiftRight(transactionsHash.size);
		const payloadSize = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		const aggregateTransactionHeaderReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== aggregateTransactionHeaderReserved_1)
			throw RangeError(`Invalid value of reserved field (${aggregateTransactionHeaderReserved_1})`);
		const transactions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readVariableSizeElements(view.window(payloadSize), EmbeddedTransactionFactory, 8, false);
		view.shiftRight(payloadSize);
		const cosignatures = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArray(view.buffer, Cosignature);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(cosignatures));

		instance._transactionsHash = transactionsHash;
		instance._transactions = transactions;
		instance._cosignatures = cosignatures;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._transactionsHash.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.transactions, 8, false), 4, false)); // bound: payload_size
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._aggregateTransactionHeaderReserved_1, 4, false));
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeVariableSizeElements(buffer, this._transactions, 8, false);
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._cosignatures);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `transactionsHash: ${this._transactionsHash.toString()}, `;
		result += `transactions: [${this._transactions.map(e => e.toString()).join(',')}], `;
		result += `cosignatures: [${this._cosignatures.map(e => e.toString()).join(',')}], `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.transactionsHash = this._transactionsHash.toJson();
		result.transactions = this._transactions.map(e => e.toJson());
		result.cosignatures = this._cosignatures.map(e => e.toJson());
		return result;
	}
}

class AggregateBondedTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.AGGREGATE_BONDED;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		transactionsHash: 'pod:Hash256',
		transactions: 'array[EmbeddedTransaction]',
		cosignatures: 'array[Cosignature]'
	};

	constructor() {
		super();
		this._version = AggregateBondedTransactionV1.TRANSACTION_VERSION;
		this._type = AggregateBondedTransactionV1.TRANSACTION_TYPE;
		this._transactionsHash = new Hash256();
		this._transactions = [];
		this._cosignatures = [];
		this._aggregateTransactionHeaderReserved_1 = 0; // reserved field
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get transactionsHash() {
		return this._transactionsHash;
	}

	set transactionsHash(value) {
		this._transactionsHash = value;
	}

	get transactions() {
		return this._transactions;
	}

	set transactions(value) {
		this._transactions = value;
	}

	get cosignatures() {
		return this._cosignatures;
	}

	set cosignatures(value) {
		this._cosignatures = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.transactionsHash.size;
		size += 4;
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.transactions, 8, false);
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.cosignatures);
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new AggregateBondedTransactionV1();

		Transaction._deserialize(view, instance);
		const transactionsHash = Hash256.deserialize(view.buffer);
		view.shiftRight(transactionsHash.size);
		const payloadSize = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		const aggregateTransactionHeaderReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== aggregateTransactionHeaderReserved_1)
			throw RangeError(`Invalid value of reserved field (${aggregateTransactionHeaderReserved_1})`);
		const transactions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readVariableSizeElements(view.window(payloadSize), EmbeddedTransactionFactory, 8, false);
		view.shiftRight(payloadSize);
		const cosignatures = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArray(view.buffer, Cosignature);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(cosignatures));

		instance._transactionsHash = transactionsHash;
		instance._transactions = transactions;
		instance._cosignatures = cosignatures;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._transactionsHash.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.transactions, 8, false), 4, false)); // bound: payload_size
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._aggregateTransactionHeaderReserved_1, 4, false));
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeVariableSizeElements(buffer, this._transactions, 8, false);
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._cosignatures);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `transactionsHash: ${this._transactionsHash.toString()}, `;
		result += `transactions: [${this._transactions.map(e => e.toString()).join(',')}], `;
		result += `cosignatures: [${this._cosignatures.map(e => e.toString()).join(',')}], `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.transactionsHash = this._transactionsHash.toJson();
		result.transactions = this._transactions.map(e => e.toJson());
		result.cosignatures = this._cosignatures.map(e => e.toJson());
		return result;
	}
}

class AggregateBondedTransactionV2 extends Transaction {
	static TRANSACTION_VERSION = 2;

	static TRANSACTION_TYPE = TransactionType.AGGREGATE_BONDED;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		transactionsHash: 'pod:Hash256',
		transactions: 'array[EmbeddedTransaction]',
		cosignatures: 'array[Cosignature]'
	};

	constructor() {
		super();
		this._version = AggregateBondedTransactionV2.TRANSACTION_VERSION;
		this._type = AggregateBondedTransactionV2.TRANSACTION_TYPE;
		this._transactionsHash = new Hash256();
		this._transactions = [];
		this._cosignatures = [];
		this._aggregateTransactionHeaderReserved_1 = 0; // reserved field
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get transactionsHash() {
		return this._transactionsHash;
	}

	set transactionsHash(value) {
		this._transactionsHash = value;
	}

	get transactions() {
		return this._transactions;
	}

	set transactions(value) {
		this._transactions = value;
	}

	get cosignatures() {
		return this._cosignatures;
	}

	set cosignatures(value) {
		this._cosignatures = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.transactionsHash.size;
		size += 4;
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.transactions, 8, false);
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.cosignatures);
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new AggregateBondedTransactionV2();

		Transaction._deserialize(view, instance);
		const transactionsHash = Hash256.deserialize(view.buffer);
		view.shiftRight(transactionsHash.size);
		const payloadSize = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		const aggregateTransactionHeaderReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== aggregateTransactionHeaderReserved_1)
			throw RangeError(`Invalid value of reserved field (${aggregateTransactionHeaderReserved_1})`);
		const transactions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readVariableSizeElements(view.window(payloadSize), EmbeddedTransactionFactory, 8, false);
		view.shiftRight(payloadSize);
		const cosignatures = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArray(view.buffer, Cosignature);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(cosignatures));

		instance._transactionsHash = transactionsHash;
		instance._transactions = transactions;
		instance._cosignatures = cosignatures;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._transactionsHash.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.transactions, 8, false), 4, false)); // bound: payload_size
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._aggregateTransactionHeaderReserved_1, 4, false));
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeVariableSizeElements(buffer, this._transactions, 8, false);
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._cosignatures);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `transactionsHash: ${this._transactionsHash.toString()}, `;
		result += `transactions: [${this._transactions.map(e => e.toString()).join(',')}], `;
		result += `cosignatures: [${this._cosignatures.map(e => e.toString()).join(',')}], `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.transactionsHash = this._transactionsHash.toJson();
		result.transactions = this._transactions.map(e => e.toJson());
		result.cosignatures = this._cosignatures.map(e => e.toJson());
		return result;
	}
}

class VotingKeyLinkTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.VOTING_KEY_LINK;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		linkedPublicKey: 'pod:VotingPublicKey',
		startEpoch: 'pod:FinalizationEpoch',
		endEpoch: 'pod:FinalizationEpoch',
		linkAction: 'enum:LinkAction'
	};

	constructor() {
		super();
		this._version = VotingKeyLinkTransactionV1.TRANSACTION_VERSION;
		this._type = VotingKeyLinkTransactionV1.TRANSACTION_TYPE;
		this._linkedPublicKey = new VotingPublicKey();
		this._startEpoch = new FinalizationEpoch();
		this._endEpoch = new FinalizationEpoch();
		this._linkAction = LinkAction.UNLINK;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get linkedPublicKey() {
		return this._linkedPublicKey;
	}

	set linkedPublicKey(value) {
		this._linkedPublicKey = value;
	}

	get startEpoch() {
		return this._startEpoch;
	}

	set startEpoch(value) {
		this._startEpoch = value;
	}

	get endEpoch() {
		return this._endEpoch;
	}

	set endEpoch(value) {
		this._endEpoch = value;
	}

	get linkAction() {
		return this._linkAction;
	}

	set linkAction(value) {
		this._linkAction = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.linkedPublicKey.size;
		size += this.startEpoch.size;
		size += this.endEpoch.size;
		size += this.linkAction.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new VotingKeyLinkTransactionV1();

		Transaction._deserialize(view, instance);
		const linkedPublicKey = VotingPublicKey.deserialize(view.buffer);
		view.shiftRight(linkedPublicKey.size);
		const startEpoch = FinalizationEpoch.deserializeAligned(view.buffer);
		view.shiftRight(startEpoch.size);
		const endEpoch = FinalizationEpoch.deserializeAligned(view.buffer);
		view.shiftRight(endEpoch.size);
		const linkAction = LinkAction.deserializeAligned(view.buffer);
		view.shiftRight(linkAction.size);

		instance._linkedPublicKey = linkedPublicKey;
		instance._startEpoch = startEpoch;
		instance._endEpoch = endEpoch;
		instance._linkAction = linkAction;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._linkedPublicKey.serialize());
		buffer.write(this._startEpoch.serialize());
		buffer.write(this._endEpoch.serialize());
		buffer.write(this._linkAction.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `linkedPublicKey: ${this._linkedPublicKey.toString()}, `;
		result += `startEpoch: ${this._startEpoch.toString()}, `;
		result += `endEpoch: ${this._endEpoch.toString()}, `;
		result += `linkAction: ${this._linkAction.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.linkedPublicKey = this._linkedPublicKey.toJson();
		result.startEpoch = this._startEpoch.toJson();
		result.endEpoch = this._endEpoch.toJson();
		result.linkAction = this._linkAction.toJson();
		return result;
	}
}

class EmbeddedVotingKeyLinkTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.VOTING_KEY_LINK;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		linkedPublicKey: 'pod:VotingPublicKey',
		startEpoch: 'pod:FinalizationEpoch',
		endEpoch: 'pod:FinalizationEpoch',
		linkAction: 'enum:LinkAction'
	};

	constructor() {
		super();
		this._version = EmbeddedVotingKeyLinkTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedVotingKeyLinkTransactionV1.TRANSACTION_TYPE;
		this._linkedPublicKey = new VotingPublicKey();
		this._startEpoch = new FinalizationEpoch();
		this._endEpoch = new FinalizationEpoch();
		this._linkAction = LinkAction.UNLINK;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get linkedPublicKey() {
		return this._linkedPublicKey;
	}

	set linkedPublicKey(value) {
		this._linkedPublicKey = value;
	}

	get startEpoch() {
		return this._startEpoch;
	}

	set startEpoch(value) {
		this._startEpoch = value;
	}

	get endEpoch() {
		return this._endEpoch;
	}

	set endEpoch(value) {
		this._endEpoch = value;
	}

	get linkAction() {
		return this._linkAction;
	}

	set linkAction(value) {
		this._linkAction = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.linkedPublicKey.size;
		size += this.startEpoch.size;
		size += this.endEpoch.size;
		size += this.linkAction.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedVotingKeyLinkTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const linkedPublicKey = VotingPublicKey.deserialize(view.buffer);
		view.shiftRight(linkedPublicKey.size);
		const startEpoch = FinalizationEpoch.deserializeAligned(view.buffer);
		view.shiftRight(startEpoch.size);
		const endEpoch = FinalizationEpoch.deserializeAligned(view.buffer);
		view.shiftRight(endEpoch.size);
		const linkAction = LinkAction.deserializeAligned(view.buffer);
		view.shiftRight(linkAction.size);

		instance._linkedPublicKey = linkedPublicKey;
		instance._startEpoch = startEpoch;
		instance._endEpoch = endEpoch;
		instance._linkAction = linkAction;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._linkedPublicKey.serialize());
		buffer.write(this._startEpoch.serialize());
		buffer.write(this._endEpoch.serialize());
		buffer.write(this._linkAction.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `linkedPublicKey: ${this._linkedPublicKey.toString()}, `;
		result += `startEpoch: ${this._startEpoch.toString()}, `;
		result += `endEpoch: ${this._endEpoch.toString()}, `;
		result += `linkAction: ${this._linkAction.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.linkedPublicKey = this._linkedPublicKey.toJson();
		result.startEpoch = this._startEpoch.toJson();
		result.endEpoch = this._endEpoch.toJson();
		result.linkAction = this._linkAction.toJson();
		return result;
	}
}

class VrfKeyLinkTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.VRF_KEY_LINK;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		linkedPublicKey: 'pod:PublicKey',
		linkAction: 'enum:LinkAction'
	};

	constructor() {
		super();
		this._version = VrfKeyLinkTransactionV1.TRANSACTION_VERSION;
		this._type = VrfKeyLinkTransactionV1.TRANSACTION_TYPE;
		this._linkedPublicKey = new PublicKey();
		this._linkAction = LinkAction.UNLINK;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get linkedPublicKey() {
		return this._linkedPublicKey;
	}

	set linkedPublicKey(value) {
		this._linkedPublicKey = value;
	}

	get linkAction() {
		return this._linkAction;
	}

	set linkAction(value) {
		this._linkAction = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.linkedPublicKey.size;
		size += this.linkAction.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new VrfKeyLinkTransactionV1();

		Transaction._deserialize(view, instance);
		const linkedPublicKey = PublicKey.deserialize(view.buffer);
		view.shiftRight(linkedPublicKey.size);
		const linkAction = LinkAction.deserializeAligned(view.buffer);
		view.shiftRight(linkAction.size);

		instance._linkedPublicKey = linkedPublicKey;
		instance._linkAction = linkAction;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._linkedPublicKey.serialize());
		buffer.write(this._linkAction.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `linkedPublicKey: ${this._linkedPublicKey.toString()}, `;
		result += `linkAction: ${this._linkAction.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.linkedPublicKey = this._linkedPublicKey.toJson();
		result.linkAction = this._linkAction.toJson();
		return result;
	}
}

class EmbeddedVrfKeyLinkTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.VRF_KEY_LINK;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		linkedPublicKey: 'pod:PublicKey',
		linkAction: 'enum:LinkAction'
	};

	constructor() {
		super();
		this._version = EmbeddedVrfKeyLinkTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedVrfKeyLinkTransactionV1.TRANSACTION_TYPE;
		this._linkedPublicKey = new PublicKey();
		this._linkAction = LinkAction.UNLINK;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get linkedPublicKey() {
		return this._linkedPublicKey;
	}

	set linkedPublicKey(value) {
		this._linkedPublicKey = value;
	}

	get linkAction() {
		return this._linkAction;
	}

	set linkAction(value) {
		this._linkAction = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.linkedPublicKey.size;
		size += this.linkAction.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedVrfKeyLinkTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const linkedPublicKey = PublicKey.deserialize(view.buffer);
		view.shiftRight(linkedPublicKey.size);
		const linkAction = LinkAction.deserializeAligned(view.buffer);
		view.shiftRight(linkAction.size);

		instance._linkedPublicKey = linkedPublicKey;
		instance._linkAction = linkAction;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._linkedPublicKey.serialize());
		buffer.write(this._linkAction.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `linkedPublicKey: ${this._linkedPublicKey.toString()}, `;
		result += `linkAction: ${this._linkAction.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.linkedPublicKey = this._linkedPublicKey.toJson();
		result.linkAction = this._linkAction.toJson();
		return result;
	}
}

class HashLockTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.HASH_LOCK;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		mosaic: 'struct:UnresolvedMosaic',
		duration: 'pod:BlockDuration',
		hash: 'pod:Hash256'
	};

	constructor() {
		super();
		this._version = HashLockTransactionV1.TRANSACTION_VERSION;
		this._type = HashLockTransactionV1.TRANSACTION_TYPE;
		this._mosaic = new UnresolvedMosaic();
		this._duration = new BlockDuration();
		this._hash = new Hash256();
	}

	sort() {
		this._mosaic.sort();
	}

	get mosaic() {
		return this._mosaic;
	}

	set mosaic(value) {
		this._mosaic = value;
	}

	get duration() {
		return this._duration;
	}

	set duration(value) {
		this._duration = value;
	}

	get hash() {
		return this._hash;
	}

	set hash(value) {
		this._hash = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.mosaic.size;
		size += this.duration.size;
		size += this.hash.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new HashLockTransactionV1();

		Transaction._deserialize(view, instance);
		const mosaic = UnresolvedMosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const duration = BlockDuration.deserializeAligned(view.buffer);
		view.shiftRight(duration.size);
		const hash = Hash256.deserialize(view.buffer);
		view.shiftRight(hash.size);

		instance._mosaic = mosaic;
		instance._duration = duration;
		instance._hash = hash;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._mosaic.serialize());
		buffer.write(this._duration.serialize());
		buffer.write(this._hash.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `mosaic: ${this._mosaic.toString()}, `;
		result += `duration: ${this._duration.toString()}, `;
		result += `hash: ${this._hash.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.mosaic = this._mosaic.toJson();
		result.duration = this._duration.toJson();
		result.hash = this._hash.toJson();
		return result;
	}
}

class EmbeddedHashLockTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.HASH_LOCK;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		mosaic: 'struct:UnresolvedMosaic',
		duration: 'pod:BlockDuration',
		hash: 'pod:Hash256'
	};

	constructor() {
		super();
		this._version = EmbeddedHashLockTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedHashLockTransactionV1.TRANSACTION_TYPE;
		this._mosaic = new UnresolvedMosaic();
		this._duration = new BlockDuration();
		this._hash = new Hash256();
	}

	sort() {
		this._mosaic.sort();
	}

	get mosaic() {
		return this._mosaic;
	}

	set mosaic(value) {
		this._mosaic = value;
	}

	get duration() {
		return this._duration;
	}

	set duration(value) {
		this._duration = value;
	}

	get hash() {
		return this._hash;
	}

	set hash(value) {
		this._hash = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.mosaic.size;
		size += this.duration.size;
		size += this.hash.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedHashLockTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const mosaic = UnresolvedMosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const duration = BlockDuration.deserializeAligned(view.buffer);
		view.shiftRight(duration.size);
		const hash = Hash256.deserialize(view.buffer);
		view.shiftRight(hash.size);

		instance._mosaic = mosaic;
		instance._duration = duration;
		instance._hash = hash;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._mosaic.serialize());
		buffer.write(this._duration.serialize());
		buffer.write(this._hash.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `mosaic: ${this._mosaic.toString()}, `;
		result += `duration: ${this._duration.toString()}, `;
		result += `hash: ${this._hash.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.mosaic = this._mosaic.toJson();
		result.duration = this._duration.toJson();
		result.hash = this._hash.toJson();
		return result;
	}
}

class LockHashAlgorithm {
	static SHA3_256 = new LockHashAlgorithm(0);

	static HASH_160 = new LockHashAlgorithm(1);

	static HASH_256 = new LockHashAlgorithm(2);

	constructor(value) {
		this.value = value;
	}

	static valueToKey(value) {
		const values = [
			0, 1, 2
		];
		const keys = [
			'SHA3_256', 'HASH_160', 'HASH_256'
		];

		const index = values.indexOf(value);
		if (-1 === index)
			throw RangeError(`invalid enum value ${value}`);

		return keys[index];
	}

	static fromValue(value) {
		return LockHashAlgorithm[this.valueToKey(value)];
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 1;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(byteArray, 1, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(byteArray, 1, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 1, false);
	}

	toString() {
		return `LockHashAlgorithm.${LockHashAlgorithm.valueToKey(this.value)}`;
	}

	toJson() {
		return this.value;
	}
}

class SecretLockTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.SECRET_LOCK;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		recipientAddress: 'pod:UnresolvedAddress',
		secret: 'pod:Hash256',
		mosaic: 'struct:UnresolvedMosaic',
		duration: 'pod:BlockDuration',
		hashAlgorithm: 'enum:LockHashAlgorithm'
	};

	constructor() {
		super();
		this._version = SecretLockTransactionV1.TRANSACTION_VERSION;
		this._type = SecretLockTransactionV1.TRANSACTION_TYPE;
		this._recipientAddress = new UnresolvedAddress();
		this._secret = new Hash256();
		this._mosaic = new UnresolvedMosaic();
		this._duration = new BlockDuration();
		this._hashAlgorithm = LockHashAlgorithm.SHA3_256;
	}

	sort() {
		this._mosaic.sort();
	}

	get recipientAddress() {
		return this._recipientAddress;
	}

	set recipientAddress(value) {
		this._recipientAddress = value;
	}

	get secret() {
		return this._secret;
	}

	set secret(value) {
		this._secret = value;
	}

	get mosaic() {
		return this._mosaic;
	}

	set mosaic(value) {
		this._mosaic = value;
	}

	get duration() {
		return this._duration;
	}

	set duration(value) {
		this._duration = value;
	}

	get hashAlgorithm() {
		return this._hashAlgorithm;
	}

	set hashAlgorithm(value) {
		this._hashAlgorithm = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.recipientAddress.size;
		size += this.secret.size;
		size += this.mosaic.size;
		size += this.duration.size;
		size += this.hashAlgorithm.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new SecretLockTransactionV1();

		Transaction._deserialize(view, instance);
		const recipientAddress = UnresolvedAddress.deserialize(view.buffer);
		view.shiftRight(recipientAddress.size);
		const secret = Hash256.deserialize(view.buffer);
		view.shiftRight(secret.size);
		const mosaic = UnresolvedMosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const duration = BlockDuration.deserializeAligned(view.buffer);
		view.shiftRight(duration.size);
		const hashAlgorithm = LockHashAlgorithm.deserializeAligned(view.buffer);
		view.shiftRight(hashAlgorithm.size);

		instance._recipientAddress = recipientAddress;
		instance._secret = secret;
		instance._mosaic = mosaic;
		instance._duration = duration;
		instance._hashAlgorithm = hashAlgorithm;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._recipientAddress.serialize());
		buffer.write(this._secret.serialize());
		buffer.write(this._mosaic.serialize());
		buffer.write(this._duration.serialize());
		buffer.write(this._hashAlgorithm.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `recipientAddress: ${this._recipientAddress.toString()}, `;
		result += `secret: ${this._secret.toString()}, `;
		result += `mosaic: ${this._mosaic.toString()}, `;
		result += `duration: ${this._duration.toString()}, `;
		result += `hashAlgorithm: ${this._hashAlgorithm.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.recipientAddress = this._recipientAddress.toJson();
		result.secret = this._secret.toJson();
		result.mosaic = this._mosaic.toJson();
		result.duration = this._duration.toJson();
		result.hashAlgorithm = this._hashAlgorithm.toJson();
		return result;
	}
}

class EmbeddedSecretLockTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.SECRET_LOCK;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		recipientAddress: 'pod:UnresolvedAddress',
		secret: 'pod:Hash256',
		mosaic: 'struct:UnresolvedMosaic',
		duration: 'pod:BlockDuration',
		hashAlgorithm: 'enum:LockHashAlgorithm'
	};

	constructor() {
		super();
		this._version = EmbeddedSecretLockTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedSecretLockTransactionV1.TRANSACTION_TYPE;
		this._recipientAddress = new UnresolvedAddress();
		this._secret = new Hash256();
		this._mosaic = new UnresolvedMosaic();
		this._duration = new BlockDuration();
		this._hashAlgorithm = LockHashAlgorithm.SHA3_256;
	}

	sort() {
		this._mosaic.sort();
	}

	get recipientAddress() {
		return this._recipientAddress;
	}

	set recipientAddress(value) {
		this._recipientAddress = value;
	}

	get secret() {
		return this._secret;
	}

	set secret(value) {
		this._secret = value;
	}

	get mosaic() {
		return this._mosaic;
	}

	set mosaic(value) {
		this._mosaic = value;
	}

	get duration() {
		return this._duration;
	}

	set duration(value) {
		this._duration = value;
	}

	get hashAlgorithm() {
		return this._hashAlgorithm;
	}

	set hashAlgorithm(value) {
		this._hashAlgorithm = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.recipientAddress.size;
		size += this.secret.size;
		size += this.mosaic.size;
		size += this.duration.size;
		size += this.hashAlgorithm.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedSecretLockTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const recipientAddress = UnresolvedAddress.deserialize(view.buffer);
		view.shiftRight(recipientAddress.size);
		const secret = Hash256.deserialize(view.buffer);
		view.shiftRight(secret.size);
		const mosaic = UnresolvedMosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);
		const duration = BlockDuration.deserializeAligned(view.buffer);
		view.shiftRight(duration.size);
		const hashAlgorithm = LockHashAlgorithm.deserializeAligned(view.buffer);
		view.shiftRight(hashAlgorithm.size);

		instance._recipientAddress = recipientAddress;
		instance._secret = secret;
		instance._mosaic = mosaic;
		instance._duration = duration;
		instance._hashAlgorithm = hashAlgorithm;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._recipientAddress.serialize());
		buffer.write(this._secret.serialize());
		buffer.write(this._mosaic.serialize());
		buffer.write(this._duration.serialize());
		buffer.write(this._hashAlgorithm.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `recipientAddress: ${this._recipientAddress.toString()}, `;
		result += `secret: ${this._secret.toString()}, `;
		result += `mosaic: ${this._mosaic.toString()}, `;
		result += `duration: ${this._duration.toString()}, `;
		result += `hashAlgorithm: ${this._hashAlgorithm.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.recipientAddress = this._recipientAddress.toJson();
		result.secret = this._secret.toJson();
		result.mosaic = this._mosaic.toJson();
		result.duration = this._duration.toJson();
		result.hashAlgorithm = this._hashAlgorithm.toJson();
		return result;
	}
}

class SecretProofTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.SECRET_PROOF;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		recipientAddress: 'pod:UnresolvedAddress',
		secret: 'pod:Hash256',
		hashAlgorithm: 'enum:LockHashAlgorithm',
		proof: 'bytes_array'
	};

	constructor() {
		super();
		this._version = SecretProofTransactionV1.TRANSACTION_VERSION;
		this._type = SecretProofTransactionV1.TRANSACTION_TYPE;
		this._recipientAddress = new UnresolvedAddress();
		this._secret = new Hash256();
		this._hashAlgorithm = LockHashAlgorithm.SHA3_256;
		this._proof = new Uint8Array();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get recipientAddress() {
		return this._recipientAddress;
	}

	set recipientAddress(value) {
		this._recipientAddress = value;
	}

	get secret() {
		return this._secret;
	}

	set secret(value) {
		this._secret = value;
	}

	get hashAlgorithm() {
		return this._hashAlgorithm;
	}

	set hashAlgorithm(value) {
		this._hashAlgorithm = value;
	}

	get proof() {
		return this._proof;
	}

	set proof(value) {
		this._proof = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.recipientAddress.size;
		size += this.secret.size;
		size += 2;
		size += this.hashAlgorithm.size;
		size += this._proof.length;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new SecretProofTransactionV1();

		Transaction._deserialize(view, instance);
		const recipientAddress = UnresolvedAddress.deserialize(view.buffer);
		view.shiftRight(recipientAddress.size);
		const secret = Hash256.deserialize(view.buffer);
		view.shiftRight(secret.size);
		const proofSize = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 2, false);
		view.shiftRight(2);
		const hashAlgorithm = LockHashAlgorithm.deserializeAligned(view.buffer);
		view.shiftRight(hashAlgorithm.size);
		const proof = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, proofSize);
		view.shiftRight(proofSize);

		instance._recipientAddress = recipientAddress;
		instance._secret = secret;
		instance._hashAlgorithm = hashAlgorithm;
		instance._proof = proof;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._recipientAddress.serialize());
		buffer.write(this._secret.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._proof.length, 2, false)); // bound: proof_size
		buffer.write(this._hashAlgorithm.serialize());
		buffer.write(this._proof);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `recipientAddress: ${this._recipientAddress.toString()}, `;
		result += `secret: ${this._secret.toString()}, `;
		result += `hashAlgorithm: ${this._hashAlgorithm.toString()}, `;
		result += `proof: hex(${_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._proof)}), `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.recipientAddress = this._recipientAddress.toJson();
		result.secret = this._secret.toJson();
		result.hashAlgorithm = this._hashAlgorithm.toJson();
		result.proof = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._proof);
		return result;
	}
}

class EmbeddedSecretProofTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.SECRET_PROOF;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		recipientAddress: 'pod:UnresolvedAddress',
		secret: 'pod:Hash256',
		hashAlgorithm: 'enum:LockHashAlgorithm',
		proof: 'bytes_array'
	};

	constructor() {
		super();
		this._version = EmbeddedSecretProofTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedSecretProofTransactionV1.TRANSACTION_TYPE;
		this._recipientAddress = new UnresolvedAddress();
		this._secret = new Hash256();
		this._hashAlgorithm = LockHashAlgorithm.SHA3_256;
		this._proof = new Uint8Array();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get recipientAddress() {
		return this._recipientAddress;
	}

	set recipientAddress(value) {
		this._recipientAddress = value;
	}

	get secret() {
		return this._secret;
	}

	set secret(value) {
		this._secret = value;
	}

	get hashAlgorithm() {
		return this._hashAlgorithm;
	}

	set hashAlgorithm(value) {
		this._hashAlgorithm = value;
	}

	get proof() {
		return this._proof;
	}

	set proof(value) {
		this._proof = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.recipientAddress.size;
		size += this.secret.size;
		size += 2;
		size += this.hashAlgorithm.size;
		size += this._proof.length;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedSecretProofTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const recipientAddress = UnresolvedAddress.deserialize(view.buffer);
		view.shiftRight(recipientAddress.size);
		const secret = Hash256.deserialize(view.buffer);
		view.shiftRight(secret.size);
		const proofSize = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 2, false);
		view.shiftRight(2);
		const hashAlgorithm = LockHashAlgorithm.deserializeAligned(view.buffer);
		view.shiftRight(hashAlgorithm.size);
		const proof = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, proofSize);
		view.shiftRight(proofSize);

		instance._recipientAddress = recipientAddress;
		instance._secret = secret;
		instance._hashAlgorithm = hashAlgorithm;
		instance._proof = proof;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._recipientAddress.serialize());
		buffer.write(this._secret.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._proof.length, 2, false)); // bound: proof_size
		buffer.write(this._hashAlgorithm.serialize());
		buffer.write(this._proof);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `recipientAddress: ${this._recipientAddress.toString()}, `;
		result += `secret: ${this._secret.toString()}, `;
		result += `hashAlgorithm: ${this._hashAlgorithm.toString()}, `;
		result += `proof: hex(${_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._proof)}), `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.recipientAddress = this._recipientAddress.toJson();
		result.secret = this._secret.toJson();
		result.hashAlgorithm = this._hashAlgorithm.toJson();
		result.proof = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._proof);
		return result;
	}
}

class AccountMetadataTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.ACCOUNT_METADATA;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		targetAddress: 'pod:UnresolvedAddress',
		value: 'bytes_array'
	};

	constructor() {
		super();
		this._version = AccountMetadataTransactionV1.TRANSACTION_VERSION;
		this._type = AccountMetadataTransactionV1.TRANSACTION_TYPE;
		this._targetAddress = new UnresolvedAddress();
		this._scopedMetadataKey = 0n;
		this._valueSizeDelta = 0;
		this._value = new Uint8Array();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get targetAddress() {
		return this._targetAddress;
	}

	set targetAddress(value) {
		this._targetAddress = value;
	}

	get scopedMetadataKey() {
		return this._scopedMetadataKey;
	}

	set scopedMetadataKey(value) {
		this._scopedMetadataKey = value;
	}

	get valueSizeDelta() {
		return this._valueSizeDelta;
	}

	set valueSizeDelta(value) {
		this._valueSizeDelta = value;
	}

	get value() {
		return this._value;
	}

	set value(value) {
		this._value = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.targetAddress.size;
		size += 8;
		size += 2;
		size += 2;
		size += this._value.length;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new AccountMetadataTransactionV1();

		Transaction._deserialize(view, instance);
		const targetAddress = UnresolvedAddress.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);
		const scopedMetadataKey = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const valueSizeDelta = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 2, true);
		view.shiftRight(2);
		const valueSize = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 2, false);
		view.shiftRight(2);
		const value = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, valueSize);
		view.shiftRight(valueSize);

		instance._targetAddress = targetAddress;
		instance._scopedMetadataKey = scopedMetadataKey;
		instance._valueSizeDelta = valueSizeDelta;
		instance._value = value;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._targetAddress.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._scopedMetadataKey, 8, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._valueSizeDelta, 2, true));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._value.length, 2, false)); // bound: value_size
		buffer.write(this._value);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `targetAddress: ${this._targetAddress.toString()}, `;
		result += `scopedMetadataKey: ${'0x'.concat(this._scopedMetadataKey.toString(16))}, `;
		result += `valueSizeDelta: ${'0x'.concat(this._valueSizeDelta.toString(16))}, `;
		result += `value: hex(${_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._value)}), `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.targetAddress = this._targetAddress.toJson();
		result.scopedMetadataKey = this._scopedMetadataKey.toString();
		result.valueSizeDelta = this._valueSizeDelta;
		result.value = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._value);
		return result;
	}
}

class EmbeddedAccountMetadataTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.ACCOUNT_METADATA;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		targetAddress: 'pod:UnresolvedAddress',
		value: 'bytes_array'
	};

	constructor() {
		super();
		this._version = EmbeddedAccountMetadataTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedAccountMetadataTransactionV1.TRANSACTION_TYPE;
		this._targetAddress = new UnresolvedAddress();
		this._scopedMetadataKey = 0n;
		this._valueSizeDelta = 0;
		this._value = new Uint8Array();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get targetAddress() {
		return this._targetAddress;
	}

	set targetAddress(value) {
		this._targetAddress = value;
	}

	get scopedMetadataKey() {
		return this._scopedMetadataKey;
	}

	set scopedMetadataKey(value) {
		this._scopedMetadataKey = value;
	}

	get valueSizeDelta() {
		return this._valueSizeDelta;
	}

	set valueSizeDelta(value) {
		this._valueSizeDelta = value;
	}

	get value() {
		return this._value;
	}

	set value(value) {
		this._value = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.targetAddress.size;
		size += 8;
		size += 2;
		size += 2;
		size += this._value.length;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedAccountMetadataTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const targetAddress = UnresolvedAddress.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);
		const scopedMetadataKey = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const valueSizeDelta = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 2, true);
		view.shiftRight(2);
		const valueSize = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 2, false);
		view.shiftRight(2);
		const value = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, valueSize);
		view.shiftRight(valueSize);

		instance._targetAddress = targetAddress;
		instance._scopedMetadataKey = scopedMetadataKey;
		instance._valueSizeDelta = valueSizeDelta;
		instance._value = value;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._targetAddress.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._scopedMetadataKey, 8, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._valueSizeDelta, 2, true));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._value.length, 2, false)); // bound: value_size
		buffer.write(this._value);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `targetAddress: ${this._targetAddress.toString()}, `;
		result += `scopedMetadataKey: ${'0x'.concat(this._scopedMetadataKey.toString(16))}, `;
		result += `valueSizeDelta: ${'0x'.concat(this._valueSizeDelta.toString(16))}, `;
		result += `value: hex(${_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._value)}), `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.targetAddress = this._targetAddress.toJson();
		result.scopedMetadataKey = this._scopedMetadataKey.toString();
		result.valueSizeDelta = this._valueSizeDelta;
		result.value = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._value);
		return result;
	}
}

class MosaicMetadataTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.MOSAIC_METADATA;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		targetAddress: 'pod:UnresolvedAddress',
		targetMosaicId: 'pod:UnresolvedMosaicId',
		value: 'bytes_array'
	};

	constructor() {
		super();
		this._version = MosaicMetadataTransactionV1.TRANSACTION_VERSION;
		this._type = MosaicMetadataTransactionV1.TRANSACTION_TYPE;
		this._targetAddress = new UnresolvedAddress();
		this._scopedMetadataKey = 0n;
		this._targetMosaicId = new UnresolvedMosaicId();
		this._valueSizeDelta = 0;
		this._value = new Uint8Array();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get targetAddress() {
		return this._targetAddress;
	}

	set targetAddress(value) {
		this._targetAddress = value;
	}

	get scopedMetadataKey() {
		return this._scopedMetadataKey;
	}

	set scopedMetadataKey(value) {
		this._scopedMetadataKey = value;
	}

	get targetMosaicId() {
		return this._targetMosaicId;
	}

	set targetMosaicId(value) {
		this._targetMosaicId = value;
	}

	get valueSizeDelta() {
		return this._valueSizeDelta;
	}

	set valueSizeDelta(value) {
		this._valueSizeDelta = value;
	}

	get value() {
		return this._value;
	}

	set value(value) {
		this._value = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.targetAddress.size;
		size += 8;
		size += this.targetMosaicId.size;
		size += 2;
		size += 2;
		size += this._value.length;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new MosaicMetadataTransactionV1();

		Transaction._deserialize(view, instance);
		const targetAddress = UnresolvedAddress.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);
		const scopedMetadataKey = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const targetMosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);
		view.shiftRight(targetMosaicId.size);
		const valueSizeDelta = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 2, true);
		view.shiftRight(2);
		const valueSize = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 2, false);
		view.shiftRight(2);
		const value = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, valueSize);
		view.shiftRight(valueSize);

		instance._targetAddress = targetAddress;
		instance._scopedMetadataKey = scopedMetadataKey;
		instance._targetMosaicId = targetMosaicId;
		instance._valueSizeDelta = valueSizeDelta;
		instance._value = value;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._targetAddress.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._scopedMetadataKey, 8, false));
		buffer.write(this._targetMosaicId.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._valueSizeDelta, 2, true));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._value.length, 2, false)); // bound: value_size
		buffer.write(this._value);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `targetAddress: ${this._targetAddress.toString()}, `;
		result += `scopedMetadataKey: ${'0x'.concat(this._scopedMetadataKey.toString(16))}, `;
		result += `targetMosaicId: ${this._targetMosaicId.toString()}, `;
		result += `valueSizeDelta: ${'0x'.concat(this._valueSizeDelta.toString(16))}, `;
		result += `value: hex(${_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._value)}), `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.targetAddress = this._targetAddress.toJson();
		result.scopedMetadataKey = this._scopedMetadataKey.toString();
		result.targetMosaicId = this._targetMosaicId.toJson();
		result.valueSizeDelta = this._valueSizeDelta;
		result.value = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._value);
		return result;
	}
}

class EmbeddedMosaicMetadataTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.MOSAIC_METADATA;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		targetAddress: 'pod:UnresolvedAddress',
		targetMosaicId: 'pod:UnresolvedMosaicId',
		value: 'bytes_array'
	};

	constructor() {
		super();
		this._version = EmbeddedMosaicMetadataTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedMosaicMetadataTransactionV1.TRANSACTION_TYPE;
		this._targetAddress = new UnresolvedAddress();
		this._scopedMetadataKey = 0n;
		this._targetMosaicId = new UnresolvedMosaicId();
		this._valueSizeDelta = 0;
		this._value = new Uint8Array();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get targetAddress() {
		return this._targetAddress;
	}

	set targetAddress(value) {
		this._targetAddress = value;
	}

	get scopedMetadataKey() {
		return this._scopedMetadataKey;
	}

	set scopedMetadataKey(value) {
		this._scopedMetadataKey = value;
	}

	get targetMosaicId() {
		return this._targetMosaicId;
	}

	set targetMosaicId(value) {
		this._targetMosaicId = value;
	}

	get valueSizeDelta() {
		return this._valueSizeDelta;
	}

	set valueSizeDelta(value) {
		this._valueSizeDelta = value;
	}

	get value() {
		return this._value;
	}

	set value(value) {
		this._value = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.targetAddress.size;
		size += 8;
		size += this.targetMosaicId.size;
		size += 2;
		size += 2;
		size += this._value.length;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedMosaicMetadataTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const targetAddress = UnresolvedAddress.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);
		const scopedMetadataKey = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const targetMosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);
		view.shiftRight(targetMosaicId.size);
		const valueSizeDelta = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 2, true);
		view.shiftRight(2);
		const valueSize = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 2, false);
		view.shiftRight(2);
		const value = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, valueSize);
		view.shiftRight(valueSize);

		instance._targetAddress = targetAddress;
		instance._scopedMetadataKey = scopedMetadataKey;
		instance._targetMosaicId = targetMosaicId;
		instance._valueSizeDelta = valueSizeDelta;
		instance._value = value;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._targetAddress.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._scopedMetadataKey, 8, false));
		buffer.write(this._targetMosaicId.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._valueSizeDelta, 2, true));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._value.length, 2, false)); // bound: value_size
		buffer.write(this._value);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `targetAddress: ${this._targetAddress.toString()}, `;
		result += `scopedMetadataKey: ${'0x'.concat(this._scopedMetadataKey.toString(16))}, `;
		result += `targetMosaicId: ${this._targetMosaicId.toString()}, `;
		result += `valueSizeDelta: ${'0x'.concat(this._valueSizeDelta.toString(16))}, `;
		result += `value: hex(${_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._value)}), `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.targetAddress = this._targetAddress.toJson();
		result.scopedMetadataKey = this._scopedMetadataKey.toString();
		result.targetMosaicId = this._targetMosaicId.toJson();
		result.valueSizeDelta = this._valueSizeDelta;
		result.value = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._value);
		return result;
	}
}

class NamespaceMetadataTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.NAMESPACE_METADATA;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		targetAddress: 'pod:UnresolvedAddress',
		targetNamespaceId: 'pod:NamespaceId',
		value: 'bytes_array'
	};

	constructor() {
		super();
		this._version = NamespaceMetadataTransactionV1.TRANSACTION_VERSION;
		this._type = NamespaceMetadataTransactionV1.TRANSACTION_TYPE;
		this._targetAddress = new UnresolvedAddress();
		this._scopedMetadataKey = 0n;
		this._targetNamespaceId = new NamespaceId();
		this._valueSizeDelta = 0;
		this._value = new Uint8Array();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get targetAddress() {
		return this._targetAddress;
	}

	set targetAddress(value) {
		this._targetAddress = value;
	}

	get scopedMetadataKey() {
		return this._scopedMetadataKey;
	}

	set scopedMetadataKey(value) {
		this._scopedMetadataKey = value;
	}

	get targetNamespaceId() {
		return this._targetNamespaceId;
	}

	set targetNamespaceId(value) {
		this._targetNamespaceId = value;
	}

	get valueSizeDelta() {
		return this._valueSizeDelta;
	}

	set valueSizeDelta(value) {
		this._valueSizeDelta = value;
	}

	get value() {
		return this._value;
	}

	set value(value) {
		this._value = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.targetAddress.size;
		size += 8;
		size += this.targetNamespaceId.size;
		size += 2;
		size += 2;
		size += this._value.length;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new NamespaceMetadataTransactionV1();

		Transaction._deserialize(view, instance);
		const targetAddress = UnresolvedAddress.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);
		const scopedMetadataKey = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const targetNamespaceId = NamespaceId.deserializeAligned(view.buffer);
		view.shiftRight(targetNamespaceId.size);
		const valueSizeDelta = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 2, true);
		view.shiftRight(2);
		const valueSize = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 2, false);
		view.shiftRight(2);
		const value = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, valueSize);
		view.shiftRight(valueSize);

		instance._targetAddress = targetAddress;
		instance._scopedMetadataKey = scopedMetadataKey;
		instance._targetNamespaceId = targetNamespaceId;
		instance._valueSizeDelta = valueSizeDelta;
		instance._value = value;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._targetAddress.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._scopedMetadataKey, 8, false));
		buffer.write(this._targetNamespaceId.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._valueSizeDelta, 2, true));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._value.length, 2, false)); // bound: value_size
		buffer.write(this._value);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `targetAddress: ${this._targetAddress.toString()}, `;
		result += `scopedMetadataKey: ${'0x'.concat(this._scopedMetadataKey.toString(16))}, `;
		result += `targetNamespaceId: ${this._targetNamespaceId.toString()}, `;
		result += `valueSizeDelta: ${'0x'.concat(this._valueSizeDelta.toString(16))}, `;
		result += `value: hex(${_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._value)}), `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.targetAddress = this._targetAddress.toJson();
		result.scopedMetadataKey = this._scopedMetadataKey.toString();
		result.targetNamespaceId = this._targetNamespaceId.toJson();
		result.valueSizeDelta = this._valueSizeDelta;
		result.value = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._value);
		return result;
	}
}

class EmbeddedNamespaceMetadataTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.NAMESPACE_METADATA;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		targetAddress: 'pod:UnresolvedAddress',
		targetNamespaceId: 'pod:NamespaceId',
		value: 'bytes_array'
	};

	constructor() {
		super();
		this._version = EmbeddedNamespaceMetadataTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedNamespaceMetadataTransactionV1.TRANSACTION_TYPE;
		this._targetAddress = new UnresolvedAddress();
		this._scopedMetadataKey = 0n;
		this._targetNamespaceId = new NamespaceId();
		this._valueSizeDelta = 0;
		this._value = new Uint8Array();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get targetAddress() {
		return this._targetAddress;
	}

	set targetAddress(value) {
		this._targetAddress = value;
	}

	get scopedMetadataKey() {
		return this._scopedMetadataKey;
	}

	set scopedMetadataKey(value) {
		this._scopedMetadataKey = value;
	}

	get targetNamespaceId() {
		return this._targetNamespaceId;
	}

	set targetNamespaceId(value) {
		this._targetNamespaceId = value;
	}

	get valueSizeDelta() {
		return this._valueSizeDelta;
	}

	set valueSizeDelta(value) {
		this._valueSizeDelta = value;
	}

	get value() {
		return this._value;
	}

	set value(value) {
		this._value = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.targetAddress.size;
		size += 8;
		size += this.targetNamespaceId.size;
		size += 2;
		size += 2;
		size += this._value.length;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedNamespaceMetadataTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const targetAddress = UnresolvedAddress.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);
		const scopedMetadataKey = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const targetNamespaceId = NamespaceId.deserializeAligned(view.buffer);
		view.shiftRight(targetNamespaceId.size);
		const valueSizeDelta = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 2, true);
		view.shiftRight(2);
		const valueSize = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 2, false);
		view.shiftRight(2);
		const value = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, valueSize);
		view.shiftRight(valueSize);

		instance._targetAddress = targetAddress;
		instance._scopedMetadataKey = scopedMetadataKey;
		instance._targetNamespaceId = targetNamespaceId;
		instance._valueSizeDelta = valueSizeDelta;
		instance._value = value;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._targetAddress.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._scopedMetadataKey, 8, false));
		buffer.write(this._targetNamespaceId.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._valueSizeDelta, 2, true));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._value.length, 2, false)); // bound: value_size
		buffer.write(this._value);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `targetAddress: ${this._targetAddress.toString()}, `;
		result += `scopedMetadataKey: ${'0x'.concat(this._scopedMetadataKey.toString(16))}, `;
		result += `targetNamespaceId: ${this._targetNamespaceId.toString()}, `;
		result += `valueSizeDelta: ${'0x'.concat(this._valueSizeDelta.toString(16))}, `;
		result += `value: hex(${_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._value)}), `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.targetAddress = this._targetAddress.toJson();
		result.scopedMetadataKey = this._scopedMetadataKey.toString();
		result.targetNamespaceId = this._targetNamespaceId.toJson();
		result.valueSizeDelta = this._valueSizeDelta;
		result.value = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._value);
		return result;
	}
}

class MosaicNonce extends _BaseValue_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
	static SIZE = 4;

	constructor(mosaicNonce = 0) {
		super(MosaicNonce.SIZE, mosaicNonce);
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new MosaicNonce(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(byteArray, 4, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return new MosaicNonce(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(byteArray, 4, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 4, false);
	}
}

class MosaicFlags {
	static NONE = new MosaicFlags(0);

	static SUPPLY_MUTABLE = new MosaicFlags(1);

	static TRANSFERABLE = new MosaicFlags(2);

	static RESTRICTABLE = new MosaicFlags(4);

	static REVOKABLE = new MosaicFlags(8);

	constructor(value) {
		this.value = value;
	}

	has(flag) {
		return 0 !== (this.value & flag);
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 1;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new MosaicFlags(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(byteArray, 1, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return new MosaicFlags(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(byteArray, 1, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 1, false);
	}

	toString() {
		const values = [
			0, 1, 2, 4, 8
		];
		const keys = [
			'NONE', 'SUPPLY_MUTABLE', 'TRANSFERABLE', 'RESTRICTABLE', 'REVOKABLE'
		];

		if (0 === this.value) {
			const index = values.indexOf(this.value);
			return `MosaicFlags.${keys[index]}`;
		}

		const positions = values.map(flag => (this.value & flag)).filter(n => n).map(n => values.indexOf(n));
		return positions.map(n => `MosaicFlags.${keys[n]}`).join('|');
	}

	toJson() {
		return this.value;
	}
}

class MosaicSupplyChangeAction {
	static DECREASE = new MosaicSupplyChangeAction(0);

	static INCREASE = new MosaicSupplyChangeAction(1);

	constructor(value) {
		this.value = value;
	}

	static valueToKey(value) {
		const values = [
			0, 1
		];
		const keys = [
			'DECREASE', 'INCREASE'
		];

		const index = values.indexOf(value);
		if (-1 === index)
			throw RangeError(`invalid enum value ${value}`);

		return keys[index];
	}

	static fromValue(value) {
		return MosaicSupplyChangeAction[this.valueToKey(value)];
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 1;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(byteArray, 1, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(byteArray, 1, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 1, false);
	}

	toString() {
		return `MosaicSupplyChangeAction.${MosaicSupplyChangeAction.valueToKey(this.value)}`;
	}

	toJson() {
		return this.value;
	}
}

class MosaicDefinitionTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.MOSAIC_DEFINITION;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		id: 'pod:MosaicId',
		duration: 'pod:BlockDuration',
		nonce: 'pod:MosaicNonce',
		flags: 'enum:MosaicFlags'
	};

	constructor() {
		super();
		this._version = MosaicDefinitionTransactionV1.TRANSACTION_VERSION;
		this._type = MosaicDefinitionTransactionV1.TRANSACTION_TYPE;
		this._id = new MosaicId();
		this._duration = new BlockDuration();
		this._nonce = new MosaicNonce();
		this._flags = MosaicFlags.NONE;
		this._divisibility = 0;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get id() {
		return this._id;
	}

	set id(value) {
		this._id = value;
	}

	get duration() {
		return this._duration;
	}

	set duration(value) {
		this._duration = value;
	}

	get nonce() {
		return this._nonce;
	}

	set nonce(value) {
		this._nonce = value;
	}

	get flags() {
		return this._flags;
	}

	set flags(value) {
		this._flags = value;
	}

	get divisibility() {
		return this._divisibility;
	}

	set divisibility(value) {
		this._divisibility = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.id.size;
		size += this.duration.size;
		size += this.nonce.size;
		size += this.flags.size;
		size += 1;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new MosaicDefinitionTransactionV1();

		Transaction._deserialize(view, instance);
		const id = MosaicId.deserializeAligned(view.buffer);
		view.shiftRight(id.size);
		const duration = BlockDuration.deserializeAligned(view.buffer);
		view.shiftRight(duration.size);
		const nonce = MosaicNonce.deserializeAligned(view.buffer);
		view.shiftRight(nonce.size);
		const flags = MosaicFlags.deserializeAligned(view.buffer);
		view.shiftRight(flags.size);
		const divisibility = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);

		instance._id = id;
		instance._duration = duration;
		instance._nonce = nonce;
		instance._flags = flags;
		instance._divisibility = divisibility;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._id.serialize());
		buffer.write(this._duration.serialize());
		buffer.write(this._nonce.serialize());
		buffer.write(this._flags.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._divisibility, 1, false));
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `id: ${this._id.toString()}, `;
		result += `duration: ${this._duration.toString()}, `;
		result += `nonce: ${this._nonce.toString()}, `;
		result += `flags: ${this._flags.toString()}, `;
		result += `divisibility: ${'0x'.concat(this._divisibility.toString(16))}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.id = this._id.toJson();
		result.duration = this._duration.toJson();
		result.nonce = this._nonce.toJson();
		result.flags = this._flags.toJson();
		result.divisibility = this._divisibility;
		return result;
	}
}

class EmbeddedMosaicDefinitionTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.MOSAIC_DEFINITION;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		id: 'pod:MosaicId',
		duration: 'pod:BlockDuration',
		nonce: 'pod:MosaicNonce',
		flags: 'enum:MosaicFlags'
	};

	constructor() {
		super();
		this._version = EmbeddedMosaicDefinitionTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedMosaicDefinitionTransactionV1.TRANSACTION_TYPE;
		this._id = new MosaicId();
		this._duration = new BlockDuration();
		this._nonce = new MosaicNonce();
		this._flags = MosaicFlags.NONE;
		this._divisibility = 0;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get id() {
		return this._id;
	}

	set id(value) {
		this._id = value;
	}

	get duration() {
		return this._duration;
	}

	set duration(value) {
		this._duration = value;
	}

	get nonce() {
		return this._nonce;
	}

	set nonce(value) {
		this._nonce = value;
	}

	get flags() {
		return this._flags;
	}

	set flags(value) {
		this._flags = value;
	}

	get divisibility() {
		return this._divisibility;
	}

	set divisibility(value) {
		this._divisibility = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.id.size;
		size += this.duration.size;
		size += this.nonce.size;
		size += this.flags.size;
		size += 1;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedMosaicDefinitionTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const id = MosaicId.deserializeAligned(view.buffer);
		view.shiftRight(id.size);
		const duration = BlockDuration.deserializeAligned(view.buffer);
		view.shiftRight(duration.size);
		const nonce = MosaicNonce.deserializeAligned(view.buffer);
		view.shiftRight(nonce.size);
		const flags = MosaicFlags.deserializeAligned(view.buffer);
		view.shiftRight(flags.size);
		const divisibility = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);

		instance._id = id;
		instance._duration = duration;
		instance._nonce = nonce;
		instance._flags = flags;
		instance._divisibility = divisibility;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._id.serialize());
		buffer.write(this._duration.serialize());
		buffer.write(this._nonce.serialize());
		buffer.write(this._flags.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._divisibility, 1, false));
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `id: ${this._id.toString()}, `;
		result += `duration: ${this._duration.toString()}, `;
		result += `nonce: ${this._nonce.toString()}, `;
		result += `flags: ${this._flags.toString()}, `;
		result += `divisibility: ${'0x'.concat(this._divisibility.toString(16))}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.id = this._id.toJson();
		result.duration = this._duration.toJson();
		result.nonce = this._nonce.toJson();
		result.flags = this._flags.toJson();
		result.divisibility = this._divisibility;
		return result;
	}
}

class MosaicSupplyChangeTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.MOSAIC_SUPPLY_CHANGE;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		mosaicId: 'pod:UnresolvedMosaicId',
		delta: 'pod:Amount',
		action: 'enum:MosaicSupplyChangeAction'
	};

	constructor() {
		super();
		this._version = MosaicSupplyChangeTransactionV1.TRANSACTION_VERSION;
		this._type = MosaicSupplyChangeTransactionV1.TRANSACTION_TYPE;
		this._mosaicId = new UnresolvedMosaicId();
		this._delta = new Amount();
		this._action = MosaicSupplyChangeAction.DECREASE;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get mosaicId() {
		return this._mosaicId;
	}

	set mosaicId(value) {
		this._mosaicId = value;
	}

	get delta() {
		return this._delta;
	}

	set delta(value) {
		this._delta = value;
	}

	get action() {
		return this._action;
	}

	set action(value) {
		this._action = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.mosaicId.size;
		size += this.delta.size;
		size += this.action.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new MosaicSupplyChangeTransactionV1();

		Transaction._deserialize(view, instance);
		const mosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);
		view.shiftRight(mosaicId.size);
		const delta = Amount.deserializeAligned(view.buffer);
		view.shiftRight(delta.size);
		const action = MosaicSupplyChangeAction.deserializeAligned(view.buffer);
		view.shiftRight(action.size);

		instance._mosaicId = mosaicId;
		instance._delta = delta;
		instance._action = action;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._mosaicId.serialize());
		buffer.write(this._delta.serialize());
		buffer.write(this._action.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `mosaicId: ${this._mosaicId.toString()}, `;
		result += `delta: ${this._delta.toString()}, `;
		result += `action: ${this._action.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.mosaicId = this._mosaicId.toJson();
		result.delta = this._delta.toJson();
		result.action = this._action.toJson();
		return result;
	}
}

class EmbeddedMosaicSupplyChangeTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.MOSAIC_SUPPLY_CHANGE;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		mosaicId: 'pod:UnresolvedMosaicId',
		delta: 'pod:Amount',
		action: 'enum:MosaicSupplyChangeAction'
	};

	constructor() {
		super();
		this._version = EmbeddedMosaicSupplyChangeTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedMosaicSupplyChangeTransactionV1.TRANSACTION_TYPE;
		this._mosaicId = new UnresolvedMosaicId();
		this._delta = new Amount();
		this._action = MosaicSupplyChangeAction.DECREASE;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get mosaicId() {
		return this._mosaicId;
	}

	set mosaicId(value) {
		this._mosaicId = value;
	}

	get delta() {
		return this._delta;
	}

	set delta(value) {
		this._delta = value;
	}

	get action() {
		return this._action;
	}

	set action(value) {
		this._action = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.mosaicId.size;
		size += this.delta.size;
		size += this.action.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedMosaicSupplyChangeTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const mosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);
		view.shiftRight(mosaicId.size);
		const delta = Amount.deserializeAligned(view.buffer);
		view.shiftRight(delta.size);
		const action = MosaicSupplyChangeAction.deserializeAligned(view.buffer);
		view.shiftRight(action.size);

		instance._mosaicId = mosaicId;
		instance._delta = delta;
		instance._action = action;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._mosaicId.serialize());
		buffer.write(this._delta.serialize());
		buffer.write(this._action.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `mosaicId: ${this._mosaicId.toString()}, `;
		result += `delta: ${this._delta.toString()}, `;
		result += `action: ${this._action.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.mosaicId = this._mosaicId.toJson();
		result.delta = this._delta.toJson();
		result.action = this._action.toJson();
		return result;
	}
}

class MosaicSupplyRevocationTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.MOSAIC_SUPPLY_REVOCATION;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		sourceAddress: 'pod:UnresolvedAddress',
		mosaic: 'struct:UnresolvedMosaic'
	};

	constructor() {
		super();
		this._version = MosaicSupplyRevocationTransactionV1.TRANSACTION_VERSION;
		this._type = MosaicSupplyRevocationTransactionV1.TRANSACTION_TYPE;
		this._sourceAddress = new UnresolvedAddress();
		this._mosaic = new UnresolvedMosaic();
	}

	sort() {
		this._mosaic.sort();
	}

	get sourceAddress() {
		return this._sourceAddress;
	}

	set sourceAddress(value) {
		this._sourceAddress = value;
	}

	get mosaic() {
		return this._mosaic;
	}

	set mosaic(value) {
		this._mosaic = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.sourceAddress.size;
		size += this.mosaic.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new MosaicSupplyRevocationTransactionV1();

		Transaction._deserialize(view, instance);
		const sourceAddress = UnresolvedAddress.deserialize(view.buffer);
		view.shiftRight(sourceAddress.size);
		const mosaic = UnresolvedMosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);

		instance._sourceAddress = sourceAddress;
		instance._mosaic = mosaic;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._sourceAddress.serialize());
		buffer.write(this._mosaic.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `sourceAddress: ${this._sourceAddress.toString()}, `;
		result += `mosaic: ${this._mosaic.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.sourceAddress = this._sourceAddress.toJson();
		result.mosaic = this._mosaic.toJson();
		return result;
	}
}

class EmbeddedMosaicSupplyRevocationTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.MOSAIC_SUPPLY_REVOCATION;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		sourceAddress: 'pod:UnresolvedAddress',
		mosaic: 'struct:UnresolvedMosaic'
	};

	constructor() {
		super();
		this._version = EmbeddedMosaicSupplyRevocationTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedMosaicSupplyRevocationTransactionV1.TRANSACTION_TYPE;
		this._sourceAddress = new UnresolvedAddress();
		this._mosaic = new UnresolvedMosaic();
	}

	sort() {
		this._mosaic.sort();
	}

	get sourceAddress() {
		return this._sourceAddress;
	}

	set sourceAddress(value) {
		this._sourceAddress = value;
	}

	get mosaic() {
		return this._mosaic;
	}

	set mosaic(value) {
		this._mosaic = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.sourceAddress.size;
		size += this.mosaic.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedMosaicSupplyRevocationTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const sourceAddress = UnresolvedAddress.deserialize(view.buffer);
		view.shiftRight(sourceAddress.size);
		const mosaic = UnresolvedMosaic.deserialize(view.buffer);
		view.shiftRight(mosaic.size);

		instance._sourceAddress = sourceAddress;
		instance._mosaic = mosaic;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._sourceAddress.serialize());
		buffer.write(this._mosaic.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `sourceAddress: ${this._sourceAddress.toString()}, `;
		result += `mosaic: ${this._mosaic.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.sourceAddress = this._sourceAddress.toJson();
		result.mosaic = this._mosaic.toJson();
		return result;
	}
}

class MultisigAccountModificationTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.MULTISIG_ACCOUNT_MODIFICATION;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		addressAdditions: 'array[UnresolvedAddress]',
		addressDeletions: 'array[UnresolvedAddress]'
	};

	constructor() {
		super();
		this._version = MultisigAccountModificationTransactionV1.TRANSACTION_VERSION;
		this._type = MultisigAccountModificationTransactionV1.TRANSACTION_TYPE;
		this._minRemovalDelta = 0;
		this._minApprovalDelta = 0;
		this._addressAdditions = [];
		this._addressDeletions = [];
		this._multisigAccountModificationTransactionBodyReserved_1 = 0; // reserved field
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get minRemovalDelta() {
		return this._minRemovalDelta;
	}

	set minRemovalDelta(value) {
		this._minRemovalDelta = value;
	}

	get minApprovalDelta() {
		return this._minApprovalDelta;
	}

	set minApprovalDelta(value) {
		this._minApprovalDelta = value;
	}

	get addressAdditions() {
		return this._addressAdditions;
	}

	set addressAdditions(value) {
		this._addressAdditions = value;
	}

	get addressDeletions() {
		return this._addressDeletions;
	}

	set addressDeletions(value) {
		this._addressDeletions = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += 1;
		size += 1;
		size += 1;
		size += 1;
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.addressAdditions);
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.addressDeletions);
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new MultisigAccountModificationTransactionV1();

		Transaction._deserialize(view, instance);
		const minRemovalDelta = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, true);
		view.shiftRight(1);
		const minApprovalDelta = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, true);
		view.shiftRight(1);
		const addressAdditionsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const addressDeletionsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const multisigAccountModificationTransactionBodyReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== multisigAccountModificationTransactionBodyReserved_1)
			throw RangeError(`Invalid value of reserved field (${multisigAccountModificationTransactionBodyReserved_1})`);
		const addressAdditions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, UnresolvedAddress, addressAdditionsCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(addressAdditions));
		const addressDeletions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, UnresolvedAddress, addressDeletionsCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(addressDeletions));

		instance._minRemovalDelta = minRemovalDelta;
		instance._minApprovalDelta = minApprovalDelta;
		instance._addressAdditions = addressAdditions;
		instance._addressDeletions = addressDeletions;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._minRemovalDelta, 1, true));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._minApprovalDelta, 1, true));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._addressAdditions.length, 1, false)); // bound: address_additions_count
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._addressDeletions.length, 1, false)); // bound: address_deletions_count
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._multisigAccountModificationTransactionBodyReserved_1, 4, false));
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._addressAdditions);
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._addressDeletions);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `minRemovalDelta: ${'0x'.concat(this._minRemovalDelta.toString(16))}, `;
		result += `minApprovalDelta: ${'0x'.concat(this._minApprovalDelta.toString(16))}, `;
		result += `addressAdditions: [${this._addressAdditions.map(e => e.toString()).join(',')}], `;
		result += `addressDeletions: [${this._addressDeletions.map(e => e.toString()).join(',')}], `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.minRemovalDelta = this._minRemovalDelta;
		result.minApprovalDelta = this._minApprovalDelta;
		result.addressAdditions = this._addressAdditions.map(e => e.toJson());
		result.addressDeletions = this._addressDeletions.map(e => e.toJson());
		return result;
	}
}

class EmbeddedMultisigAccountModificationTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.MULTISIG_ACCOUNT_MODIFICATION;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		addressAdditions: 'array[UnresolvedAddress]',
		addressDeletions: 'array[UnresolvedAddress]'
	};

	constructor() {
		super();
		this._version = EmbeddedMultisigAccountModificationTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedMultisigAccountModificationTransactionV1.TRANSACTION_TYPE;
		this._minRemovalDelta = 0;
		this._minApprovalDelta = 0;
		this._addressAdditions = [];
		this._addressDeletions = [];
		this._multisigAccountModificationTransactionBodyReserved_1 = 0; // reserved field
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get minRemovalDelta() {
		return this._minRemovalDelta;
	}

	set minRemovalDelta(value) {
		this._minRemovalDelta = value;
	}

	get minApprovalDelta() {
		return this._minApprovalDelta;
	}

	set minApprovalDelta(value) {
		this._minApprovalDelta = value;
	}

	get addressAdditions() {
		return this._addressAdditions;
	}

	set addressAdditions(value) {
		this._addressAdditions = value;
	}

	get addressDeletions() {
		return this._addressDeletions;
	}

	set addressDeletions(value) {
		this._addressDeletions = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += 1;
		size += 1;
		size += 1;
		size += 1;
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.addressAdditions);
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.addressDeletions);
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedMultisigAccountModificationTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const minRemovalDelta = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, true);
		view.shiftRight(1);
		const minApprovalDelta = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, true);
		view.shiftRight(1);
		const addressAdditionsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const addressDeletionsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const multisigAccountModificationTransactionBodyReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== multisigAccountModificationTransactionBodyReserved_1)
			throw RangeError(`Invalid value of reserved field (${multisigAccountModificationTransactionBodyReserved_1})`);
		const addressAdditions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, UnresolvedAddress, addressAdditionsCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(addressAdditions));
		const addressDeletions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, UnresolvedAddress, addressDeletionsCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(addressDeletions));

		instance._minRemovalDelta = minRemovalDelta;
		instance._minApprovalDelta = minApprovalDelta;
		instance._addressAdditions = addressAdditions;
		instance._addressDeletions = addressDeletions;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._minRemovalDelta, 1, true));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._minApprovalDelta, 1, true));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._addressAdditions.length, 1, false)); // bound: address_additions_count
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._addressDeletions.length, 1, false)); // bound: address_deletions_count
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._multisigAccountModificationTransactionBodyReserved_1, 4, false));
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._addressAdditions);
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._addressDeletions);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `minRemovalDelta: ${'0x'.concat(this._minRemovalDelta.toString(16))}, `;
		result += `minApprovalDelta: ${'0x'.concat(this._minApprovalDelta.toString(16))}, `;
		result += `addressAdditions: [${this._addressAdditions.map(e => e.toString()).join(',')}], `;
		result += `addressDeletions: [${this._addressDeletions.map(e => e.toString()).join(',')}], `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.minRemovalDelta = this._minRemovalDelta;
		result.minApprovalDelta = this._minApprovalDelta;
		result.addressAdditions = this._addressAdditions.map(e => e.toJson());
		result.addressDeletions = this._addressDeletions.map(e => e.toJson());
		return result;
	}
}

class AddressAliasTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.ADDRESS_ALIAS;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		namespaceId: 'pod:NamespaceId',
		address: 'pod:Address',
		aliasAction: 'enum:AliasAction'
	};

	constructor() {
		super();
		this._version = AddressAliasTransactionV1.TRANSACTION_VERSION;
		this._type = AddressAliasTransactionV1.TRANSACTION_TYPE;
		this._namespaceId = new NamespaceId();
		this._address = new Address();
		this._aliasAction = AliasAction.UNLINK;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get namespaceId() {
		return this._namespaceId;
	}

	set namespaceId(value) {
		this._namespaceId = value;
	}

	get address() {
		return this._address;
	}

	set address(value) {
		this._address = value;
	}

	get aliasAction() {
		return this._aliasAction;
	}

	set aliasAction(value) {
		this._aliasAction = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.namespaceId.size;
		size += this.address.size;
		size += this.aliasAction.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new AddressAliasTransactionV1();

		Transaction._deserialize(view, instance);
		const namespaceId = NamespaceId.deserializeAligned(view.buffer);
		view.shiftRight(namespaceId.size);
		const address = Address.deserialize(view.buffer);
		view.shiftRight(address.size);
		const aliasAction = AliasAction.deserializeAligned(view.buffer);
		view.shiftRight(aliasAction.size);

		instance._namespaceId = namespaceId;
		instance._address = address;
		instance._aliasAction = aliasAction;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._namespaceId.serialize());
		buffer.write(this._address.serialize());
		buffer.write(this._aliasAction.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `namespaceId: ${this._namespaceId.toString()}, `;
		result += `address: ${this._address.toString()}, `;
		result += `aliasAction: ${this._aliasAction.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.namespaceId = this._namespaceId.toJson();
		result.address = this._address.toJson();
		result.aliasAction = this._aliasAction.toJson();
		return result;
	}
}

class EmbeddedAddressAliasTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.ADDRESS_ALIAS;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		namespaceId: 'pod:NamespaceId',
		address: 'pod:Address',
		aliasAction: 'enum:AliasAction'
	};

	constructor() {
		super();
		this._version = EmbeddedAddressAliasTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedAddressAliasTransactionV1.TRANSACTION_TYPE;
		this._namespaceId = new NamespaceId();
		this._address = new Address();
		this._aliasAction = AliasAction.UNLINK;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get namespaceId() {
		return this._namespaceId;
	}

	set namespaceId(value) {
		this._namespaceId = value;
	}

	get address() {
		return this._address;
	}

	set address(value) {
		this._address = value;
	}

	get aliasAction() {
		return this._aliasAction;
	}

	set aliasAction(value) {
		this._aliasAction = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.namespaceId.size;
		size += this.address.size;
		size += this.aliasAction.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedAddressAliasTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const namespaceId = NamespaceId.deserializeAligned(view.buffer);
		view.shiftRight(namespaceId.size);
		const address = Address.deserialize(view.buffer);
		view.shiftRight(address.size);
		const aliasAction = AliasAction.deserializeAligned(view.buffer);
		view.shiftRight(aliasAction.size);

		instance._namespaceId = namespaceId;
		instance._address = address;
		instance._aliasAction = aliasAction;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._namespaceId.serialize());
		buffer.write(this._address.serialize());
		buffer.write(this._aliasAction.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `namespaceId: ${this._namespaceId.toString()}, `;
		result += `address: ${this._address.toString()}, `;
		result += `aliasAction: ${this._aliasAction.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.namespaceId = this._namespaceId.toJson();
		result.address = this._address.toJson();
		result.aliasAction = this._aliasAction.toJson();
		return result;
	}
}

class MosaicAliasTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.MOSAIC_ALIAS;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		namespaceId: 'pod:NamespaceId',
		mosaicId: 'pod:MosaicId',
		aliasAction: 'enum:AliasAction'
	};

	constructor() {
		super();
		this._version = MosaicAliasTransactionV1.TRANSACTION_VERSION;
		this._type = MosaicAliasTransactionV1.TRANSACTION_TYPE;
		this._namespaceId = new NamespaceId();
		this._mosaicId = new MosaicId();
		this._aliasAction = AliasAction.UNLINK;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get namespaceId() {
		return this._namespaceId;
	}

	set namespaceId(value) {
		this._namespaceId = value;
	}

	get mosaicId() {
		return this._mosaicId;
	}

	set mosaicId(value) {
		this._mosaicId = value;
	}

	get aliasAction() {
		return this._aliasAction;
	}

	set aliasAction(value) {
		this._aliasAction = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.namespaceId.size;
		size += this.mosaicId.size;
		size += this.aliasAction.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new MosaicAliasTransactionV1();

		Transaction._deserialize(view, instance);
		const namespaceId = NamespaceId.deserializeAligned(view.buffer);
		view.shiftRight(namespaceId.size);
		const mosaicId = MosaicId.deserializeAligned(view.buffer);
		view.shiftRight(mosaicId.size);
		const aliasAction = AliasAction.deserializeAligned(view.buffer);
		view.shiftRight(aliasAction.size);

		instance._namespaceId = namespaceId;
		instance._mosaicId = mosaicId;
		instance._aliasAction = aliasAction;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._namespaceId.serialize());
		buffer.write(this._mosaicId.serialize());
		buffer.write(this._aliasAction.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `namespaceId: ${this._namespaceId.toString()}, `;
		result += `mosaicId: ${this._mosaicId.toString()}, `;
		result += `aliasAction: ${this._aliasAction.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.namespaceId = this._namespaceId.toJson();
		result.mosaicId = this._mosaicId.toJson();
		result.aliasAction = this._aliasAction.toJson();
		return result;
	}
}

class EmbeddedMosaicAliasTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.MOSAIC_ALIAS;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		namespaceId: 'pod:NamespaceId',
		mosaicId: 'pod:MosaicId',
		aliasAction: 'enum:AliasAction'
	};

	constructor() {
		super();
		this._version = EmbeddedMosaicAliasTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedMosaicAliasTransactionV1.TRANSACTION_TYPE;
		this._namespaceId = new NamespaceId();
		this._mosaicId = new MosaicId();
		this._aliasAction = AliasAction.UNLINK;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get namespaceId() {
		return this._namespaceId;
	}

	set namespaceId(value) {
		this._namespaceId = value;
	}

	get mosaicId() {
		return this._mosaicId;
	}

	set mosaicId(value) {
		this._mosaicId = value;
	}

	get aliasAction() {
		return this._aliasAction;
	}

	set aliasAction(value) {
		this._aliasAction = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.namespaceId.size;
		size += this.mosaicId.size;
		size += this.aliasAction.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedMosaicAliasTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const namespaceId = NamespaceId.deserializeAligned(view.buffer);
		view.shiftRight(namespaceId.size);
		const mosaicId = MosaicId.deserializeAligned(view.buffer);
		view.shiftRight(mosaicId.size);
		const aliasAction = AliasAction.deserializeAligned(view.buffer);
		view.shiftRight(aliasAction.size);

		instance._namespaceId = namespaceId;
		instance._mosaicId = mosaicId;
		instance._aliasAction = aliasAction;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._namespaceId.serialize());
		buffer.write(this._mosaicId.serialize());
		buffer.write(this._aliasAction.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `namespaceId: ${this._namespaceId.toString()}, `;
		result += `mosaicId: ${this._mosaicId.toString()}, `;
		result += `aliasAction: ${this._aliasAction.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.namespaceId = this._namespaceId.toJson();
		result.mosaicId = this._mosaicId.toJson();
		result.aliasAction = this._aliasAction.toJson();
		return result;
	}
}

class NamespaceRegistrationTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.NAMESPACE_REGISTRATION;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		duration: 'pod:BlockDuration',
		parentId: 'pod:NamespaceId',
		id: 'pod:NamespaceId',
		registrationType: 'enum:NamespaceRegistrationType',
		name: 'bytes_array'
	};

	constructor() {
		super();
		this._version = NamespaceRegistrationTransactionV1.TRANSACTION_VERSION;
		this._type = NamespaceRegistrationTransactionV1.TRANSACTION_TYPE;
		this._duration = new BlockDuration();
		this._parentId = null;
		this._id = new NamespaceId();
		this._registrationType = NamespaceRegistrationType.ROOT;
		this._name = new Uint8Array();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get duration() {
		return this._duration;
	}

	set duration(value) {
		this._duration = value;
	}

	get parentId() {
		return this._parentId;
	}

	set parentId(value) {
		this._parentId = value;
	}

	get id() {
		return this._id;
	}

	set id(value) {
		this._id = value;
	}

	get registrationType() {
		return this._registrationType;
	}

	set registrationType(value) {
		this._registrationType = value;
	}

	get name() {
		return this._name;
	}

	set name(value) {
		this._name = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		if (NamespaceRegistrationType.ROOT === this.registrationType)
			size += this.duration.size;

		if (NamespaceRegistrationType.CHILD === this.registrationType)
			size += this.parentId.size;

		size += this.id.size;
		size += this.registrationType.size;
		size += 1;
		size += this._name.length;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new NamespaceRegistrationTransactionV1();

		Transaction._deserialize(view, instance);
		// deserialize to temporary buffer for further processing
		const durationTemporary = BlockDuration.deserialize(view.buffer);
		const registration_type_condition = view.window(durationTemporary.size);
		view.shiftRight(durationTemporary.size); // skip temporary

		const id = NamespaceId.deserializeAligned(view.buffer);
		view.shiftRight(id.size);
		const registrationType = NamespaceRegistrationType.deserializeAligned(view.buffer);
		view.shiftRight(registrationType.size);
		let duration = new BlockDuration();
		if (NamespaceRegistrationType.ROOT === registrationType)
			duration = BlockDuration.deserializeAligned(registration_type_condition);

		let parentId = new NamespaceId();
		if (NamespaceRegistrationType.CHILD === registrationType)
			parentId = NamespaceId.deserializeAligned(registration_type_condition);

		const nameSize = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const name = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, nameSize);
		view.shiftRight(nameSize);

		instance._duration = duration;
		instance._parentId = parentId;
		instance._id = id;
		instance._registrationType = registrationType;
		instance._name = name;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		if (NamespaceRegistrationType.ROOT === this.registrationType)
			buffer.write(this._duration.serialize());

		if (NamespaceRegistrationType.CHILD === this.registrationType)
			buffer.write(this._parentId.serialize());

		buffer.write(this._id.serialize());
		buffer.write(this._registrationType.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._name.length, 1, false)); // bound: name_size
		buffer.write(this._name);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		if (NamespaceRegistrationType.ROOT === this.registrationType)
			result += `duration: ${this._duration.toString()}, `;

		if (NamespaceRegistrationType.CHILD === this.registrationType)
			result += `parentId: ${this._parentId.toString()}, `;

		result += `id: ${this._id.toString()}, `;
		result += `registrationType: ${this._registrationType.toString()}, `;
		result += `name: hex(${_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._name)}), `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		if (NamespaceRegistrationType.ROOT === this.registrationType)
			result.duration = this._duration.toJson();

		if (NamespaceRegistrationType.CHILD === this.registrationType)
			result.parentId = this._parentId.toJson();

		result.id = this._id.toJson();
		result.registrationType = this._registrationType.toJson();
		result.name = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._name);
		return result;
	}
}

class EmbeddedNamespaceRegistrationTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.NAMESPACE_REGISTRATION;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		duration: 'pod:BlockDuration',
		parentId: 'pod:NamespaceId',
		id: 'pod:NamespaceId',
		registrationType: 'enum:NamespaceRegistrationType',
		name: 'bytes_array'
	};

	constructor() {
		super();
		this._version = EmbeddedNamespaceRegistrationTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedNamespaceRegistrationTransactionV1.TRANSACTION_TYPE;
		this._duration = new BlockDuration();
		this._parentId = null;
		this._id = new NamespaceId();
		this._registrationType = NamespaceRegistrationType.ROOT;
		this._name = new Uint8Array();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get duration() {
		return this._duration;
	}

	set duration(value) {
		this._duration = value;
	}

	get parentId() {
		return this._parentId;
	}

	set parentId(value) {
		this._parentId = value;
	}

	get id() {
		return this._id;
	}

	set id(value) {
		this._id = value;
	}

	get registrationType() {
		return this._registrationType;
	}

	set registrationType(value) {
		this._registrationType = value;
	}

	get name() {
		return this._name;
	}

	set name(value) {
		this._name = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		if (NamespaceRegistrationType.ROOT === this.registrationType)
			size += this.duration.size;

		if (NamespaceRegistrationType.CHILD === this.registrationType)
			size += this.parentId.size;

		size += this.id.size;
		size += this.registrationType.size;
		size += 1;
		size += this._name.length;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedNamespaceRegistrationTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		// deserialize to temporary buffer for further processing
		const durationTemporary = BlockDuration.deserialize(view.buffer);
		const registration_type_condition = view.window(durationTemporary.size);
		view.shiftRight(durationTemporary.size); // skip temporary

		const id = NamespaceId.deserializeAligned(view.buffer);
		view.shiftRight(id.size);
		const registrationType = NamespaceRegistrationType.deserializeAligned(view.buffer);
		view.shiftRight(registrationType.size);
		let duration = new BlockDuration();
		if (NamespaceRegistrationType.ROOT === registrationType)
			duration = BlockDuration.deserializeAligned(registration_type_condition);

		let parentId = new NamespaceId();
		if (NamespaceRegistrationType.CHILD === registrationType)
			parentId = NamespaceId.deserializeAligned(registration_type_condition);

		const nameSize = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const name = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, nameSize);
		view.shiftRight(nameSize);

		instance._duration = duration;
		instance._parentId = parentId;
		instance._id = id;
		instance._registrationType = registrationType;
		instance._name = name;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		if (NamespaceRegistrationType.ROOT === this.registrationType)
			buffer.write(this._duration.serialize());

		if (NamespaceRegistrationType.CHILD === this.registrationType)
			buffer.write(this._parentId.serialize());

		buffer.write(this._id.serialize());
		buffer.write(this._registrationType.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._name.length, 1, false)); // bound: name_size
		buffer.write(this._name);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		if (NamespaceRegistrationType.ROOT === this.registrationType)
			result += `duration: ${this._duration.toString()}, `;

		if (NamespaceRegistrationType.CHILD === this.registrationType)
			result += `parentId: ${this._parentId.toString()}, `;

		result += `id: ${this._id.toString()}, `;
		result += `registrationType: ${this._registrationType.toString()}, `;
		result += `name: hex(${_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._name)}), `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		if (NamespaceRegistrationType.ROOT === this.registrationType)
			result.duration = this._duration.toJson();

		if (NamespaceRegistrationType.CHILD === this.registrationType)
			result.parentId = this._parentId.toJson();

		result.id = this._id.toJson();
		result.registrationType = this._registrationType.toJson();
		result.name = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._name);
		return result;
	}
}

class AccountRestrictionFlags {
	static ADDRESS = new AccountRestrictionFlags(1);

	static MOSAIC_ID = new AccountRestrictionFlags(2);

	static TRANSACTION_TYPE = new AccountRestrictionFlags(4);

	static OUTGOING = new AccountRestrictionFlags(16384);

	static BLOCK = new AccountRestrictionFlags(32768);

	constructor(value) {
		this.value = value;
	}

	has(flag) {
		return 0 !== (this.value & flag);
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 2;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new AccountRestrictionFlags(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(byteArray, 2, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return new AccountRestrictionFlags(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(byteArray, 2, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 2, false);
	}

	toString() {
		const values = [
			1, 2, 4, 16384, 32768
		];
		const keys = [
			'ADDRESS', 'MOSAIC_ID', 'TRANSACTION_TYPE', 'OUTGOING', 'BLOCK'
		];

		if (0 === this.value) {
			const index = values.indexOf(this.value);
			return `AccountRestrictionFlags.${keys[index]}`;
		}

		const positions = values.map(flag => (this.value & flag)).filter(n => n).map(n => values.indexOf(n));
		return positions.map(n => `AccountRestrictionFlags.${keys[n]}`).join('|');
	}

	toJson() {
		return this.value;
	}
}

class AccountAddressRestrictionTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.ACCOUNT_ADDRESS_RESTRICTION;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		restrictionFlags: 'enum:AccountRestrictionFlags',
		restrictionAdditions: 'array[UnresolvedAddress]',
		restrictionDeletions: 'array[UnresolvedAddress]'
	};

	constructor() {
		super();
		this._version = AccountAddressRestrictionTransactionV1.TRANSACTION_VERSION;
		this._type = AccountAddressRestrictionTransactionV1.TRANSACTION_TYPE;
		this._restrictionFlags = AccountRestrictionFlags.ADDRESS;
		this._restrictionAdditions = [];
		this._restrictionDeletions = [];
		this._accountRestrictionTransactionBodyReserved_1 = 0; // reserved field
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get restrictionFlags() {
		return this._restrictionFlags;
	}

	set restrictionFlags(value) {
		this._restrictionFlags = value;
	}

	get restrictionAdditions() {
		return this._restrictionAdditions;
	}

	set restrictionAdditions(value) {
		this._restrictionAdditions = value;
	}

	get restrictionDeletions() {
		return this._restrictionDeletions;
	}

	set restrictionDeletions(value) {
		this._restrictionDeletions = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.restrictionFlags.size;
		size += 1;
		size += 1;
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.restrictionAdditions);
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.restrictionDeletions);
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new AccountAddressRestrictionTransactionV1();

		Transaction._deserialize(view, instance);
		const restrictionFlags = AccountRestrictionFlags.deserializeAligned(view.buffer);
		view.shiftRight(restrictionFlags.size);
		const restrictionAdditionsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const restrictionDeletionsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const accountRestrictionTransactionBodyReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== accountRestrictionTransactionBodyReserved_1)
			throw RangeError(`Invalid value of reserved field (${accountRestrictionTransactionBodyReserved_1})`);
		const restrictionAdditions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, UnresolvedAddress, restrictionAdditionsCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(restrictionAdditions));
		const restrictionDeletions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, UnresolvedAddress, restrictionDeletionsCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(restrictionDeletions));

		instance._restrictionFlags = restrictionFlags;
		instance._restrictionAdditions = restrictionAdditions;
		instance._restrictionDeletions = restrictionDeletions;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._restrictionFlags.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._restrictionAdditions.length, 1, false)); // bound: restriction_additions_count
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._restrictionDeletions.length, 1, false)); // bound: restriction_deletions_count
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._accountRestrictionTransactionBodyReserved_1, 4, false));
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._restrictionAdditions);
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._restrictionDeletions);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `restrictionFlags: ${this._restrictionFlags.toString()}, `;
		result += `restrictionAdditions: [${this._restrictionAdditions.map(e => e.toString()).join(',')}], `;
		result += `restrictionDeletions: [${this._restrictionDeletions.map(e => e.toString()).join(',')}], `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.restrictionFlags = this._restrictionFlags.toJson();
		result.restrictionAdditions = this._restrictionAdditions.map(e => e.toJson());
		result.restrictionDeletions = this._restrictionDeletions.map(e => e.toJson());
		return result;
	}
}

class EmbeddedAccountAddressRestrictionTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.ACCOUNT_ADDRESS_RESTRICTION;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		restrictionFlags: 'enum:AccountRestrictionFlags',
		restrictionAdditions: 'array[UnresolvedAddress]',
		restrictionDeletions: 'array[UnresolvedAddress]'
	};

	constructor() {
		super();
		this._version = EmbeddedAccountAddressRestrictionTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedAccountAddressRestrictionTransactionV1.TRANSACTION_TYPE;
		this._restrictionFlags = AccountRestrictionFlags.ADDRESS;
		this._restrictionAdditions = [];
		this._restrictionDeletions = [];
		this._accountRestrictionTransactionBodyReserved_1 = 0; // reserved field
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get restrictionFlags() {
		return this._restrictionFlags;
	}

	set restrictionFlags(value) {
		this._restrictionFlags = value;
	}

	get restrictionAdditions() {
		return this._restrictionAdditions;
	}

	set restrictionAdditions(value) {
		this._restrictionAdditions = value;
	}

	get restrictionDeletions() {
		return this._restrictionDeletions;
	}

	set restrictionDeletions(value) {
		this._restrictionDeletions = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.restrictionFlags.size;
		size += 1;
		size += 1;
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.restrictionAdditions);
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.restrictionDeletions);
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedAccountAddressRestrictionTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const restrictionFlags = AccountRestrictionFlags.deserializeAligned(view.buffer);
		view.shiftRight(restrictionFlags.size);
		const restrictionAdditionsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const restrictionDeletionsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const accountRestrictionTransactionBodyReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== accountRestrictionTransactionBodyReserved_1)
			throw RangeError(`Invalid value of reserved field (${accountRestrictionTransactionBodyReserved_1})`);
		const restrictionAdditions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, UnresolvedAddress, restrictionAdditionsCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(restrictionAdditions));
		const restrictionDeletions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, UnresolvedAddress, restrictionDeletionsCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(restrictionDeletions));

		instance._restrictionFlags = restrictionFlags;
		instance._restrictionAdditions = restrictionAdditions;
		instance._restrictionDeletions = restrictionDeletions;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._restrictionFlags.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._restrictionAdditions.length, 1, false)); // bound: restriction_additions_count
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._restrictionDeletions.length, 1, false)); // bound: restriction_deletions_count
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._accountRestrictionTransactionBodyReserved_1, 4, false));
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._restrictionAdditions);
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._restrictionDeletions);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `restrictionFlags: ${this._restrictionFlags.toString()}, `;
		result += `restrictionAdditions: [${this._restrictionAdditions.map(e => e.toString()).join(',')}], `;
		result += `restrictionDeletions: [${this._restrictionDeletions.map(e => e.toString()).join(',')}], `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.restrictionFlags = this._restrictionFlags.toJson();
		result.restrictionAdditions = this._restrictionAdditions.map(e => e.toJson());
		result.restrictionDeletions = this._restrictionDeletions.map(e => e.toJson());
		return result;
	}
}

class AccountMosaicRestrictionTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.ACCOUNT_MOSAIC_RESTRICTION;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		restrictionFlags: 'enum:AccountRestrictionFlags',
		restrictionAdditions: 'array[UnresolvedMosaicId]',
		restrictionDeletions: 'array[UnresolvedMosaicId]'
	};

	constructor() {
		super();
		this._version = AccountMosaicRestrictionTransactionV1.TRANSACTION_VERSION;
		this._type = AccountMosaicRestrictionTransactionV1.TRANSACTION_TYPE;
		this._restrictionFlags = AccountRestrictionFlags.ADDRESS;
		this._restrictionAdditions = [];
		this._restrictionDeletions = [];
		this._accountRestrictionTransactionBodyReserved_1 = 0; // reserved field
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get restrictionFlags() {
		return this._restrictionFlags;
	}

	set restrictionFlags(value) {
		this._restrictionFlags = value;
	}

	get restrictionAdditions() {
		return this._restrictionAdditions;
	}

	set restrictionAdditions(value) {
		this._restrictionAdditions = value;
	}

	get restrictionDeletions() {
		return this._restrictionDeletions;
	}

	set restrictionDeletions(value) {
		this._restrictionDeletions = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.restrictionFlags.size;
		size += 1;
		size += 1;
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.restrictionAdditions);
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.restrictionDeletions);
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new AccountMosaicRestrictionTransactionV1();

		Transaction._deserialize(view, instance);
		const restrictionFlags = AccountRestrictionFlags.deserializeAligned(view.buffer);
		view.shiftRight(restrictionFlags.size);
		const restrictionAdditionsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const restrictionDeletionsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const accountRestrictionTransactionBodyReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== accountRestrictionTransactionBodyReserved_1)
			throw RangeError(`Invalid value of reserved field (${accountRestrictionTransactionBodyReserved_1})`);
		const restrictionAdditions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, UnresolvedMosaicId, restrictionAdditionsCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(restrictionAdditions));
		const restrictionDeletions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, UnresolvedMosaicId, restrictionDeletionsCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(restrictionDeletions));

		instance._restrictionFlags = restrictionFlags;
		instance._restrictionAdditions = restrictionAdditions;
		instance._restrictionDeletions = restrictionDeletions;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._restrictionFlags.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._restrictionAdditions.length, 1, false)); // bound: restriction_additions_count
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._restrictionDeletions.length, 1, false)); // bound: restriction_deletions_count
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._accountRestrictionTransactionBodyReserved_1, 4, false));
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._restrictionAdditions);
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._restrictionDeletions);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `restrictionFlags: ${this._restrictionFlags.toString()}, `;
		result += `restrictionAdditions: [${this._restrictionAdditions.map(e => e.toString()).join(',')}], `;
		result += `restrictionDeletions: [${this._restrictionDeletions.map(e => e.toString()).join(',')}], `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.restrictionFlags = this._restrictionFlags.toJson();
		result.restrictionAdditions = this._restrictionAdditions.map(e => e.toJson());
		result.restrictionDeletions = this._restrictionDeletions.map(e => e.toJson());
		return result;
	}
}

class EmbeddedAccountMosaicRestrictionTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.ACCOUNT_MOSAIC_RESTRICTION;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		restrictionFlags: 'enum:AccountRestrictionFlags',
		restrictionAdditions: 'array[UnresolvedMosaicId]',
		restrictionDeletions: 'array[UnresolvedMosaicId]'
	};

	constructor() {
		super();
		this._version = EmbeddedAccountMosaicRestrictionTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedAccountMosaicRestrictionTransactionV1.TRANSACTION_TYPE;
		this._restrictionFlags = AccountRestrictionFlags.ADDRESS;
		this._restrictionAdditions = [];
		this._restrictionDeletions = [];
		this._accountRestrictionTransactionBodyReserved_1 = 0; // reserved field
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get restrictionFlags() {
		return this._restrictionFlags;
	}

	set restrictionFlags(value) {
		this._restrictionFlags = value;
	}

	get restrictionAdditions() {
		return this._restrictionAdditions;
	}

	set restrictionAdditions(value) {
		this._restrictionAdditions = value;
	}

	get restrictionDeletions() {
		return this._restrictionDeletions;
	}

	set restrictionDeletions(value) {
		this._restrictionDeletions = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.restrictionFlags.size;
		size += 1;
		size += 1;
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.restrictionAdditions);
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.restrictionDeletions);
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedAccountMosaicRestrictionTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const restrictionFlags = AccountRestrictionFlags.deserializeAligned(view.buffer);
		view.shiftRight(restrictionFlags.size);
		const restrictionAdditionsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const restrictionDeletionsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const accountRestrictionTransactionBodyReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== accountRestrictionTransactionBodyReserved_1)
			throw RangeError(`Invalid value of reserved field (${accountRestrictionTransactionBodyReserved_1})`);
		const restrictionAdditions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, UnresolvedMosaicId, restrictionAdditionsCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(restrictionAdditions));
		const restrictionDeletions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, UnresolvedMosaicId, restrictionDeletionsCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(restrictionDeletions));

		instance._restrictionFlags = restrictionFlags;
		instance._restrictionAdditions = restrictionAdditions;
		instance._restrictionDeletions = restrictionDeletions;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._restrictionFlags.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._restrictionAdditions.length, 1, false)); // bound: restriction_additions_count
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._restrictionDeletions.length, 1, false)); // bound: restriction_deletions_count
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._accountRestrictionTransactionBodyReserved_1, 4, false));
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._restrictionAdditions);
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._restrictionDeletions);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `restrictionFlags: ${this._restrictionFlags.toString()}, `;
		result += `restrictionAdditions: [${this._restrictionAdditions.map(e => e.toString()).join(',')}], `;
		result += `restrictionDeletions: [${this._restrictionDeletions.map(e => e.toString()).join(',')}], `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.restrictionFlags = this._restrictionFlags.toJson();
		result.restrictionAdditions = this._restrictionAdditions.map(e => e.toJson());
		result.restrictionDeletions = this._restrictionDeletions.map(e => e.toJson());
		return result;
	}
}

class AccountOperationRestrictionTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.ACCOUNT_OPERATION_RESTRICTION;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		restrictionFlags: 'enum:AccountRestrictionFlags',
		restrictionAdditions: 'array[TransactionType]',
		restrictionDeletions: 'array[TransactionType]'
	};

	constructor() {
		super();
		this._version = AccountOperationRestrictionTransactionV1.TRANSACTION_VERSION;
		this._type = AccountOperationRestrictionTransactionV1.TRANSACTION_TYPE;
		this._restrictionFlags = AccountRestrictionFlags.ADDRESS;
		this._restrictionAdditions = [];
		this._restrictionDeletions = [];
		this._accountRestrictionTransactionBodyReserved_1 = 0; // reserved field
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get restrictionFlags() {
		return this._restrictionFlags;
	}

	set restrictionFlags(value) {
		this._restrictionFlags = value;
	}

	get restrictionAdditions() {
		return this._restrictionAdditions;
	}

	set restrictionAdditions(value) {
		this._restrictionAdditions = value;
	}

	get restrictionDeletions() {
		return this._restrictionDeletions;
	}

	set restrictionDeletions(value) {
		this._restrictionDeletions = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.restrictionFlags.size;
		size += 1;
		size += 1;
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.restrictionAdditions);
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.restrictionDeletions);
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new AccountOperationRestrictionTransactionV1();

		Transaction._deserialize(view, instance);
		const restrictionFlags = AccountRestrictionFlags.deserializeAligned(view.buffer);
		view.shiftRight(restrictionFlags.size);
		const restrictionAdditionsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const restrictionDeletionsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const accountRestrictionTransactionBodyReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== accountRestrictionTransactionBodyReserved_1)
			throw RangeError(`Invalid value of reserved field (${accountRestrictionTransactionBodyReserved_1})`);
		const restrictionAdditions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, TransactionType, restrictionAdditionsCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(restrictionAdditions));
		const restrictionDeletions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, TransactionType, restrictionDeletionsCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(restrictionDeletions));

		instance._restrictionFlags = restrictionFlags;
		instance._restrictionAdditions = restrictionAdditions;
		instance._restrictionDeletions = restrictionDeletions;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._restrictionFlags.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._restrictionAdditions.length, 1, false)); // bound: restriction_additions_count
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._restrictionDeletions.length, 1, false)); // bound: restriction_deletions_count
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._accountRestrictionTransactionBodyReserved_1, 4, false));
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._restrictionAdditions);
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._restrictionDeletions);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `restrictionFlags: ${this._restrictionFlags.toString()}, `;
		result += `restrictionAdditions: [${this._restrictionAdditions.map(e => e.toString()).join(',')}], `;
		result += `restrictionDeletions: [${this._restrictionDeletions.map(e => e.toString()).join(',')}], `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.restrictionFlags = this._restrictionFlags.toJson();
		result.restrictionAdditions = this._restrictionAdditions.map(e => e.toJson());
		result.restrictionDeletions = this._restrictionDeletions.map(e => e.toJson());
		return result;
	}
}

class EmbeddedAccountOperationRestrictionTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.ACCOUNT_OPERATION_RESTRICTION;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		restrictionFlags: 'enum:AccountRestrictionFlags',
		restrictionAdditions: 'array[TransactionType]',
		restrictionDeletions: 'array[TransactionType]'
	};

	constructor() {
		super();
		this._version = EmbeddedAccountOperationRestrictionTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedAccountOperationRestrictionTransactionV1.TRANSACTION_TYPE;
		this._restrictionFlags = AccountRestrictionFlags.ADDRESS;
		this._restrictionAdditions = [];
		this._restrictionDeletions = [];
		this._accountRestrictionTransactionBodyReserved_1 = 0; // reserved field
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get restrictionFlags() {
		return this._restrictionFlags;
	}

	set restrictionFlags(value) {
		this._restrictionFlags = value;
	}

	get restrictionAdditions() {
		return this._restrictionAdditions;
	}

	set restrictionAdditions(value) {
		this._restrictionAdditions = value;
	}

	get restrictionDeletions() {
		return this._restrictionDeletions;
	}

	set restrictionDeletions(value) {
		this._restrictionDeletions = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.restrictionFlags.size;
		size += 1;
		size += 1;
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.restrictionAdditions);
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.restrictionDeletions);
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedAccountOperationRestrictionTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const restrictionFlags = AccountRestrictionFlags.deserializeAligned(view.buffer);
		view.shiftRight(restrictionFlags.size);
		const restrictionAdditionsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const restrictionDeletionsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const accountRestrictionTransactionBodyReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== accountRestrictionTransactionBodyReserved_1)
			throw RangeError(`Invalid value of reserved field (${accountRestrictionTransactionBodyReserved_1})`);
		const restrictionAdditions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, TransactionType, restrictionAdditionsCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(restrictionAdditions));
		const restrictionDeletions = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, TransactionType, restrictionDeletionsCount);
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(restrictionDeletions));

		instance._restrictionFlags = restrictionFlags;
		instance._restrictionAdditions = restrictionAdditions;
		instance._restrictionDeletions = restrictionDeletions;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._restrictionFlags.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._restrictionAdditions.length, 1, false)); // bound: restriction_additions_count
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._restrictionDeletions.length, 1, false)); // bound: restriction_deletions_count
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._accountRestrictionTransactionBodyReserved_1, 4, false));
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._restrictionAdditions);
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._restrictionDeletions);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `restrictionFlags: ${this._restrictionFlags.toString()}, `;
		result += `restrictionAdditions: [${this._restrictionAdditions.map(e => e.toString()).join(',')}], `;
		result += `restrictionDeletions: [${this._restrictionDeletions.map(e => e.toString()).join(',')}], `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.restrictionFlags = this._restrictionFlags.toJson();
		result.restrictionAdditions = this._restrictionAdditions.map(e => e.toJson());
		result.restrictionDeletions = this._restrictionDeletions.map(e => e.toJson());
		return result;
	}
}

class MosaicAddressRestrictionTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.MOSAIC_ADDRESS_RESTRICTION;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		mosaicId: 'pod:UnresolvedMosaicId',
		targetAddress: 'pod:UnresolvedAddress'
	};

	constructor() {
		super();
		this._version = MosaicAddressRestrictionTransactionV1.TRANSACTION_VERSION;
		this._type = MosaicAddressRestrictionTransactionV1.TRANSACTION_TYPE;
		this._mosaicId = new UnresolvedMosaicId();
		this._restrictionKey = 0n;
		this._previousRestrictionValue = 0n;
		this._newRestrictionValue = 0n;
		this._targetAddress = new UnresolvedAddress();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get mosaicId() {
		return this._mosaicId;
	}

	set mosaicId(value) {
		this._mosaicId = value;
	}

	get restrictionKey() {
		return this._restrictionKey;
	}

	set restrictionKey(value) {
		this._restrictionKey = value;
	}

	get previousRestrictionValue() {
		return this._previousRestrictionValue;
	}

	set previousRestrictionValue(value) {
		this._previousRestrictionValue = value;
	}

	get newRestrictionValue() {
		return this._newRestrictionValue;
	}

	set newRestrictionValue(value) {
		this._newRestrictionValue = value;
	}

	get targetAddress() {
		return this._targetAddress;
	}

	set targetAddress(value) {
		this._targetAddress = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.mosaicId.size;
		size += 8;
		size += 8;
		size += 8;
		size += this.targetAddress.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new MosaicAddressRestrictionTransactionV1();

		Transaction._deserialize(view, instance);
		const mosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);
		view.shiftRight(mosaicId.size);
		const restrictionKey = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const previousRestrictionValue = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const newRestrictionValue = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const targetAddress = UnresolvedAddress.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);

		instance._mosaicId = mosaicId;
		instance._restrictionKey = restrictionKey;
		instance._previousRestrictionValue = previousRestrictionValue;
		instance._newRestrictionValue = newRestrictionValue;
		instance._targetAddress = targetAddress;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._mosaicId.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._restrictionKey, 8, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._previousRestrictionValue, 8, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._newRestrictionValue, 8, false));
		buffer.write(this._targetAddress.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `mosaicId: ${this._mosaicId.toString()}, `;
		result += `restrictionKey: ${'0x'.concat(this._restrictionKey.toString(16))}, `;
		result += `previousRestrictionValue: ${'0x'.concat(this._previousRestrictionValue.toString(16))}, `;
		result += `newRestrictionValue: ${'0x'.concat(this._newRestrictionValue.toString(16))}, `;
		result += `targetAddress: ${this._targetAddress.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.mosaicId = this._mosaicId.toJson();
		result.restrictionKey = this._restrictionKey.toString();
		result.previousRestrictionValue = this._previousRestrictionValue.toString();
		result.newRestrictionValue = this._newRestrictionValue.toString();
		result.targetAddress = this._targetAddress.toJson();
		return result;
	}
}

class EmbeddedMosaicAddressRestrictionTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.MOSAIC_ADDRESS_RESTRICTION;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		mosaicId: 'pod:UnresolvedMosaicId',
		targetAddress: 'pod:UnresolvedAddress'
	};

	constructor() {
		super();
		this._version = EmbeddedMosaicAddressRestrictionTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedMosaicAddressRestrictionTransactionV1.TRANSACTION_TYPE;
		this._mosaicId = new UnresolvedMosaicId();
		this._restrictionKey = 0n;
		this._previousRestrictionValue = 0n;
		this._newRestrictionValue = 0n;
		this._targetAddress = new UnresolvedAddress();
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get mosaicId() {
		return this._mosaicId;
	}

	set mosaicId(value) {
		this._mosaicId = value;
	}

	get restrictionKey() {
		return this._restrictionKey;
	}

	set restrictionKey(value) {
		this._restrictionKey = value;
	}

	get previousRestrictionValue() {
		return this._previousRestrictionValue;
	}

	set previousRestrictionValue(value) {
		this._previousRestrictionValue = value;
	}

	get newRestrictionValue() {
		return this._newRestrictionValue;
	}

	set newRestrictionValue(value) {
		this._newRestrictionValue = value;
	}

	get targetAddress() {
		return this._targetAddress;
	}

	set targetAddress(value) {
		this._targetAddress = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.mosaicId.size;
		size += 8;
		size += 8;
		size += 8;
		size += this.targetAddress.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedMosaicAddressRestrictionTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const mosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);
		view.shiftRight(mosaicId.size);
		const restrictionKey = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const previousRestrictionValue = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const newRestrictionValue = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const targetAddress = UnresolvedAddress.deserialize(view.buffer);
		view.shiftRight(targetAddress.size);

		instance._mosaicId = mosaicId;
		instance._restrictionKey = restrictionKey;
		instance._previousRestrictionValue = previousRestrictionValue;
		instance._newRestrictionValue = newRestrictionValue;
		instance._targetAddress = targetAddress;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._mosaicId.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._restrictionKey, 8, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._previousRestrictionValue, 8, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._newRestrictionValue, 8, false));
		buffer.write(this._targetAddress.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `mosaicId: ${this._mosaicId.toString()}, `;
		result += `restrictionKey: ${'0x'.concat(this._restrictionKey.toString(16))}, `;
		result += `previousRestrictionValue: ${'0x'.concat(this._previousRestrictionValue.toString(16))}, `;
		result += `newRestrictionValue: ${'0x'.concat(this._newRestrictionValue.toString(16))}, `;
		result += `targetAddress: ${this._targetAddress.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.mosaicId = this._mosaicId.toJson();
		result.restrictionKey = this._restrictionKey.toString();
		result.previousRestrictionValue = this._previousRestrictionValue.toString();
		result.newRestrictionValue = this._newRestrictionValue.toString();
		result.targetAddress = this._targetAddress.toJson();
		return result;
	}
}

class MosaicRestrictionKey extends _BaseValue_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
	static SIZE = 8;

	constructor(mosaicRestrictionKey = 0n) {
		super(MosaicRestrictionKey.SIZE, mosaicRestrictionKey);
	}

	static deserialize(payload) {
		const byteArray = payload;
		return new MosaicRestrictionKey(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigIntUnaligned(byteArray, 8, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return new MosaicRestrictionKey(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(byteArray, 8, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 8, false);
	}
}

class MosaicRestrictionType {
	static NONE = new MosaicRestrictionType(0);

	static EQ = new MosaicRestrictionType(1);

	static NE = new MosaicRestrictionType(2);

	static LT = new MosaicRestrictionType(3);

	static LE = new MosaicRestrictionType(4);

	static GT = new MosaicRestrictionType(5);

	static GE = new MosaicRestrictionType(6);

	constructor(value) {
		this.value = value;
	}

	static valueToKey(value) {
		const values = [
			0, 1, 2, 3, 4, 5, 6
		];
		const keys = [
			'NONE', 'EQ', 'NE', 'LT', 'LE', 'GT', 'GE'
		];

		const index = values.indexOf(value);
		if (-1 === index)
			throw RangeError(`invalid enum value ${value}`);

		return keys[index];
	}

	static fromValue(value) {
		return MosaicRestrictionType[this.valueToKey(value)];
	}

	get size() { // eslint-disable-line class-methods-use-this
		return 1;
	}

	static deserialize(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToIntUnaligned(byteArray, 1, false));
	}

	static deserializeAligned(payload) {
		const byteArray = payload;
		return this.fromValue(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(byteArray, 1, false));
	}

	serialize() {
		return _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this.value, 1, false);
	}

	toString() {
		return `MosaicRestrictionType.${MosaicRestrictionType.valueToKey(this.value)}`;
	}

	toJson() {
		return this.value;
	}
}

class MosaicGlobalRestrictionTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.MOSAIC_GLOBAL_RESTRICTION;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		mosaicId: 'pod:UnresolvedMosaicId',
		referenceMosaicId: 'pod:UnresolvedMosaicId',
		previousRestrictionType: 'enum:MosaicRestrictionType',
		newRestrictionType: 'enum:MosaicRestrictionType'
	};

	constructor() {
		super();
		this._version = MosaicGlobalRestrictionTransactionV1.TRANSACTION_VERSION;
		this._type = MosaicGlobalRestrictionTransactionV1.TRANSACTION_TYPE;
		this._mosaicId = new UnresolvedMosaicId();
		this._referenceMosaicId = new UnresolvedMosaicId();
		this._restrictionKey = 0n;
		this._previousRestrictionValue = 0n;
		this._newRestrictionValue = 0n;
		this._previousRestrictionType = MosaicRestrictionType.NONE;
		this._newRestrictionType = MosaicRestrictionType.NONE;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get mosaicId() {
		return this._mosaicId;
	}

	set mosaicId(value) {
		this._mosaicId = value;
	}

	get referenceMosaicId() {
		return this._referenceMosaicId;
	}

	set referenceMosaicId(value) {
		this._referenceMosaicId = value;
	}

	get restrictionKey() {
		return this._restrictionKey;
	}

	set restrictionKey(value) {
		this._restrictionKey = value;
	}

	get previousRestrictionValue() {
		return this._previousRestrictionValue;
	}

	set previousRestrictionValue(value) {
		this._previousRestrictionValue = value;
	}

	get newRestrictionValue() {
		return this._newRestrictionValue;
	}

	set newRestrictionValue(value) {
		this._newRestrictionValue = value;
	}

	get previousRestrictionType() {
		return this._previousRestrictionType;
	}

	set previousRestrictionType(value) {
		this._previousRestrictionType = value;
	}

	get newRestrictionType() {
		return this._newRestrictionType;
	}

	set newRestrictionType(value) {
		this._newRestrictionType = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.mosaicId.size;
		size += this.referenceMosaicId.size;
		size += 8;
		size += 8;
		size += 8;
		size += this.previousRestrictionType.size;
		size += this.newRestrictionType.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new MosaicGlobalRestrictionTransactionV1();

		Transaction._deserialize(view, instance);
		const mosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);
		view.shiftRight(mosaicId.size);
		const referenceMosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);
		view.shiftRight(referenceMosaicId.size);
		const restrictionKey = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const previousRestrictionValue = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const newRestrictionValue = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const previousRestrictionType = MosaicRestrictionType.deserializeAligned(view.buffer);
		view.shiftRight(previousRestrictionType.size);
		const newRestrictionType = MosaicRestrictionType.deserializeAligned(view.buffer);
		view.shiftRight(newRestrictionType.size);

		instance._mosaicId = mosaicId;
		instance._referenceMosaicId = referenceMosaicId;
		instance._restrictionKey = restrictionKey;
		instance._previousRestrictionValue = previousRestrictionValue;
		instance._newRestrictionValue = newRestrictionValue;
		instance._previousRestrictionType = previousRestrictionType;
		instance._newRestrictionType = newRestrictionType;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._mosaicId.serialize());
		buffer.write(this._referenceMosaicId.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._restrictionKey, 8, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._previousRestrictionValue, 8, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._newRestrictionValue, 8, false));
		buffer.write(this._previousRestrictionType.serialize());
		buffer.write(this._newRestrictionType.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `mosaicId: ${this._mosaicId.toString()}, `;
		result += `referenceMosaicId: ${this._referenceMosaicId.toString()}, `;
		result += `restrictionKey: ${'0x'.concat(this._restrictionKey.toString(16))}, `;
		result += `previousRestrictionValue: ${'0x'.concat(this._previousRestrictionValue.toString(16))}, `;
		result += `newRestrictionValue: ${'0x'.concat(this._newRestrictionValue.toString(16))}, `;
		result += `previousRestrictionType: ${this._previousRestrictionType.toString()}, `;
		result += `newRestrictionType: ${this._newRestrictionType.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.mosaicId = this._mosaicId.toJson();
		result.referenceMosaicId = this._referenceMosaicId.toJson();
		result.restrictionKey = this._restrictionKey.toString();
		result.previousRestrictionValue = this._previousRestrictionValue.toString();
		result.newRestrictionValue = this._newRestrictionValue.toString();
		result.previousRestrictionType = this._previousRestrictionType.toJson();
		result.newRestrictionType = this._newRestrictionType.toJson();
		return result;
	}
}

class EmbeddedMosaicGlobalRestrictionTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.MOSAIC_GLOBAL_RESTRICTION;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		mosaicId: 'pod:UnresolvedMosaicId',
		referenceMosaicId: 'pod:UnresolvedMosaicId',
		previousRestrictionType: 'enum:MosaicRestrictionType',
		newRestrictionType: 'enum:MosaicRestrictionType'
	};

	constructor() {
		super();
		this._version = EmbeddedMosaicGlobalRestrictionTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedMosaicGlobalRestrictionTransactionV1.TRANSACTION_TYPE;
		this._mosaicId = new UnresolvedMosaicId();
		this._referenceMosaicId = new UnresolvedMosaicId();
		this._restrictionKey = 0n;
		this._previousRestrictionValue = 0n;
		this._newRestrictionValue = 0n;
		this._previousRestrictionType = MosaicRestrictionType.NONE;
		this._newRestrictionType = MosaicRestrictionType.NONE;
	}

	sort() { // eslint-disable-line class-methods-use-this
	}

	get mosaicId() {
		return this._mosaicId;
	}

	set mosaicId(value) {
		this._mosaicId = value;
	}

	get referenceMosaicId() {
		return this._referenceMosaicId;
	}

	set referenceMosaicId(value) {
		this._referenceMosaicId = value;
	}

	get restrictionKey() {
		return this._restrictionKey;
	}

	set restrictionKey(value) {
		this._restrictionKey = value;
	}

	get previousRestrictionValue() {
		return this._previousRestrictionValue;
	}

	set previousRestrictionValue(value) {
		this._previousRestrictionValue = value;
	}

	get newRestrictionValue() {
		return this._newRestrictionValue;
	}

	set newRestrictionValue(value) {
		this._newRestrictionValue = value;
	}

	get previousRestrictionType() {
		return this._previousRestrictionType;
	}

	set previousRestrictionType(value) {
		this._previousRestrictionType = value;
	}

	get newRestrictionType() {
		return this._newRestrictionType;
	}

	set newRestrictionType(value) {
		this._newRestrictionType = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.mosaicId.size;
		size += this.referenceMosaicId.size;
		size += 8;
		size += 8;
		size += 8;
		size += this.previousRestrictionType.size;
		size += this.newRestrictionType.size;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedMosaicGlobalRestrictionTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const mosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);
		view.shiftRight(mosaicId.size);
		const referenceMosaicId = UnresolvedMosaicId.deserializeAligned(view.buffer);
		view.shiftRight(referenceMosaicId.size);
		const restrictionKey = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const previousRestrictionValue = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const newRestrictionValue = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt(view.buffer, 8, false);
		view.shiftRight(8);
		const previousRestrictionType = MosaicRestrictionType.deserializeAligned(view.buffer);
		view.shiftRight(previousRestrictionType.size);
		const newRestrictionType = MosaicRestrictionType.deserializeAligned(view.buffer);
		view.shiftRight(newRestrictionType.size);

		instance._mosaicId = mosaicId;
		instance._referenceMosaicId = referenceMosaicId;
		instance._restrictionKey = restrictionKey;
		instance._previousRestrictionValue = previousRestrictionValue;
		instance._newRestrictionValue = newRestrictionValue;
		instance._previousRestrictionType = previousRestrictionType;
		instance._newRestrictionType = newRestrictionType;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._mosaicId.serialize());
		buffer.write(this._referenceMosaicId.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._restrictionKey, 8, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._previousRestrictionValue, 8, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._newRestrictionValue, 8, false));
		buffer.write(this._previousRestrictionType.serialize());
		buffer.write(this._newRestrictionType.serialize());
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `mosaicId: ${this._mosaicId.toString()}, `;
		result += `referenceMosaicId: ${this._referenceMosaicId.toString()}, `;
		result += `restrictionKey: ${'0x'.concat(this._restrictionKey.toString(16))}, `;
		result += `previousRestrictionValue: ${'0x'.concat(this._previousRestrictionValue.toString(16))}, `;
		result += `newRestrictionValue: ${'0x'.concat(this._newRestrictionValue.toString(16))}, `;
		result += `previousRestrictionType: ${this._previousRestrictionType.toString()}, `;
		result += `newRestrictionType: ${this._newRestrictionType.toString()}, `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.mosaicId = this._mosaicId.toJson();
		result.referenceMosaicId = this._referenceMosaicId.toJson();
		result.restrictionKey = this._restrictionKey.toString();
		result.previousRestrictionValue = this._previousRestrictionValue.toString();
		result.newRestrictionValue = this._newRestrictionValue.toString();
		result.previousRestrictionType = this._previousRestrictionType.toJson();
		result.newRestrictionType = this._newRestrictionType.toJson();
		return result;
	}
}

class TransferTransactionV1 extends Transaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.TRANSFER;

	static TYPE_HINTS = {
		...Transaction.TYPE_HINTS,
		recipientAddress: 'pod:UnresolvedAddress',
		mosaics: 'array[UnresolvedMosaic]',
		message: 'bytes_array'
	};

	constructor() {
		super();
		this._version = TransferTransactionV1.TRANSACTION_VERSION;
		this._type = TransferTransactionV1.TRANSACTION_TYPE;
		this._recipientAddress = new UnresolvedAddress();
		this._mosaics = [];
		this._message = new Uint8Array();
		this._transferTransactionBodyReserved_1 = 0; // reserved field
		this._transferTransactionBodyReserved_2 = 0; // reserved field
	}

	sort() {
		this._mosaics = this._mosaics.sort((lhs, rhs) => _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.deepCompare(
			(lhs.mosaicId.comparer ? lhs.mosaicId.comparer() : lhs.mosaicId.value),
			(rhs.mosaicId.comparer ? rhs.mosaicId.comparer() : rhs.mosaicId.value)
		));
	}

	get recipientAddress() {
		return this._recipientAddress;
	}

	set recipientAddress(value) {
		this._recipientAddress = value;
	}

	get mosaics() {
		return this._mosaics;
	}

	set mosaics(value) {
		this._mosaics = value;
	}

	get message() {
		return this._message;
	}

	set message(value) {
		this._message = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.recipientAddress.size;
		size += 2;
		size += 1;
		size += 1;
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.mosaics);
		size += this._message.length;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new TransferTransactionV1();

		Transaction._deserialize(view, instance);
		const recipientAddress = UnresolvedAddress.deserialize(view.buffer);
		view.shiftRight(recipientAddress.size);
		const messageSize = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 2, false);
		view.shiftRight(2);
		const mosaicsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const transferTransactionBodyReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		if (0 !== transferTransactionBodyReserved_1)
			throw RangeError(`Invalid value of reserved field (${transferTransactionBodyReserved_1})`);
		const transferTransactionBodyReserved_2 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== transferTransactionBodyReserved_2)
			throw RangeError(`Invalid value of reserved field (${transferTransactionBodyReserved_2})`);
		const mosaics = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, UnresolvedMosaic, mosaicsCount, e => ((e.mosaicId.comparer ? e.mosaicId.comparer() : e.mosaicId.value)));
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(mosaics));
		const message = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, messageSize);
		view.shiftRight(messageSize);

		instance._recipientAddress = recipientAddress;
		instance._mosaics = mosaics;
		instance._message = message;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._recipientAddress.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._message.length, 2, false)); // bound: message_size
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._mosaics.length, 1, false)); // bound: mosaics_count
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._transferTransactionBodyReserved_1, 1, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._transferTransactionBodyReserved_2, 4, false));
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._mosaics, e => ((e.mosaicId.comparer ? e.mosaicId.comparer() : e.mosaicId.value)));
		buffer.write(this._message);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `recipientAddress: ${this._recipientAddress.toString()}, `;
		result += `mosaics: [${this._mosaics.map(e => e.toString()).join(',')}], `;
		result += `message: hex(${_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._message)}), `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.recipientAddress = this._recipientAddress.toJson();
		result.mosaics = this._mosaics.map(e => e.toJson());
		result.message = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._message);
		return result;
	}
}

class EmbeddedTransferTransactionV1 extends EmbeddedTransaction {
	static TRANSACTION_VERSION = 1;

	static TRANSACTION_TYPE = TransactionType.TRANSFER;

	static TYPE_HINTS = {
		...EmbeddedTransaction.TYPE_HINTS,
		recipientAddress: 'pod:UnresolvedAddress',
		mosaics: 'array[UnresolvedMosaic]',
		message: 'bytes_array'
	};

	constructor() {
		super();
		this._version = EmbeddedTransferTransactionV1.TRANSACTION_VERSION;
		this._type = EmbeddedTransferTransactionV1.TRANSACTION_TYPE;
		this._recipientAddress = new UnresolvedAddress();
		this._mosaics = [];
		this._message = new Uint8Array();
		this._transferTransactionBodyReserved_1 = 0; // reserved field
		this._transferTransactionBodyReserved_2 = 0; // reserved field
	}

	sort() {
		this._mosaics = this._mosaics.sort((lhs, rhs) => _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.deepCompare(
			(lhs.mosaicId.comparer ? lhs.mosaicId.comparer() : lhs.mosaicId.value),
			(rhs.mosaicId.comparer ? rhs.mosaicId.comparer() : rhs.mosaicId.value)
		));
	}

	get recipientAddress() {
		return this._recipientAddress;
	}

	set recipientAddress(value) {
		this._recipientAddress = value;
	}

	get mosaics() {
		return this._mosaics;
	}

	set mosaics(value) {
		this._mosaics = value;
	}

	get message() {
		return this._message;
	}

	set message(value) {
		this._message = value;
	}

	get size() { // eslint-disable-line class-methods-use-this
		let size = 0;
		size += super.size;
		size += this.recipientAddress.size;
		size += 2;
		size += 1;
		size += 1;
		size += 4;
		size += _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(this.mosaics);
		size += this._message.length;
		return size;
	}

	static deserialize(payload) {
		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const instance = new EmbeddedTransferTransactionV1();

		EmbeddedTransaction._deserialize(view, instance);
		const recipientAddress = UnresolvedAddress.deserialize(view.buffer);
		view.shiftRight(recipientAddress.size);
		const messageSize = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 2, false);
		view.shiftRight(2);
		const mosaicsCount = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		const transferTransactionBodyReserved_1 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 1, false);
		view.shiftRight(1);
		if (0 !== transferTransactionBodyReserved_1)
			throw RangeError(`Invalid value of reserved field (${transferTransactionBodyReserved_1})`);
		const transferTransactionBodyReserved_2 = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.bytesToInt(view.buffer, 4, false);
		view.shiftRight(4);
		if (0 !== transferTransactionBodyReserved_2)
			throw RangeError(`Invalid value of reserved field (${transferTransactionBodyReserved_2})`);
		const mosaics = _utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.readArrayCount(view.buffer, UnresolvedMosaic, mosaicsCount, e => ((e.mosaicId.comparer ? e.mosaicId.comparer() : e.mosaicId.value)));
		view.shiftRight(_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.size(mosaics));
		const message = new Uint8Array(view.buffer.buffer, view.buffer.byteOffset, messageSize);
		view.shiftRight(messageSize);

		instance._recipientAddress = recipientAddress;
		instance._mosaics = mosaics;
		instance._message = message;
		return instance;
	}

	serialize() {
		const buffer = new _utils_Writer_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.size);
		super._serialize(buffer);
		buffer.write(this._recipientAddress.serialize());
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._message.length, 2, false)); // bound: message_size
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._mosaics.length, 1, false)); // bound: mosaics_count
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._transferTransactionBodyReserved_1, 1, false));
		buffer.write(_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.intToBytes(this._transferTransactionBodyReserved_2, 4, false));
		_utils_arrayHelpers_js__WEBPACK_IMPORTED_MODULE_4__.writeArray(buffer, this._mosaics, e => ((e.mosaicId.comparer ? e.mosaicId.comparer() : e.mosaicId.value)));
		buffer.write(this._message);
		return buffer.storage;
	}

	toString() {
		let result = '(';
		result += super.toString();
		result += `recipientAddress: ${this._recipientAddress.toString()}, `;
		result += `mosaics: [${this._mosaics.map(e => e.toString()).join(',')}], `;
		result += `message: hex(${_utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._message)}), `;
		result += ')';
		return result;
	}

	/**
	 * @returns {object} JSON-safe representation of this object.
	 */
	toJson() {
		const result = {};
		Object.assign(result, super.toJson());
		result.recipientAddress = this._recipientAddress.toJson();
		result.mosaics = this._mosaics.map(e => e.toJson());
		result.message = _utils_converter_js__WEBPACK_IMPORTED_MODULE_5__.uint8ToHex(this._message);
		return result;
	}
}

class TransactionFactory {
	static toKey(values) {
		if (1 === values.length)
			return values[0];

		// assume each key is at most 32bits
		return values.map(n => BigInt(n)).reduce((accumulator, value) => (accumulator << 32n) + value);
	}

	static deserialize(payload) {
		const parent = new Transaction();
		Transaction._deserialize(new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload), parent);

		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const mapping = new Map();
		mapping.set(TransactionFactory.toKey([AccountKeyLinkTransactionV1.TRANSACTION_TYPE.value, AccountKeyLinkTransactionV1.TRANSACTION_VERSION]), AccountKeyLinkTransactionV1);
		mapping.set(TransactionFactory.toKey([NodeKeyLinkTransactionV1.TRANSACTION_TYPE.value, NodeKeyLinkTransactionV1.TRANSACTION_VERSION]), NodeKeyLinkTransactionV1);
		mapping.set(TransactionFactory.toKey([AggregateCompleteTransactionV1.TRANSACTION_TYPE.value, AggregateCompleteTransactionV1.TRANSACTION_VERSION]), AggregateCompleteTransactionV1);
		mapping.set(TransactionFactory.toKey([AggregateCompleteTransactionV2.TRANSACTION_TYPE.value, AggregateCompleteTransactionV2.TRANSACTION_VERSION]), AggregateCompleteTransactionV2);
		mapping.set(TransactionFactory.toKey([AggregateBondedTransactionV1.TRANSACTION_TYPE.value, AggregateBondedTransactionV1.TRANSACTION_VERSION]), AggregateBondedTransactionV1);
		mapping.set(TransactionFactory.toKey([AggregateBondedTransactionV2.TRANSACTION_TYPE.value, AggregateBondedTransactionV2.TRANSACTION_VERSION]), AggregateBondedTransactionV2);
		mapping.set(TransactionFactory.toKey([VotingKeyLinkTransactionV1.TRANSACTION_TYPE.value, VotingKeyLinkTransactionV1.TRANSACTION_VERSION]), VotingKeyLinkTransactionV1);
		mapping.set(TransactionFactory.toKey([VrfKeyLinkTransactionV1.TRANSACTION_TYPE.value, VrfKeyLinkTransactionV1.TRANSACTION_VERSION]), VrfKeyLinkTransactionV1);
		mapping.set(TransactionFactory.toKey([HashLockTransactionV1.TRANSACTION_TYPE.value, HashLockTransactionV1.TRANSACTION_VERSION]), HashLockTransactionV1);
		mapping.set(TransactionFactory.toKey([SecretLockTransactionV1.TRANSACTION_TYPE.value, SecretLockTransactionV1.TRANSACTION_VERSION]), SecretLockTransactionV1);
		mapping.set(TransactionFactory.toKey([SecretProofTransactionV1.TRANSACTION_TYPE.value, SecretProofTransactionV1.TRANSACTION_VERSION]), SecretProofTransactionV1);
		mapping.set(TransactionFactory.toKey([AccountMetadataTransactionV1.TRANSACTION_TYPE.value, AccountMetadataTransactionV1.TRANSACTION_VERSION]), AccountMetadataTransactionV1);
		mapping.set(TransactionFactory.toKey([MosaicMetadataTransactionV1.TRANSACTION_TYPE.value, MosaicMetadataTransactionV1.TRANSACTION_VERSION]), MosaicMetadataTransactionV1);
		mapping.set(TransactionFactory.toKey([NamespaceMetadataTransactionV1.TRANSACTION_TYPE.value, NamespaceMetadataTransactionV1.TRANSACTION_VERSION]), NamespaceMetadataTransactionV1);
		mapping.set(TransactionFactory.toKey([MosaicDefinitionTransactionV1.TRANSACTION_TYPE.value, MosaicDefinitionTransactionV1.TRANSACTION_VERSION]), MosaicDefinitionTransactionV1);
		mapping.set(TransactionFactory.toKey([MosaicSupplyChangeTransactionV1.TRANSACTION_TYPE.value, MosaicSupplyChangeTransactionV1.TRANSACTION_VERSION]), MosaicSupplyChangeTransactionV1);
		mapping.set(TransactionFactory.toKey([MosaicSupplyRevocationTransactionV1.TRANSACTION_TYPE.value, MosaicSupplyRevocationTransactionV1.TRANSACTION_VERSION]), MosaicSupplyRevocationTransactionV1);
		mapping.set(TransactionFactory.toKey([MultisigAccountModificationTransactionV1.TRANSACTION_TYPE.value, MultisigAccountModificationTransactionV1.TRANSACTION_VERSION]), MultisigAccountModificationTransactionV1);
		mapping.set(TransactionFactory.toKey([AddressAliasTransactionV1.TRANSACTION_TYPE.value, AddressAliasTransactionV1.TRANSACTION_VERSION]), AddressAliasTransactionV1);
		mapping.set(TransactionFactory.toKey([MosaicAliasTransactionV1.TRANSACTION_TYPE.value, MosaicAliasTransactionV1.TRANSACTION_VERSION]), MosaicAliasTransactionV1);
		mapping.set(TransactionFactory.toKey([NamespaceRegistrationTransactionV1.TRANSACTION_TYPE.value, NamespaceRegistrationTransactionV1.TRANSACTION_VERSION]), NamespaceRegistrationTransactionV1);
		mapping.set(TransactionFactory.toKey([AccountAddressRestrictionTransactionV1.TRANSACTION_TYPE.value, AccountAddressRestrictionTransactionV1.TRANSACTION_VERSION]), AccountAddressRestrictionTransactionV1);
		mapping.set(TransactionFactory.toKey([AccountMosaicRestrictionTransactionV1.TRANSACTION_TYPE.value, AccountMosaicRestrictionTransactionV1.TRANSACTION_VERSION]), AccountMosaicRestrictionTransactionV1);
		mapping.set(TransactionFactory.toKey([AccountOperationRestrictionTransactionV1.TRANSACTION_TYPE.value, AccountOperationRestrictionTransactionV1.TRANSACTION_VERSION]), AccountOperationRestrictionTransactionV1);
		mapping.set(TransactionFactory.toKey([MosaicAddressRestrictionTransactionV1.TRANSACTION_TYPE.value, MosaicAddressRestrictionTransactionV1.TRANSACTION_VERSION]), MosaicAddressRestrictionTransactionV1);
		mapping.set(TransactionFactory.toKey([MosaicGlobalRestrictionTransactionV1.TRANSACTION_TYPE.value, MosaicGlobalRestrictionTransactionV1.TRANSACTION_VERSION]), MosaicGlobalRestrictionTransactionV1);
		mapping.set(TransactionFactory.toKey([TransferTransactionV1.TRANSACTION_TYPE.value, TransferTransactionV1.TRANSACTION_VERSION]), TransferTransactionV1);
		const discriminator = TransactionFactory.toKey([parent.type.value, parent.version]);
		const factory_class = mapping.get(discriminator);
		return factory_class.deserialize(view.buffer);
	}

	static createByName(entityName) {
		const mapping = {
			account_key_link_transaction_v1: AccountKeyLinkTransactionV1,
			node_key_link_transaction_v1: NodeKeyLinkTransactionV1,
			aggregate_complete_transaction_v1: AggregateCompleteTransactionV1,
			aggregate_complete_transaction_v2: AggregateCompleteTransactionV2,
			aggregate_bonded_transaction_v1: AggregateBondedTransactionV1,
			aggregate_bonded_transaction_v2: AggregateBondedTransactionV2,
			voting_key_link_transaction_v1: VotingKeyLinkTransactionV1,
			vrf_key_link_transaction_v1: VrfKeyLinkTransactionV1,
			hash_lock_transaction_v1: HashLockTransactionV1,
			secret_lock_transaction_v1: SecretLockTransactionV1,
			secret_proof_transaction_v1: SecretProofTransactionV1,
			account_metadata_transaction_v1: AccountMetadataTransactionV1,
			mosaic_metadata_transaction_v1: MosaicMetadataTransactionV1,
			namespace_metadata_transaction_v1: NamespaceMetadataTransactionV1,
			mosaic_definition_transaction_v1: MosaicDefinitionTransactionV1,
			mosaic_supply_change_transaction_v1: MosaicSupplyChangeTransactionV1,
			mosaic_supply_revocation_transaction_v1: MosaicSupplyRevocationTransactionV1,
			multisig_account_modification_transaction_v1: MultisigAccountModificationTransactionV1,
			address_alias_transaction_v1: AddressAliasTransactionV1,
			mosaic_alias_transaction_v1: MosaicAliasTransactionV1,
			namespace_registration_transaction_v1: NamespaceRegistrationTransactionV1,
			account_address_restriction_transaction_v1: AccountAddressRestrictionTransactionV1,
			account_mosaic_restriction_transaction_v1: AccountMosaicRestrictionTransactionV1,
			account_operation_restriction_transaction_v1: AccountOperationRestrictionTransactionV1,
			mosaic_address_restriction_transaction_v1: MosaicAddressRestrictionTransactionV1,
			mosaic_global_restriction_transaction_v1: MosaicGlobalRestrictionTransactionV1,
			transfer_transaction_v1: TransferTransactionV1
		};

		if (!Object.prototype.hasOwnProperty.call(mapping, entityName))
			throw RangeError(`unknown Transaction type ${entityName}`);

		return new mapping[entityName]();
	}
}

class EmbeddedTransactionFactory {
	static toKey(values) {
		if (1 === values.length)
			return values[0];

		// assume each key is at most 32bits
		return values.map(n => BigInt(n)).reduce((accumulator, value) => (accumulator << 32n) + value);
	}

	static deserialize(payload) {
		const parent = new EmbeddedTransaction();
		EmbeddedTransaction._deserialize(new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload), parent);

		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const mapping = new Map();
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedAccountKeyLinkTransactionV1.TRANSACTION_TYPE.value, EmbeddedAccountKeyLinkTransactionV1.TRANSACTION_VERSION]), EmbeddedAccountKeyLinkTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedNodeKeyLinkTransactionV1.TRANSACTION_TYPE.value, EmbeddedNodeKeyLinkTransactionV1.TRANSACTION_VERSION]), EmbeddedNodeKeyLinkTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedVotingKeyLinkTransactionV1.TRANSACTION_TYPE.value, EmbeddedVotingKeyLinkTransactionV1.TRANSACTION_VERSION]), EmbeddedVotingKeyLinkTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedVrfKeyLinkTransactionV1.TRANSACTION_TYPE.value, EmbeddedVrfKeyLinkTransactionV1.TRANSACTION_VERSION]), EmbeddedVrfKeyLinkTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedHashLockTransactionV1.TRANSACTION_TYPE.value, EmbeddedHashLockTransactionV1.TRANSACTION_VERSION]), EmbeddedHashLockTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedSecretLockTransactionV1.TRANSACTION_TYPE.value, EmbeddedSecretLockTransactionV1.TRANSACTION_VERSION]), EmbeddedSecretLockTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedSecretProofTransactionV1.TRANSACTION_TYPE.value, EmbeddedSecretProofTransactionV1.TRANSACTION_VERSION]), EmbeddedSecretProofTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedAccountMetadataTransactionV1.TRANSACTION_TYPE.value, EmbeddedAccountMetadataTransactionV1.TRANSACTION_VERSION]), EmbeddedAccountMetadataTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedMosaicMetadataTransactionV1.TRANSACTION_TYPE.value, EmbeddedMosaicMetadataTransactionV1.TRANSACTION_VERSION]), EmbeddedMosaicMetadataTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedNamespaceMetadataTransactionV1.TRANSACTION_TYPE.value, EmbeddedNamespaceMetadataTransactionV1.TRANSACTION_VERSION]), EmbeddedNamespaceMetadataTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedMosaicDefinitionTransactionV1.TRANSACTION_TYPE.value, EmbeddedMosaicDefinitionTransactionV1.TRANSACTION_VERSION]), EmbeddedMosaicDefinitionTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedMosaicSupplyChangeTransactionV1.TRANSACTION_TYPE.value, EmbeddedMosaicSupplyChangeTransactionV1.TRANSACTION_VERSION]), EmbeddedMosaicSupplyChangeTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedMosaicSupplyRevocationTransactionV1.TRANSACTION_TYPE.value, EmbeddedMosaicSupplyRevocationTransactionV1.TRANSACTION_VERSION]), EmbeddedMosaicSupplyRevocationTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedMultisigAccountModificationTransactionV1.TRANSACTION_TYPE.value, EmbeddedMultisigAccountModificationTransactionV1.TRANSACTION_VERSION]), EmbeddedMultisigAccountModificationTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedAddressAliasTransactionV1.TRANSACTION_TYPE.value, EmbeddedAddressAliasTransactionV1.TRANSACTION_VERSION]), EmbeddedAddressAliasTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedMosaicAliasTransactionV1.TRANSACTION_TYPE.value, EmbeddedMosaicAliasTransactionV1.TRANSACTION_VERSION]), EmbeddedMosaicAliasTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedNamespaceRegistrationTransactionV1.TRANSACTION_TYPE.value, EmbeddedNamespaceRegistrationTransactionV1.TRANSACTION_VERSION]), EmbeddedNamespaceRegistrationTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedAccountAddressRestrictionTransactionV1.TRANSACTION_TYPE.value, EmbeddedAccountAddressRestrictionTransactionV1.TRANSACTION_VERSION]), EmbeddedAccountAddressRestrictionTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedAccountMosaicRestrictionTransactionV1.TRANSACTION_TYPE.value, EmbeddedAccountMosaicRestrictionTransactionV1.TRANSACTION_VERSION]), EmbeddedAccountMosaicRestrictionTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedAccountOperationRestrictionTransactionV1.TRANSACTION_TYPE.value, EmbeddedAccountOperationRestrictionTransactionV1.TRANSACTION_VERSION]), EmbeddedAccountOperationRestrictionTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedMosaicAddressRestrictionTransactionV1.TRANSACTION_TYPE.value, EmbeddedMosaicAddressRestrictionTransactionV1.TRANSACTION_VERSION]), EmbeddedMosaicAddressRestrictionTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedMosaicGlobalRestrictionTransactionV1.TRANSACTION_TYPE.value, EmbeddedMosaicGlobalRestrictionTransactionV1.TRANSACTION_VERSION]), EmbeddedMosaicGlobalRestrictionTransactionV1);
		mapping.set(EmbeddedTransactionFactory.toKey([EmbeddedTransferTransactionV1.TRANSACTION_TYPE.value, EmbeddedTransferTransactionV1.TRANSACTION_VERSION]), EmbeddedTransferTransactionV1);
		const discriminator = EmbeddedTransactionFactory.toKey([parent.type.value, parent.version]);
		const factory_class = mapping.get(discriminator);
		return factory_class.deserialize(view.buffer);
	}

	static createByName(entityName) {
		const mapping = {
			account_key_link_transaction_v1: EmbeddedAccountKeyLinkTransactionV1,
			node_key_link_transaction_v1: EmbeddedNodeKeyLinkTransactionV1,
			voting_key_link_transaction_v1: EmbeddedVotingKeyLinkTransactionV1,
			vrf_key_link_transaction_v1: EmbeddedVrfKeyLinkTransactionV1,
			hash_lock_transaction_v1: EmbeddedHashLockTransactionV1,
			secret_lock_transaction_v1: EmbeddedSecretLockTransactionV1,
			secret_proof_transaction_v1: EmbeddedSecretProofTransactionV1,
			account_metadata_transaction_v1: EmbeddedAccountMetadataTransactionV1,
			mosaic_metadata_transaction_v1: EmbeddedMosaicMetadataTransactionV1,
			namespace_metadata_transaction_v1: EmbeddedNamespaceMetadataTransactionV1,
			mosaic_definition_transaction_v1: EmbeddedMosaicDefinitionTransactionV1,
			mosaic_supply_change_transaction_v1: EmbeddedMosaicSupplyChangeTransactionV1,
			mosaic_supply_revocation_transaction_v1: EmbeddedMosaicSupplyRevocationTransactionV1,
			multisig_account_modification_transaction_v1: EmbeddedMultisigAccountModificationTransactionV1,
			address_alias_transaction_v1: EmbeddedAddressAliasTransactionV1,
			mosaic_alias_transaction_v1: EmbeddedMosaicAliasTransactionV1,
			namespace_registration_transaction_v1: EmbeddedNamespaceRegistrationTransactionV1,
			account_address_restriction_transaction_v1: EmbeddedAccountAddressRestrictionTransactionV1,
			account_mosaic_restriction_transaction_v1: EmbeddedAccountMosaicRestrictionTransactionV1,
			account_operation_restriction_transaction_v1: EmbeddedAccountOperationRestrictionTransactionV1,
			mosaic_address_restriction_transaction_v1: EmbeddedMosaicAddressRestrictionTransactionV1,
			mosaic_global_restriction_transaction_v1: EmbeddedMosaicGlobalRestrictionTransactionV1,
			transfer_transaction_v1: EmbeddedTransferTransactionV1
		};

		if (!Object.prototype.hasOwnProperty.call(mapping, entityName))
			throw RangeError(`unknown EmbeddedTransaction type ${entityName}`);

		return new mapping[entityName]();
	}
}

class BlockFactory {
	static toKey(values) {
		if (1 === values.length)
			return values[0];

		// assume each key is at most 32bits
		return values.map(n => BigInt(n)).reduce((accumulator, value) => (accumulator << 32n) + value);
	}

	static deserialize(payload) {
		const parent = new Block();
		Block._deserialize(new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload), parent);

		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const mapping = new Map();
		mapping.set(BlockFactory.toKey([NemesisBlockV1.BLOCK_TYPE.value]), NemesisBlockV1);
		mapping.set(BlockFactory.toKey([NormalBlockV1.BLOCK_TYPE.value]), NormalBlockV1);
		mapping.set(BlockFactory.toKey([ImportanceBlockV1.BLOCK_TYPE.value]), ImportanceBlockV1);
		const discriminator = BlockFactory.toKey([parent.type.value]);
		const factory_class = mapping.get(discriminator);
		return factory_class.deserialize(view.buffer);
	}

	static createByName(entityName) {
		const mapping = {
			nemesis_block_v1: NemesisBlockV1,
			normal_block_v1: NormalBlockV1,
			importance_block_v1: ImportanceBlockV1
		};

		if (!Object.prototype.hasOwnProperty.call(mapping, entityName))
			throw RangeError(`unknown Block type ${entityName}`);

		return new mapping[entityName]();
	}
}

class ReceiptFactory {
	static toKey(values) {
		if (1 === values.length)
			return values[0];

		// assume each key is at most 32bits
		return values.map(n => BigInt(n)).reduce((accumulator, value) => (accumulator << 32n) + value);
	}

	static deserialize(payload) {
		const parent = new Receipt();
		Receipt._deserialize(new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload), parent);

		const view = new _utils_BufferView_js__WEBPACK_IMPORTED_MODULE_2__["default"](payload);
		const mapping = new Map();
		mapping.set(ReceiptFactory.toKey([HarvestFeeReceipt.RECEIPT_TYPE.value]), HarvestFeeReceipt);
		mapping.set(ReceiptFactory.toKey([InflationReceipt.RECEIPT_TYPE.value]), InflationReceipt);
		mapping.set(ReceiptFactory.toKey([LockHashCreatedFeeReceipt.RECEIPT_TYPE.value]), LockHashCreatedFeeReceipt);
		mapping.set(ReceiptFactory.toKey([LockHashCompletedFeeReceipt.RECEIPT_TYPE.value]), LockHashCompletedFeeReceipt);
		mapping.set(ReceiptFactory.toKey([LockHashExpiredFeeReceipt.RECEIPT_TYPE.value]), LockHashExpiredFeeReceipt);
		mapping.set(ReceiptFactory.toKey([LockSecretCreatedFeeReceipt.RECEIPT_TYPE.value]), LockSecretCreatedFeeReceipt);
		mapping.set(ReceiptFactory.toKey([LockSecretCompletedFeeReceipt.RECEIPT_TYPE.value]), LockSecretCompletedFeeReceipt);
		mapping.set(ReceiptFactory.toKey([LockSecretExpiredFeeReceipt.RECEIPT_TYPE.value]), LockSecretExpiredFeeReceipt);
		mapping.set(ReceiptFactory.toKey([MosaicExpiredReceipt.RECEIPT_TYPE.value]), MosaicExpiredReceipt);
		mapping.set(ReceiptFactory.toKey([MosaicRentalFeeReceipt.RECEIPT_TYPE.value]), MosaicRentalFeeReceipt);
		mapping.set(ReceiptFactory.toKey([NamespaceExpiredReceipt.RECEIPT_TYPE.value]), NamespaceExpiredReceipt);
		mapping.set(ReceiptFactory.toKey([NamespaceDeletedReceipt.RECEIPT_TYPE.value]), NamespaceDeletedReceipt);
		mapping.set(ReceiptFactory.toKey([NamespaceRentalFeeReceipt.RECEIPT_TYPE.value]), NamespaceRentalFeeReceipt);
		const discriminator = ReceiptFactory.toKey([parent.type.value]);
		const factory_class = mapping.get(discriminator);
		return factory_class.deserialize(view.buffer);
	}

	static createByName(entityName) {
		const mapping = {
			harvest_fee_receipt: HarvestFeeReceipt,
			inflation_receipt: InflationReceipt,
			lock_hash_created_fee_receipt: LockHashCreatedFeeReceipt,
			lock_hash_completed_fee_receipt: LockHashCompletedFeeReceipt,
			lock_hash_expired_fee_receipt: LockHashExpiredFeeReceipt,
			lock_secret_created_fee_receipt: LockSecretCreatedFeeReceipt,
			lock_secret_completed_fee_receipt: LockSecretCompletedFeeReceipt,
			lock_secret_expired_fee_receipt: LockSecretExpiredFeeReceipt,
			mosaic_expired_receipt: MosaicExpiredReceipt,
			mosaic_rental_fee_receipt: MosaicRentalFeeReceipt,
			namespace_expired_receipt: NamespaceExpiredReceipt,
			namespace_deleted_receipt: NamespaceDeletedReceipt,
			namespace_rental_fee_receipt: NamespaceRentalFeeReceipt
		};

		if (!Object.prototype.hasOwnProperty.call(mapping, entityName))
			throw RangeError(`unknown Receipt type ${entityName}`);

		return new mapping[entityName]();
	}
}


/***/ }),

/***/ "./node_modules/symbol-sdk/src/symbol/models_ts.js":
/*!*********************************************************!*\
  !*** ./node_modules/symbol-sdk/src/symbol/models_ts.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AccountAddressRestrictionTransactionV1Descriptor: () => (/* binding */ AccountAddressRestrictionTransactionV1Descriptor),
/* harmony export */   AccountKeyLinkTransactionV1Descriptor: () => (/* binding */ AccountKeyLinkTransactionV1Descriptor),
/* harmony export */   AccountMetadataTransactionV1Descriptor: () => (/* binding */ AccountMetadataTransactionV1Descriptor),
/* harmony export */   AccountMosaicRestrictionTransactionV1Descriptor: () => (/* binding */ AccountMosaicRestrictionTransactionV1Descriptor),
/* harmony export */   AccountOperationRestrictionTransactionV1Descriptor: () => (/* binding */ AccountOperationRestrictionTransactionV1Descriptor),
/* harmony export */   AddressAliasTransactionV1Descriptor: () => (/* binding */ AddressAliasTransactionV1Descriptor),
/* harmony export */   AggregateBondedTransactionV1Descriptor: () => (/* binding */ AggregateBondedTransactionV1Descriptor),
/* harmony export */   AggregateBondedTransactionV2Descriptor: () => (/* binding */ AggregateBondedTransactionV2Descriptor),
/* harmony export */   AggregateCompleteTransactionV1Descriptor: () => (/* binding */ AggregateCompleteTransactionV1Descriptor),
/* harmony export */   AggregateCompleteTransactionV2Descriptor: () => (/* binding */ AggregateCompleteTransactionV2Descriptor),
/* harmony export */   CosignatureDescriptor: () => (/* binding */ CosignatureDescriptor),
/* harmony export */   DetachedCosignatureDescriptor: () => (/* binding */ DetachedCosignatureDescriptor),
/* harmony export */   HashLockTransactionV1Descriptor: () => (/* binding */ HashLockTransactionV1Descriptor),
/* harmony export */   MosaicAddressRestrictionTransactionV1Descriptor: () => (/* binding */ MosaicAddressRestrictionTransactionV1Descriptor),
/* harmony export */   MosaicAliasTransactionV1Descriptor: () => (/* binding */ MosaicAliasTransactionV1Descriptor),
/* harmony export */   MosaicDefinitionTransactionV1Descriptor: () => (/* binding */ MosaicDefinitionTransactionV1Descriptor),
/* harmony export */   MosaicDescriptor: () => (/* binding */ MosaicDescriptor),
/* harmony export */   MosaicGlobalRestrictionTransactionV1Descriptor: () => (/* binding */ MosaicGlobalRestrictionTransactionV1Descriptor),
/* harmony export */   MosaicMetadataTransactionV1Descriptor: () => (/* binding */ MosaicMetadataTransactionV1Descriptor),
/* harmony export */   MosaicSupplyChangeTransactionV1Descriptor: () => (/* binding */ MosaicSupplyChangeTransactionV1Descriptor),
/* harmony export */   MosaicSupplyRevocationTransactionV1Descriptor: () => (/* binding */ MosaicSupplyRevocationTransactionV1Descriptor),
/* harmony export */   MultisigAccountModificationTransactionV1Descriptor: () => (/* binding */ MultisigAccountModificationTransactionV1Descriptor),
/* harmony export */   NamespaceMetadataTransactionV1Descriptor: () => (/* binding */ NamespaceMetadataTransactionV1Descriptor),
/* harmony export */   NamespaceRegistrationTransactionV1Descriptor: () => (/* binding */ NamespaceRegistrationTransactionV1Descriptor),
/* harmony export */   NodeKeyLinkTransactionV1Descriptor: () => (/* binding */ NodeKeyLinkTransactionV1Descriptor),
/* harmony export */   SecretLockTransactionV1Descriptor: () => (/* binding */ SecretLockTransactionV1Descriptor),
/* harmony export */   SecretProofTransactionV1Descriptor: () => (/* binding */ SecretProofTransactionV1Descriptor),
/* harmony export */   TransferTransactionV1Descriptor: () => (/* binding */ TransferTransactionV1Descriptor),
/* harmony export */   UnresolvedMosaicDescriptor: () => (/* binding */ UnresolvedMosaicDescriptor),
/* harmony export */   VotingKeyLinkTransactionV1Descriptor: () => (/* binding */ VotingKeyLinkTransactionV1Descriptor),
/* harmony export */   VrfKeyLinkTransactionV1Descriptor: () => (/* binding */ VrfKeyLinkTransactionV1Descriptor)
/* harmony export */ });
/* harmony import */ var _Network_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Network.js */ "./node_modules/symbol-sdk/src/symbol/Network.js");
/* harmony import */ var _models_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./models.js */ "./node_modules/symbol-sdk/src/symbol/models.js");
/* harmony import */ var _CryptoTypes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CryptoTypes.js */ "./node_modules/symbol-sdk/src/CryptoTypes.js");
/* eslint-disable max-len */





/**
 * Type safe descriptor used to generate a descriptor map for MosaicDescriptor.
 *
 * A quantity of a certain mosaic.
 */
class MosaicDescriptor {
	/**
	 * Creates a descriptor for Mosaic.
	 * @param {models.MosaicId} mosaicId Mosaic identifier.
	 * @param {models.Amount} amount Mosaic amount.
	 */
	constructor(mosaicId, amount) {
		this.rawDescriptor = {
			mosaicId,
			amount
		};
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for UnresolvedMosaicDescriptor.
 *
 * A quantity of a certain mosaic, specified either through a MosaicId or an alias.
 */
class UnresolvedMosaicDescriptor {
	/**
	 * Creates a descriptor for UnresolvedMosaic.
	 * @param {models.UnresolvedMosaicId} mosaicId Unresolved mosaic identifier.
	 * @param {models.Amount} amount Mosaic amount.
	 */
	constructor(mosaicId, amount) {
		this.rawDescriptor = {
			mosaicId,
			amount
		};
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for AccountKeyLinkTransactionV1Descriptor.
 *
 * This transaction is required for all accounts wanting to activate remote or delegated harvesting (V1, latest).
 * Announce an AccountKeyLinkTransaction to delegate the account importance score to a proxy account.
 */
class AccountKeyLinkTransactionV1Descriptor {
	/**
	 * Creates a descriptor for AccountKeyLinkTransactionV1.
	 * @param {PublicKey} linkedPublicKey Linked public key.
	 * @param {models.LinkAction} linkAction Account link action.
	 */
	constructor(linkedPublicKey, linkAction) {
		this.rawDescriptor = {
			type: 'account_key_link_transaction_v1',
			linkedPublicKey,
			linkAction
		};
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for NodeKeyLinkTransactionV1Descriptor.
 *
 * This transaction is required for all accounts willing to activate delegated harvesting (V1, latest).
 * Announce a NodeKeyLinkTransaction to link an account with a public key used by TLS to create sessions.
 */
class NodeKeyLinkTransactionV1Descriptor {
	/**
	 * Creates a descriptor for NodeKeyLinkTransactionV1.
	 * @param {PublicKey} linkedPublicKey Linked public key.
	 * @param {models.LinkAction} linkAction Account link action.
	 */
	constructor(linkedPublicKey, linkAction) {
		this.rawDescriptor = {
			type: 'node_key_link_transaction_v1',
			linkedPublicKey,
			linkAction
		};
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for CosignatureDescriptor.
 *
 * Cosignature attached to an AggregateCompleteTransaction or AggregateBondedTransaction.
 */
class CosignatureDescriptor {
	/**
	 * Creates a descriptor for Cosignature.
	 * @param {bigint} version Version.
	 * @param {PublicKey} signerPublicKey Cosigner public key.
	 * @param {models.Signature} signature Transaction signature.
	 */
	constructor(version, signerPublicKey, signature) {
		this.rawDescriptor = {
			version,
			signerPublicKey,
			signature
		};
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for DetachedCosignatureDescriptor.
 *
 * Cosignature detached from an AggregateCompleteTransaction or AggregateBondedTransaction.
 */
class DetachedCosignatureDescriptor {
	/**
	 * Creates a descriptor for DetachedCosignature.
	 * @param {bigint} version Version.
	 * @param {PublicKey} signerPublicKey Cosigner public key.
	 * @param {models.Signature} signature Transaction signature.
	 * @param {Hash256} parentHash Hash of the AggregateBondedTransaction that is signed by this cosignature.
	 */
	constructor(version, signerPublicKey, signature, parentHash) {
		this.rawDescriptor = {
			version,
			signerPublicKey,
			signature,
			parentHash
		};
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for AggregateCompleteTransactionV1Descriptor.
 *
 * Send transactions in batches to different accounts (V1, deprecated).
 * Use this transaction when all required signatures are available when the transaction is created.
 */
class AggregateCompleteTransactionV1Descriptor {
	/**
	 * Creates a descriptor for AggregateCompleteTransactionV1.
	 * @param {Hash256} transactionsHash Hash of the aggregate's transaction.
	 * @param {models.EmbeddedTransaction[]|undefined} transactions Embedded transaction data.
	Transactions are variable-sized and the total payload size is in bytes.
	Embedded transactions cannot be aggregates.
	 * @param {models.Cosignature[]|undefined} cosignatures Cosignatures data.
	Fills up remaining body space after transactions.
	 */
	constructor(transactionsHash, transactions = undefined, cosignatures = undefined) {
		this.rawDescriptor = {
			type: 'aggregate_complete_transaction_v1',
			transactionsHash
		};

		if (transactions)
			this.rawDescriptor.transactions = transactions;

		if (cosignatures)
			this.rawDescriptor.cosignatures = cosignatures;
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for AggregateCompleteTransactionV2Descriptor.
 *
 * Send transactions in batches to different accounts (V2, latest).
 * Use this transaction when all required signatures are available when the transaction is created.
 */
class AggregateCompleteTransactionV2Descriptor {
	/**
	 * Creates a descriptor for AggregateCompleteTransactionV2.
	 * @param {Hash256} transactionsHash Hash of the aggregate's transaction.
	 * @param {models.EmbeddedTransaction[]|undefined} transactions Embedded transaction data.
	Transactions are variable-sized and the total payload size is in bytes.
	Embedded transactions cannot be aggregates.
	 * @param {models.Cosignature[]|undefined} cosignatures Cosignatures data.
	Fills up remaining body space after transactions.
	 */
	constructor(transactionsHash, transactions = undefined, cosignatures = undefined) {
		this.rawDescriptor = {
			type: 'aggregate_complete_transaction_v2',
			transactionsHash
		};

		if (transactions)
			this.rawDescriptor.transactions = transactions;

		if (cosignatures)
			this.rawDescriptor.cosignatures = cosignatures;
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for AggregateBondedTransactionV1Descriptor.
 *
 * Propose an arrangement of transactions between different accounts (V1, deprecated).
 * Use this transaction when not all required signatures are available when the transaction is created.
 * Missing signatures must be provided using a Cosignature or DetachedCosignature.
 * To prevent spam attacks, before trying to announce this transaction a HashLockTransaction must be successfully announced and confirmed.
 */
class AggregateBondedTransactionV1Descriptor {
	/**
	 * Creates a descriptor for AggregateBondedTransactionV1.
	 * @param {Hash256} transactionsHash Hash of the aggregate's transaction.
	 * @param {models.EmbeddedTransaction[]|undefined} transactions Embedded transaction data.
	Transactions are variable-sized and the total payload size is in bytes.
	Embedded transactions cannot be aggregates.
	 * @param {models.Cosignature[]|undefined} cosignatures Cosignatures data.
	Fills up remaining body space after transactions.
	 */
	constructor(transactionsHash, transactions = undefined, cosignatures = undefined) {
		this.rawDescriptor = {
			type: 'aggregate_bonded_transaction_v1',
			transactionsHash
		};

		if (transactions)
			this.rawDescriptor.transactions = transactions;

		if (cosignatures)
			this.rawDescriptor.cosignatures = cosignatures;
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for AggregateBondedTransactionV2Descriptor.
 *
 * Propose an arrangement of transactions between different accounts (V2, latest).
 * Use this transaction when not all required signatures are available when the transaction is created.
 * Missing signatures must be provided using a Cosignature or DetachedCosignature.
 * To prevent spam attacks, before trying to announce this transaction a HashLockTransaction must be successfully announced and confirmed.
 */
class AggregateBondedTransactionV2Descriptor {
	/**
	 * Creates a descriptor for AggregateBondedTransactionV2.
	 * @param {Hash256} transactionsHash Hash of the aggregate's transaction.
	 * @param {models.EmbeddedTransaction[]|undefined} transactions Embedded transaction data.
	Transactions are variable-sized and the total payload size is in bytes.
	Embedded transactions cannot be aggregates.
	 * @param {models.Cosignature[]|undefined} cosignatures Cosignatures data.
	Fills up remaining body space after transactions.
	 */
	constructor(transactionsHash, transactions = undefined, cosignatures = undefined) {
		this.rawDescriptor = {
			type: 'aggregate_bonded_transaction_v2',
			transactionsHash
		};

		if (transactions)
			this.rawDescriptor.transactions = transactions;

		if (cosignatures)
			this.rawDescriptor.cosignatures = cosignatures;
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for VotingKeyLinkTransactionV1Descriptor.
 *
 * Link an account with a public key required for finalization voting (V1, latest).
 * This transaction is required for node operators wanting to vote for [finalization](/concepts/block.html#finalization).
 * Announce a VotingKeyLinkTransaction to associate a voting key with an account during a fixed period. An account can be linked to up to **3** different voting keys at the same time.
 * The recommended production setting is to always have at least **2** linked keys with different ``endPoint`` values to ensure a key is registered after the first one expires.
 * See more details in [the manual node setup guide](/guides/network/running-a-symbol-node-manually.html#manual-voting-key-renewal).
 */
class VotingKeyLinkTransactionV1Descriptor {
	/**
	 * Creates a descriptor for VotingKeyLinkTransactionV1.
	 * @param {PublicKey} linkedPublicKey Linked voting public key.
	 * @param {models.FinalizationEpoch} startEpoch Starting finalization epoch.
	 * @param {models.FinalizationEpoch} endEpoch Ending finalization epoch.
	 * @param {models.LinkAction} linkAction Account link action.
	 */
	constructor(linkedPublicKey, startEpoch, endEpoch, linkAction) {
		this.rawDescriptor = {
			type: 'voting_key_link_transaction_v1',
			linkedPublicKey,
			startEpoch,
			endEpoch,
			linkAction
		};
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for VrfKeyLinkTransactionV1Descriptor.
 *
 * Link an account with a VRF public key required for harvesting (V1, latest).
 * Announce a VrfKeyLinkTransaction to link an account with a VRF public key. The linked key is used to randomize block production and leader/participant selection.
 * This transaction is required for all accounts wishing to [harvest](/concepts/harvesting.html).
 */
class VrfKeyLinkTransactionV1Descriptor {
	/**
	 * Creates a descriptor for VrfKeyLinkTransactionV1.
	 * @param {PublicKey} linkedPublicKey Linked VRF public key.
	 * @param {models.LinkAction} linkAction Account link action.
	 */
	constructor(linkedPublicKey, linkAction) {
		this.rawDescriptor = {
			type: 'vrf_key_link_transaction_v1',
			linkedPublicKey,
			linkAction
		};
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for HashLockTransactionV1Descriptor.
 *
 * Lock a deposit needed to announce an AggregateBondedTransaction (V1, latest).
 * An AggregateBondedTransaction consumes network resources as it is stored in every node's partial cache while it waits to be fully signed. To avoid spam attacks a HashLockTransaction must be announced and confirmed before an AggregateBondedTransaction can be announced. The HashLockTransaction locks a certain amount of funds (**10** XYM by default) until the aggregate is signed.
 * Upon completion of the aggregate, the locked funds become available again to the account that signed the HashLockTransaction.
 * If the lock expires before the aggregate is signed by all cosignatories (**48h by default), the locked funds become a reward collected by the block harvester at the height where the lock expires.
 * \note It is not necessary to sign the aggregate and its HashLockTransaction with the same account. For example, if Bob wants to announce an aggregate and does not have enough funds to announce a HashLockTransaction, he can ask Alice to announce the lock transaction for him by sharing the signed AggregateTransaction hash.
 */
class HashLockTransactionV1Descriptor {
	/**
	 * Creates a descriptor for HashLockTransactionV1.
	 * @param {UnresolvedMosaicDescriptor} mosaic Locked mosaic.
	 * @param {models.BlockDuration} duration Number of blocks for which a lock should be valid.
	The default maximum is 48h (See the `maxHashLockDuration` network property).
	 * @param {Hash256} hash Hash of the AggregateBondedTransaction to be confirmed before unlocking the mosaics.
	 */
	constructor(mosaic, duration, hash) {
		this.rawDescriptor = {
			type: 'hash_lock_transaction_v1',
			mosaic: mosaic.toMap(),
			duration,
			hash
		};
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for SecretLockTransactionV1Descriptor.
 *
 * Start a token swap between different chains (V1, latest).
 * Use a SecretLockTransaction to transfer mosaics between two accounts. The mosaics sent remain locked until a valid SecretProofTransaction unlocks them.
 * The default expiration date is **365 days** after announcement (See the `maxSecretLockDuration` network property). If the lock expires before a valid SecretProofTransaction is announced the locked amount goes back to the initiator of the SecretLockTransaction.
 */
class SecretLockTransactionV1Descriptor {
	/**
	 * Creates a descriptor for SecretLockTransactionV1.
	 * @param {Address} recipientAddress Address that receives the funds once successfully unlocked by a SecretProofTransaction.
	 * @param {Hash256} secret Hashed proof.
	 * @param {UnresolvedMosaicDescriptor} mosaic Locked mosaics.
	 * @param {models.BlockDuration} duration Number of blocks to wait for the SecretProofTransaction.
	 * @param {models.LockHashAlgorithm} hashAlgorithm Algorithm used to hash the proof.
	 */
	constructor(recipientAddress, secret, mosaic, duration, hashAlgorithm) {
		this.rawDescriptor = {
			type: 'secret_lock_transaction_v1',
			recipientAddress,
			secret,
			mosaic: mosaic.toMap(),
			duration,
			hashAlgorithm
		};
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for SecretProofTransactionV1Descriptor.
 *
 * Conclude a token swap between different chains (V1, latest).
 * Use a SecretProofTransaction to unlock the funds locked by a SecretLockTransaction.
 * The transaction must prove knowing the *proof* that unlocks the mosaics.
 */
class SecretProofTransactionV1Descriptor {
	/**
	 * Creates a descriptor for SecretProofTransactionV1.
	 * @param {Address} recipientAddress Address that receives the funds once unlocked.
	 * @param {Hash256} secret Hashed proof.
	 * @param {models.LockHashAlgorithm} hashAlgorithm Algorithm used to hash the proof.
	 * @param {Uint8Array|string|undefined} proof Original random set of bytes that were hashed.
	 */
	constructor(recipientAddress, secret, hashAlgorithm, proof = undefined) {
		this.rawDescriptor = {
			type: 'secret_proof_transaction_v1',
			recipientAddress,
			secret,
			hashAlgorithm
		};

		if (proof)
			this.rawDescriptor.proof = proof;
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for AccountMetadataTransactionV1Descriptor.
 *
 * Associate a key-value state ([metadata](/concepts/metadata.html)) to an **account** (V1, latest).
 * \note This transaction must **always** be wrapped in an AggregateTransaction so that a cosignature from `target_address` can be provided. Without this cosignature the transaction is invalid.
 * Compare to MosaicMetadataTransaction and NamespaceMetadataTransaction.
 */
class AccountMetadataTransactionV1Descriptor {
	/**
	 * Creates a descriptor for AccountMetadataTransactionV1.
	 * @param {Address} targetAddress Account whose metadata should be modified.
	 * @param {bigint} scopedMetadataKey Metadata key scoped to source, target and type.
	 * @param {number} valueSizeDelta Change in value size in bytes, compared to previous size.
	 * @param {Uint8Array|string|undefined} value Difference between existing value and new value. \note When there is no existing value, this array is directly used and `value_size_delta`==`value_size`. \note When there is an existing value, the new value is the byte-wise XOR of the previous value and this array.
	 */
	constructor(targetAddress, scopedMetadataKey, valueSizeDelta, value = undefined) {
		this.rawDescriptor = {
			type: 'account_metadata_transaction_v1',
			targetAddress,
			scopedMetadataKey,
			valueSizeDelta
		};

		if (value)
			this.rawDescriptor.value = value;
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for MosaicMetadataTransactionV1Descriptor.
 *
 * Associate a key-value state ([metadata](/concepts/metadata.html)) to a **mosaic** (V1, latest).
 * Compare to AccountMetadataTransaction and NamespaceMetadataTransaction.
 */
class MosaicMetadataTransactionV1Descriptor {
	/**
	 * Creates a descriptor for MosaicMetadataTransactionV1.
	 * @param {Address} targetAddress Account owning the mosaic whose metadata should be modified.
	 * @param {bigint} scopedMetadataKey Metadata key scoped to source, target and type.
	 * @param {models.UnresolvedMosaicId} targetMosaicId Mosaic whose metadata should be modified.
	 * @param {number} valueSizeDelta Change in value size in bytes, compared to previous size.
	 * @param {Uint8Array|string|undefined} value Difference between existing value and new value. \note When there is no existing value, this array is directly used and `value_size_delta`==`value_size`. \note When there is an existing value, the new value is the byte-wise XOR of the previous value and this array.
	 */
	constructor(targetAddress, scopedMetadataKey, targetMosaicId, valueSizeDelta, value = undefined) {
		this.rawDescriptor = {
			type: 'mosaic_metadata_transaction_v1',
			targetAddress,
			scopedMetadataKey,
			targetMosaicId,
			valueSizeDelta
		};

		if (value)
			this.rawDescriptor.value = value;
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for NamespaceMetadataTransactionV1Descriptor.
 *
 * Associate a key-value state ([metadata](/concepts/metadata.html)) to a **namespace** (V1, latest).
 * Compare to AccountMetadataTransaction and MosaicMetadataTransaction.
 */
class NamespaceMetadataTransactionV1Descriptor {
	/**
	 * Creates a descriptor for NamespaceMetadataTransactionV1.
	 * @param {Address} targetAddress Account owning the namespace whose metadata should be modified.
	 * @param {bigint} scopedMetadataKey Metadata key scoped to source, target and type.
	 * @param {models.NamespaceId} targetNamespaceId Namespace whose metadata should be modified.
	 * @param {number} valueSizeDelta Change in value size in bytes, compared to previous size.
	 * @param {Uint8Array|string|undefined} value Difference between existing value and new value. \note When there is no existing value, this array is directly used and `value_size_delta`==`value_size`. \note When there is an existing value, the new value is the byte-wise XOR of the previous value and this array.
	 */
	constructor(targetAddress, scopedMetadataKey, targetNamespaceId, valueSizeDelta, value = undefined) {
		this.rawDescriptor = {
			type: 'namespace_metadata_transaction_v1',
			targetAddress,
			scopedMetadataKey,
			targetNamespaceId,
			valueSizeDelta
		};

		if (value)
			this.rawDescriptor.value = value;
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for MosaicDefinitionTransactionV1Descriptor.
 *
 * Create a new  [mosaic](/concepts/mosaic.html) (V1, latest).
 */
class MosaicDefinitionTransactionV1Descriptor {
	/**
	 * Creates a descriptor for MosaicDefinitionTransactionV1.
	 * @param {models.MosaicId} id Unique mosaic identifier obtained from the generator account's public key and the `nonce`.
	The SDK's can take care of generating this ID for you.
	 * @param {models.BlockDuration} duration Mosaic duration expressed in blocks. If set to 0, the mosaic never expires.
	 * @param {models.MosaicNonce} nonce Random nonce used to generate the mosaic id.
	 * @param {models.MosaicFlags} flags Mosaic flags.
	 * @param {number} divisibility Mosaic divisibility.
	 */
	constructor(id, duration, nonce, flags, divisibility) {
		this.rawDescriptor = {
			type: 'mosaic_definition_transaction_v1',
			id,
			duration,
			nonce,
			flags,
			divisibility
		};
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for MosaicSupplyChangeTransactionV1Descriptor.
 *
 * Change the total supply of a mosaic (V1, latest).
 */
class MosaicSupplyChangeTransactionV1Descriptor {
	/**
	 * Creates a descriptor for MosaicSupplyChangeTransactionV1.
	 * @param {models.UnresolvedMosaicId} mosaicId Affected mosaic identifier.
	 * @param {models.Amount} delta Change amount. It cannot be negative, use the `action` field to indicate if this amount should be **added** or **subtracted** from the current supply.
	 * @param {models.MosaicSupplyChangeAction} action Supply change action.
	 */
	constructor(mosaicId, delta, action) {
		this.rawDescriptor = {
			type: 'mosaic_supply_change_transaction_v1',
			mosaicId,
			delta,
			action
		};
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for MosaicSupplyRevocationTransactionV1Descriptor.
 *
 * Revoke mosaic (V1, latest).
 */
class MosaicSupplyRevocationTransactionV1Descriptor {
	/**
	 * Creates a descriptor for MosaicSupplyRevocationTransactionV1.
	 * @param {Address} sourceAddress Address from which tokens should be revoked.
	 * @param {UnresolvedMosaicDescriptor} mosaic Revoked mosaic and amount.
	 */
	constructor(sourceAddress, mosaic) {
		this.rawDescriptor = {
			type: 'mosaic_supply_revocation_transaction_v1',
			sourceAddress,
			mosaic: mosaic.toMap()
		};
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for MultisigAccountModificationTransactionV1Descriptor.
 *
 * Create or modify a [multi-signature](/concepts/multisig-account.html) account (V1, latest).
 * This transaction allows you to: - Transform a regular account into a multisig account. - Change the configurable properties of a multisig account. - Add or delete cosignatories from a multisig account (removing all cosignatories turns a multisig account into a regular account again).
 */
class MultisigAccountModificationTransactionV1Descriptor {
	/**
	 * Creates a descriptor for MultisigAccountModificationTransactionV1.
	 * @param {number} minRemovalDelta Relative change to the **minimum** number of cosignatures required when **removing a cosignatory**.
	E.g., when moving from 0 to 2 cosignatures this number would be **2**. When moving from 4 to 3 cosignatures, the number would be **-1**.
	 * @param {number} minApprovalDelta Relative change to the **minimum** number of cosignatures required when **approving a transaction**.
	E.g., when moving from 0 to 2 cosignatures this number would be **2**. When moving from 4 to 3 cosignatures, the number would be **-1**.
	 * @param {Address[]|undefined} addressAdditions Cosignatory address additions.
	All accounts in this list will be able to cosign transactions on behalf of the multisig account. The number of required cosignatures depends on the configured minimum approval and minimum removal values.
	 * @param {Address[]|undefined} addressDeletions Cosignatory address deletions.
	All accounts in this list will stop being able to cosign transactions on behalf of the multisig account. A transaction containing **any** address in this array requires a number of cosignatures at least equal to the minimum removal value.
	 */
	constructor(minRemovalDelta, minApprovalDelta, addressAdditions = undefined, addressDeletions = undefined) {
		this.rawDescriptor = {
			type: 'multisig_account_modification_transaction_v1',
			minRemovalDelta,
			minApprovalDelta
		};

		if (addressAdditions)
			this.rawDescriptor.addressAdditions = addressAdditions;

		if (addressDeletions)
			this.rawDescriptor.addressDeletions = addressDeletions;
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for AddressAliasTransactionV1Descriptor.
 *
 * Attach or detach a [namespace](/concepts/namespace.html) (alias) to an account address (V1, latest).
 * A namespace can be assigned to any account present in the network (this is, an account which has received at least one transaction).
 */
class AddressAliasTransactionV1Descriptor {
	/**
	 * Creates a descriptor for AddressAliasTransactionV1.
	 * @param {models.NamespaceId} namespaceId Identifier of the namespace that will become (or stop being) an alias for the address.
	 * @param {Address} address Aliased address.
	 * @param {models.AliasAction} aliasAction Alias action.
	 */
	constructor(namespaceId, address, aliasAction) {
		this.rawDescriptor = {
			type: 'address_alias_transaction_v1',
			namespaceId,
			address,
			aliasAction
		};
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for MosaicAliasTransactionV1Descriptor.
 *
 * Attach or detach a [namespace](/concepts/namespace.html) to a Mosaic.(V1, latest)
 * Setting an alias to a mosaic is only possible if the account announcing this transaction has also created the namespace and the mosaic involved.
 */
class MosaicAliasTransactionV1Descriptor {
	/**
	 * Creates a descriptor for MosaicAliasTransactionV1.
	 * @param {models.NamespaceId} namespaceId Identifier of the namespace that will become (or stop being) an alias for the Mosaic.
	 * @param {models.MosaicId} mosaicId Aliased mosaic identifier.
	 * @param {models.AliasAction} aliasAction Alias action.
	 */
	constructor(namespaceId, mosaicId, aliasAction) {
		this.rawDescriptor = {
			type: 'mosaic_alias_transaction_v1',
			namespaceId,
			mosaicId,
			aliasAction
		};
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for NamespaceRegistrationTransactionV1Descriptor.
 *
 * Register (or renew a registration for) a [namespace](/concepts/namespace.html) (V1, latest).
 * Namespaces help keep assets organized.
 */
class NamespaceRegistrationTransactionV1Descriptor {
	/**
	 * Creates a descriptor for NamespaceRegistrationTransactionV1.
	 * @param {models.NamespaceId} id Namespace identifier.
	 * @param {models.NamespaceRegistrationType} registrationType Namespace registration type.
	 * @param {models.BlockDuration|undefined} duration Number of confirmed blocks you would like to rent the namespace for. Required for root namespaces.
	 * @param {models.NamespaceId|undefined} parentId Parent namespace identifier. Required for sub-namespaces.
	 * @param {Uint8Array|string|undefined} name Namespace name.
	 */
	constructor(id, registrationType, duration = undefined, parentId = undefined, name = undefined) {
		this.rawDescriptor = {
			type: 'namespace_registration_transaction_v1',
			id,
			registrationType
		};

		if (duration)
			this.rawDescriptor.duration = duration;

		if (parentId)
			this.rawDescriptor.parentId = parentId;

		if (name)
			this.rawDescriptor.name = name;
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for AccountAddressRestrictionTransactionV1Descriptor.
 *
 * Allow or block incoming and outgoing transactions for a given a set of addresses (V1, latest).
 */
class AccountAddressRestrictionTransactionV1Descriptor {
	/**
	 * Creates a descriptor for AccountAddressRestrictionTransactionV1.
	 * @param {models.AccountRestrictionFlags} restrictionFlags Type of restriction being applied to the listed addresses.
	 * @param {Address[]|undefined} restrictionAdditions Array of account addresses being added to the restricted list.
	 * @param {Address[]|undefined} restrictionDeletions Array of account addresses being removed from the restricted list.
	 */
	constructor(restrictionFlags, restrictionAdditions = undefined, restrictionDeletions = undefined) {
		this.rawDescriptor = {
			type: 'account_address_restriction_transaction_v1',
			restrictionFlags
		};

		if (restrictionAdditions)
			this.rawDescriptor.restrictionAdditions = restrictionAdditions;

		if (restrictionDeletions)
			this.rawDescriptor.restrictionDeletions = restrictionDeletions;
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for AccountMosaicRestrictionTransactionV1Descriptor.
 *
 * Allow or block incoming transactions containing a given set of mosaics (V1, latest).
 */
class AccountMosaicRestrictionTransactionV1Descriptor {
	/**
	 * Creates a descriptor for AccountMosaicRestrictionTransactionV1.
	 * @param {models.AccountRestrictionFlags} restrictionFlags Type of restriction being applied to the listed mosaics.
	 * @param {models.UnresolvedMosaicId[]|undefined} restrictionAdditions Array of mosaics being added to the restricted list.
	 * @param {models.UnresolvedMosaicId[]|undefined} restrictionDeletions Array of mosaics being removed from the restricted list.
	 */
	constructor(restrictionFlags, restrictionAdditions = undefined, restrictionDeletions = undefined) {
		this.rawDescriptor = {
			type: 'account_mosaic_restriction_transaction_v1',
			restrictionFlags
		};

		if (restrictionAdditions)
			this.rawDescriptor.restrictionAdditions = restrictionAdditions;

		if (restrictionDeletions)
			this.rawDescriptor.restrictionDeletions = restrictionDeletions;
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for AccountOperationRestrictionTransactionV1Descriptor.
 *
 * Allow or block outgoing transactions depending on their transaction type (V1, latest).
 */
class AccountOperationRestrictionTransactionV1Descriptor {
	/**
	 * Creates a descriptor for AccountOperationRestrictionTransactionV1.
	 * @param {models.AccountRestrictionFlags} restrictionFlags Type of restriction being applied to the listed transaction types.
	 * @param {models.TransactionType[]|undefined} restrictionAdditions Array of transaction types being added to the restricted list.
	 * @param {models.TransactionType[]|undefined} restrictionDeletions Array of transaction types being rtemoved from the restricted list.
	 */
	constructor(restrictionFlags, restrictionAdditions = undefined, restrictionDeletions = undefined) {
		this.rawDescriptor = {
			type: 'account_operation_restriction_transaction_v1',
			restrictionFlags
		};

		if (restrictionAdditions)
			this.rawDescriptor.restrictionAdditions = restrictionAdditions;

		if (restrictionDeletions)
			this.rawDescriptor.restrictionDeletions = restrictionDeletions;
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for MosaicAddressRestrictionTransactionV1Descriptor.
 *
 * Set address specific rules to transfer a restrictable mosaic (V1, latest).
 */
class MosaicAddressRestrictionTransactionV1Descriptor {
	/**
	 * Creates a descriptor for MosaicAddressRestrictionTransactionV1.
	 * @param {models.UnresolvedMosaicId} mosaicId Identifier of the mosaic to which the restriction applies.
	 * @param {bigint} restrictionKey Restriction key.
	 * @param {bigint} previousRestrictionValue Previous restriction value. Set `previousRestrictionValue` to `FFFFFFFFFFFFFFFF` if the target address does not have a previous restriction value for this mosaic id and restriction key.
	 * @param {bigint} newRestrictionValue New restriction value.
	 * @param {Address} targetAddress Address being restricted.
	 */
	constructor(mosaicId, restrictionKey, previousRestrictionValue, newRestrictionValue, targetAddress) {
		this.rawDescriptor = {
			type: 'mosaic_address_restriction_transaction_v1',
			mosaicId,
			restrictionKey,
			previousRestrictionValue,
			newRestrictionValue,
			targetAddress
		};
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for MosaicGlobalRestrictionTransactionV1Descriptor.
 *
 * Set global rules to transfer a restrictable mosaic (V1, latest).
 */
class MosaicGlobalRestrictionTransactionV1Descriptor {
	/**
	 * Creates a descriptor for MosaicGlobalRestrictionTransactionV1.
	 * @param {models.UnresolvedMosaicId} mosaicId Identifier of the mosaic being restricted. The mosaic creator must be the signer of the transaction.
	 * @param {models.UnresolvedMosaicId} referenceMosaicId Identifier of the mosaic providing the restriction key. The mosaic global restriction for the mosaic identifier depends on global restrictions set on the reference mosaic. Set `reference_mosaic_id` to **0** if the mosaic giving the restriction equals the `mosaic_id`.
	 * @param {bigint} restrictionKey Restriction key relative to the reference mosaic identifier.
	 * @param {bigint} previousRestrictionValue Previous restriction value.
	 * @param {bigint} newRestrictionValue New restriction value.
	 * @param {models.MosaicRestrictionType} previousRestrictionType Previous restriction type.
	 * @param {models.MosaicRestrictionType} newRestrictionType New restriction type.
	 */
	constructor(
		mosaicId,
		referenceMosaicId,
		restrictionKey,
		previousRestrictionValue,
		newRestrictionValue,
		previousRestrictionType,
		newRestrictionType
	) {
		this.rawDescriptor = {
			type: 'mosaic_global_restriction_transaction_v1',
			mosaicId,
			referenceMosaicId,
			restrictionKey,
			previousRestrictionValue,
			newRestrictionValue,
			previousRestrictionType,
			newRestrictionType
		};
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}

/**
 * Type safe descriptor used to generate a descriptor map for TransferTransactionV1Descriptor.
 *
 * Send mosaics and messages between two accounts (V1, latest).
 */
class TransferTransactionV1Descriptor {
	/**
	 * Creates a descriptor for TransferTransactionV1.
	 * @param {Address} recipientAddress recipient address
	 * @param {UnresolvedMosaicDescriptor[]|undefined} mosaics attached mosaics
	 * @param {Uint8Array|string|undefined} message attached message
	 */
	constructor(recipientAddress, mosaics = undefined, message = undefined) {
		this.rawDescriptor = {
			type: 'transfer_transaction_v1',
			recipientAddress
		};

		if (mosaics)
			this.rawDescriptor.mosaics = mosaics.map(descriptor => descriptor.toMap());

		if (message)
			this.rawDescriptor.message = message;
	}

	/**
	 * Builds a representation of this descriptor that can be passed to a factory function.
	 * @returns {object} Descriptor that can be passed to a factory function.
	 */
	toMap() {
		return this.rawDescriptor;
	}
}


/***/ }),

/***/ "./node_modules/symbol-sdk/src/utils/base32.js":
/*!*****************************************************!*\
  !*** ./node_modules/symbol-sdk/src/utils/base32.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _charMapping_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./charMapping.js */ "./node_modules/symbol-sdk/src/utils/charMapping.js");


const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
const DECODED_BLOCK_SIZE = 5;
const ENCODED_BLOCK_SIZE = 8;

// region encode

const encodeBlock = (input, inputOffset, output, outputOffset) => {
	output[outputOffset + 0] = ALPHABET[input[inputOffset + 0] >> 3];
	output[outputOffset + 1] = ALPHABET[((input[inputOffset + 0] & 0x07) << 2) | (input[inputOffset + 1] >> 6)];
	output[outputOffset + 2] = ALPHABET[(input[inputOffset + 1] & 0x3E) >> 1];
	output[outputOffset + 3] = ALPHABET[((input[inputOffset + 1] & 0x01) << 4) | (input[inputOffset + 2] >> 4)];
	output[outputOffset + 4] = ALPHABET[((input[inputOffset + 2] & 0x0F) << 1) | (input[inputOffset + 3] >> 7)];
	output[outputOffset + 5] = ALPHABET[(input[inputOffset + 3] & 0x7F) >> 2];
	output[outputOffset + 6] = ALPHABET[((input[inputOffset + 3] & 0x03) << 3) | (input[inputOffset + 4] >> 5)];
	output[outputOffset + 7] = ALPHABET[input[inputOffset + 4] & 0x1F];
};

// endregion

// region decode

const Char_To_Decoded_Char_Map = (() => {
	const builder = _charMapping_js__WEBPACK_IMPORTED_MODULE_0__["default"].createBuilder();
	builder.addRange('A', 'Z', 0);
	builder.addRange('2', '7', 26);
	return builder.map;
})();

const decodeChar = c => {
	const decodedChar = Char_To_Decoded_Char_Map[c];
	if (undefined !== decodedChar)
		return decodedChar;

	throw Error(`illegal base32 character ${c}`);
};

const decodeBlock = (input, inputOffset, output, outputOffset) => {
	const bytes = new Uint8Array(ENCODED_BLOCK_SIZE);
	for (let i = 0; i < ENCODED_BLOCK_SIZE; ++i)
		bytes[i] = decodeChar(input[inputOffset + i]);

	output[outputOffset + 0] = (bytes[0] << 3) | (bytes[1] >> 2);
	output[outputOffset + 1] = ((bytes[1] & 0x03) << 6) | (bytes[2] << 1) | (bytes[3] >> 4);
	output[outputOffset + 2] = ((bytes[3] & 0x0F) << 4) | (bytes[4] >> 1);
	output[outputOffset + 3] = ((bytes[4] & 0x01) << 7) | (bytes[5] << 2) | (bytes[6] >> 3);
	output[outputOffset + 4] = ((bytes[6] & 0x07) << 5) | bytes[7];
};

// endregion

/**
 * Base32 encodes a binary buffer.
 * @param {Uint8Array} data Binary data to encode.
 * @returns {string} Base32 encoded string corresponding to the input data.
 */
const encode = data => {
	if (0 !== data.length % DECODED_BLOCK_SIZE)
		throw Error(`decoded size must be multiple of ${DECODED_BLOCK_SIZE}`);

	const output = new Array(data.length / DECODED_BLOCK_SIZE * ENCODED_BLOCK_SIZE);
	for (let i = 0; i < data.length / DECODED_BLOCK_SIZE; ++i)
		encodeBlock(data, i * DECODED_BLOCK_SIZE, output, i * ENCODED_BLOCK_SIZE);

	return output.join('');
};

/**
 * Base32 decodes a base32 encoded string.
 * @param {string} encoded Base32 encoded string to decode.
 * @returns {Uint8Array} Binary data corresponding to the input string.
 */
const decode = encoded => {
	if (0 !== encoded.length % ENCODED_BLOCK_SIZE)
		throw Error(`encoded size must be multiple of ${ENCODED_BLOCK_SIZE}`);

	const output = new Uint8Array(encoded.length / ENCODED_BLOCK_SIZE * DECODED_BLOCK_SIZE);
	for (let i = 0; i < encoded.length / ENCODED_BLOCK_SIZE; ++i)
		decodeBlock(encoded, i * ENCODED_BLOCK_SIZE, output, i * DECODED_BLOCK_SIZE);

	return output;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ encode, decode });


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_symbol-sdk_src_symbol_index_js.6f0a5146651bd4bd3ac9.js.map